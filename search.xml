<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>了解Base64编码解码</title>
    <url>/2019/01/05/base64/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-161cc8afdcaec6f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="了解Base64编码解码"></p>
<blockquote>
<p>我们经常说Base64，那Base64到底是什么呢？<br><a href="https://zh.wikipedia.org/zh-hans/Base64"><strong>Base64</strong></a>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制数据</a>的表示方法，常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE" title="数据">数据</a>的场合，表示、传输、存储一些二进制数据，会将不便于查看的二进制数据用Base64进行表示。所以Bsea64经常用于密码学中，因为密码学通常用二进制进行加密，加密的结果用Base64编码来表示并传输。</p>
</blockquote>
<p>我们想了解Base64，其实看下面的Base64索引表就可以了。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-f9b1a93c393d27f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Base64索引表"></p>
<p>在Base64中的可打印字符包括<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D" title="拉丁字母">字母</a><code>A-Z</code>、<code>a-z</code>、<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97" title="数字">数字</a><code>0-9</code>共有62个字符，加上<code>+</code>、<code>/</code>共64个字符，实际上还有一个字符<code>=</code>来作为后缀。比如：编码Man<br><img src="https://upload-images.jianshu.io/upload_images/5741330-578423235d58ea16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编码Man"></p>
<p>当Base64对一个二进制数据进行编码时，每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>为一个单元，对应某个可打印字符。3个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82" title="字节">字节</a>有24个位元，对应于4个Base64单元，即3个字节可由4个可打印字符来表示，所以最少要24个比特位。如果不足24位，就在后面补0，后面补的0就会用<code>=</code>来表示，所以<code>=</code>也只会在最后面。</p>
<h4 id="终端演示Base64编码"><a href="#终端演示Base64编码" class="headerlink" title="终端演示Base64编码"></a>终端演示Base64编码</h4><pre class="line-numbers language-none"><code class="language-none">// 通过Base64将111图片进行编码，生成111.txt文件
$ base64 111.png -o 111.txt
// 对111.txt文件解码，生成222.png
$ base64 111.txt -o 222.png -D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-a811b9c976ba1fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Base64编码"></p>
<p>左侧的图片是原始文件，通过Base64编码后输出右侧111.txt文件，再对111.txt文件解码还原。</p>
<h4 id="代码演示Base64编码"><a href="#代码演示Base64编码" class="headerlink" title="代码演示Base64编码"></a>代码演示Base64编码</h4><p>Base64也是在iOS7以后出现的，接下来用代码简单操作一下<br></p><pre class="line-numbers language-none"><code class="language-none">//
//  ViewController.m
//  Base64
//
//  Created by Vincent on 2019/1/14.
//  Copyright © 2019 Vincent. All rights reserved.
//

#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

- (NSString *)getBase64Encode:(NSString *)encodeStr {
    // 将传进来的string转成NSData，再进行Base64编码
    NSData *data = [encodeStr dataUsingEncoding:NSUTF8StringEncoding];
    return [data base64EncodedStringWithOptions:0];
}

- (NSString *)getBase64Decode:(NSString *)decodeStr {
     // 由于传过来的是Base64编码字符串，则不需要先转二进制再解码，可以直接通过NSData初始化方法解码
    NSData *data = [[NSData alloc] initWithBase64EncodedString:decodeStr options:0];
    // 将data转成string
    return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    NSLog(@"----编码:%@", [self getBase64Encode:@"abc"]);
    NSLog(@"####解码:%@", [self getBase64Decode:[self getBase64Encode:@"abc"]]);
}

@end
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<ul>
<li>打印结果<pre class="line-numbers language-none"><code class="language-none">----编码:YWJj
####解码:abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>终端验证<pre class="line-numbers language-none"><code class="language-none">// 通过Base64将abc进行编码
$  echo -n abc | base64
YWJj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
验证通过！！！但是通过Base64编码，我们会发现编码结果会变大1/3。<br>该文章为记录本人的学习路程，希望能够帮助大家！！！</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密算法原理--OpenSSL演示、iOS代码运用及CCCrypt安全隐患</title>
    <url>/2019/01/13/cccrypt/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6fba0bae30b20faa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对称加密算法原理"></p>
<p>之前介绍了非对称加密算法，这篇文章介绍一下在非对称加密算法出现之前的对称加密算法，常见的对称加密算法、终端演示OpenSSL和iOS代码运用以及CCCrypt的安全隐患等。</p>
<blockquote>
<p>对称加密算法：明文通过密钥加密得到密文，密文再通过这个密钥解密得到明文。所以在业务逻辑上相对没有非对称加密RSA的安全性高。</p>
</blockquote>
<h4 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h4><ul>
<li>DES<br>数据加密标准，但由于强度不高，暴力破解难度不是很高，所以用的很少。</li>
<li>3DES<br>使用3个密钥，对数据进行三次加密，强度增强。虽然强度相对DES有所提高，但是对称加密算法密钥的保存就很难，3DES的3个密钥更麻烦，所以3DES也没有被广泛使用。</li>
<li>AES<br>高级密码标准，加密强度非常高，被广泛使用，美国安全局和苹果钥匙串访问都是用了AES加密算法。</li>
</ul>
<h4 id="常用的两种加密模式"><a href="#常用的两种加密模式" class="headerlink" title="常用的两种加密模式"></a>常用的两种加密模式</h4><ul>
<li>ECB（Electronic Code Book）：电子密码本模式（每一块数据独立加密）<br>最基本的加密模式，也就是通常理解的加密，相同的明文将永远加密成相同的密文，无初始向量，容易受到密码本重放攻击，一般情况下很少用。</li>
<li>CBC（Cipher Block Chaining）：密码分组链接模式（使用一个密钥和一个初始化向量[IV]对数据执行加密。每一块数据加密都依赖上一块数据，有效的保证数据的完整性）<br>明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。CBC可以有效的保证密文的完整性，如果一个数据块在传递时丢失或改变，后面的数据将无法正常解密。</li>
</ul>
<p>当然了，除了对称加密和非对称加密外，我们肯定还听说过Hash</p>
<h4 id="Hash概述"><a href="#Hash概述" class="headerlink" title="Hash概述"></a>Hash概述</h4><blockquote>
<p>Hash：一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</p>
</blockquote>
<p>之前介绍了RSA加密算法，在RSA算法之后也衍生出很多加密算法，典型的算法就有HASH函数（也称之为散列函数，严格意义上不算是加密算法，只不过是和加密一起用），还有在RSA出现之前的对称加密算法，这些算法都是公开的。</p>
<h4 id="Hash特点"><a href="#Hash特点" class="headerlink" title="Hash特点"></a>Hash特点</h4><p>算法是公开的<br>相同的数据加密结果不变<br>不同的数据加密结果定长（MD5得到的结果默认是128位二进制，一般用16进制的32个字符来标识）<br>不可逆<br>信息摘要，信息“指纹”，用来做数据识别的</p>
<h4 id="HASH用途"><a href="#HASH用途" class="headerlink" title="HASH用途"></a>HASH用途</h4><p>密码加密：服务器不需要知道用户真实密码，只需要匹配HASH值<br>搜索引擎<br>版权<br>数字签名</p>
<h4 id="OpenSSL演示ECB和CBC的区别"><a href="#OpenSSL演示ECB和CBC的区别" class="headerlink" title="OpenSSL演示ECB和CBC的区别"></a>OpenSSL演示ECB和CBC的区别</h4><ul>
<li><p>OpenSSL演示ECB模式加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先创建一个待加密的message.txt文件，编辑内容
$ vi message.txt
$ cat message.txt
  Hello vincent!!!
// enc -des-ecb是对称加密算法DES的ECB模式，-K是密钥，616263就是ASCII码“abc”，-nosalt不加盐（OpenSSL默认会加盐），输出msg.bin
$ openssl enc -des-ecb -K 616263 -nosalt -in message.txt -out msg.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这时在文件夹内会多出一个加密过后的二进制文件msg.bin，修改message.txt文件的内容，再次进行加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先修改message.txt的内容，vincent-&gt;Vincent
$ vi message.txt
$ cat message.txt
  Hello Vincent!!!
// 再次对message.txt进行同样的方式加密，输出msg1.bin
$ openssl enc -des-ecb -K 616263 -nosalt -in message.txt -out msg1.bin
// 查看下msg.bin和msg1.bin有什么不同
$ xxd msg.bin
00000000: 6d87 4097 d383 0bda a5bc d168 de16 688d  m.@........h..h.
00000010: b8db 0794 f9ed eca9
$ xxd msg1.bin
00000000: 20e2 8361 50a7 16a0 a5bc d168 de16 688d   ..aP......h..h.
00000010: b8db 0794 f9ed eca9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们会发现，修改message.txt内容后ECB模式加密的结果只是修改部分不同，前后加密结果不变</p>
</li>
<li><p>OpenSSL演示CBC模式加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先编辑message.txt的内容
$ vi message.txt
$ cat message.txt
  Hello vincent!!!
// 再次对message.txt进行CBC方式加密，相对ECB模式除了修改-des-cbc，还会多一个iv参数，iv是初始化向量，输出msg2.bin
$ openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -in message.txt -out msg2.bin
// 再次编辑message.txt的内容，vincent-&gt;Vincent
$ vi message.txt
$ cat message.txt
  Hello Vincent!!!
// 对修改后的文件加密，输出msg3.bin
$ openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -in message.txt -out msg3.bin
// 查看下msg2.bin和msg3.bin有什么不同
$ xxd msg2.bin
00000000: d647 a33b 0389 dea5 3c81 02c9 ec05 44dd  .G.;....&lt;.....D.
00000010: 467c a581 ab1a 415a
$ xxd msg3.bin
00000000: 9882 c1b6 3186 b465 b3be d08a 5ad5 2fd1  ....1..e....Z./.
00000010: 6032 add7 bdb2 07da                      `2......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经多次测试发现，修改message.txt内容后CBC模式加密的结果是修改部分不同以及后面的加密结果也会变化</p>
</li>
<li>终端测试指令<blockquote>
<p>  加密过程：先加密，再base64编码<br>   解密过程：先base64解码，再解密</p>
<pre class="line-numbers language-none"><code class="language-none">//  DES(ECB)加密
$ echo -n hello | openssl enc -des-ecb -K 616263 -nosalt | base64
 
// DES(CBC)加密
$ echo -n hello | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt | base64

//  AES(ECB)加密 128位
$ echo -n hello | openssl enc -aes-128-ecb -K 616263 -nosalt | base64
 
 //  AES(CBC)加密
$ echo -n hello | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 
//  DES(ECB)解密  base64 -D进行解码成二进制 -d解密
$ echo -n HQr0Oij2kbo= | base64 -D | openssl enc -des-ecb -K 616263 -nosalt -d

//  DES(CBC)解密
$ echo -n alvrvb3Gz88= | base64 -D | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -d

//  AES(ECB)解密
$ echo -n d1QG4T2tivoi0Kiu3NEmZQ== | base64 -D | openssl enc -aes-128-ecb -K 616263 -nosalt -d

//  AES(CBC)解密
$ echo -n u3W/N816uzFpcg6pZ+kbdg== | base64 -D | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="对称加密算法代码演示"><a href="#对称加密算法代码演示" class="headerlink" title="对称加密算法代码演示"></a>对称加密算法代码演示</h4><pre class="line-numbers language-none"><code class="language-none">// AES加密、ECB模式对“hello vincent!!!”进行加密
    NSString *ECBEncryptStr = [[EncryptionTools sharedEncryptionTools] encryptString:@"hello vincent!!!" keyString:@"abc" iv:nil];
    NSLog(@"%@", ECBEncryptStr);
    // 解密
    NSString *ECBDecrypt = [[EncryptionTools sharedEncryptionTools] decryptString:ECBEncryptStr keyString:@"abc" iv:nil];
    NSLog(@"%@", ECBDecrypt);
    
    // 一个数组，和前面一样有8个数据
    uint8_t iv[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    // 把数组包装才二进制NSdata 把数组的指针和长度传进去
    NSData *ivData = [NSData dataWithBytes:iv length:sizeof(iv)];
    // AES加密、CBC模式
    NSString *CBCEncryptStr = [[EncryptionTools sharedEncryptionTools] encryptString:@"hello vincent!!!" keyString:@"abc" iv:ivData];
    NSLog(@"%@", CBCEncryptStr);
    // 解密
    NSString *CBCDecrypt = [[EncryptionTools sharedEncryptionTools] decryptString:CBCEncryptStr keyString:@"abc" iv:ivData];
    NSLog(@"%@", CBCDecrypt);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>打印结果：</p>
<pre class="line-numbers language-none"><code class="language-none">LzWe4b6VMKHECZTg5GEoDvOJyUo3lvcCucS987KliFw=
hello vincent!!!
Vo04z90TAfQX07onyrvCie1SnRpsbHKMkYnaNhcEPP0=
hello vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然将加密和解密封装成了两个方法，但是苹果内部加密和解密都是用的一个函数。先看下其中封装的一个方法内部实现</p>
<pre class="line-numbers language-none"><code class="language-none">// 加密字符串并返回base64编码字符串
- (NSString *)encryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv {
    
    // 设置秘钥 将keyString转成二进制
    NSData *keyData = [keyString dataUsingEncoding:NSUTF8StringEncoding];
    uint8_t cKey[self.keySize];
    bzero(cKey, sizeof(cKey));
    [keyData getBytes:cKey length:self.keySize];
    
    // 设置iv
    uint8_t cIv[self.blockSize];
    bzero(cIv, self.blockSize);
    int option = 0;
    if (iv) {
        [iv getBytes:cIv length:self.blockSize];
        option = kCCOptionPKCS7Padding; // CBC加密
    } else {
        option = kCCOptionPKCS7Padding | kCCOptionECBMode;  // ECB加密
    }
    
    // 设置输出缓冲区 将原始数据转成二进制，并根据所使用的加密方式设置缓冲区
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    size_t bufferSize = [data length] + self.blockSize;
    void *buffer = malloc(bufferSize);
    
    // 开始加密
    size_t encryptedSize = 0;
    //加密解密都是它 -- CCCrypt
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                          self.algorithm,
                                          option,
                                          cKey,
                                          self.keySize,
                                          cIv,
                                          [data bytes],
                                          [data length],
                                          buffer,
                                          bufferSize,
                                          &amp;encryptedSize);
    
    NSData *result = nil;
    if (cryptStatus == kCCSuccess) {
        result = [NSData dataWithBytesNoCopy:buffer length:encryptedSize];
    } else {
        free(buffer);
        NSLog(@"[错误] 加密失败|状态编码: %d", cryptStatus);
    }
    
    return [result base64EncodedStringWithOptions:0];
}

// 解密字符串
- (NSString *)decryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv {
    
    // 设置秘钥
    NSData *keyData = [keyString dataUsingEncoding:NSUTF8StringEncoding];
    uint8_t cKey[self.keySize];
    bzero(cKey, sizeof(cKey));
    [keyData getBytes:cKey length:self.keySize];
    
    // 设置iv
    uint8_t cIv[self.blockSize];
    bzero(cIv, self.blockSize);
    int option = 0;
    if (iv) {
        [iv getBytes:cIv length:self.blockSize];
        option = kCCOptionPKCS7Padding;
    } else {
        option = kCCOptionPKCS7Padding | kCCOptionECBMode;
    }
    
    // 设置输出缓冲区
    NSData *data = [[NSData alloc] initWithBase64EncodedString:string options:0];
    size_t bufferSize = [data length] + self.blockSize;
    void *buffer = malloc(bufferSize);
    
    // 开始解密
    size_t decryptedSize = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,
                                          self.algorithm,
                                          option,
                                          cKey,
                                          self.keySize,
                                          cIv,
                                          [data bytes],
                                          [data length],
                                          buffer,
                                          bufferSize,
                                          &amp;decryptedSize);
    
    NSData *result = nil;
    if (cryptStatus == kCCSuccess) {
        result = [NSData dataWithBytesNoCopy:buffer length:decryptedSize];
    } else {
        free(buffer);
        NSLog(@"[错误] 解密失败|状态编码: %d", cryptStatus);
    }
    
    return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码已加入相应的注释，就不解释代码了。我们会发现苹果内部加密和解密都是用<code>CCCryptorStatus CCCrypt(
  CCOperation op, 
  CCAlgorithm alg, 
  CCOptions options, 
  const void *key,
  size_t keyLength,
  const void *iv, 
  const void *dataIn, 
  size_t dataInLength,
  void *dataOut, 
  size_t dataOutAvailable,
  size_t *dataOutMoved)</code>，这个函数是对称加密算法的核心函数。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-55512cbb2b8544e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CCCrypt函数"></p>
</blockquote>
</li>
</ul>
<p>WTF!!!11个参数，这么多，这都是干嘛的？</p>
<blockquote>
<p>参数意义<br>op：kCCEncrypt(加密)/ kCCDecrypt(解密)<br>alg：加密算法 kCCAlgorithmAES、kCCAlgorithmDES、kCCAlgorithmBlowfish等等<br>options：加密方式 kCCOptionPKCS7Padding（CBC方式）/kCCOptionECBMode（ECB方式）<br>key：加密密钥<br>keyLength：密钥长度<br>iv：初始化向量 ECB不需要指定（CBC多了这个参数就相当于加盐，加密强度更高了）<br>dataIn：加密的数据<br>dataInLength：加密数据的长度<br>dataOut：缓冲区（地址），存放密文<br>dataOutAvailable：缓冲区的大小<br>dataOutMoved：加密结果的大小</p>
</blockquote>
<p>搞清楚每个参数的意义也就明白了，苹果这样设计还是挺人性化的。对称加密和解密所用的参数密钥都是一样的，所以加密和解密都是用同一个函数。苹果的加密算法也都在CommonCrypto.h这个库里面，这个库并不在macho中，是在系统中，所以我们大多数会认为这个加密会很安全，但是事实上并不是这样。</p>
<h4 id="CCCrypt函数安全隐患"><a href="#CCCrypt函数安全隐患" class="headerlink" title="CCCrypt函数安全隐患"></a>CCCrypt函数安全隐患</h4><p>现在我们已经使用CCCrypt对数据进行加密和解密了，接下来看下我们用CCCrypt加密的数据是否真的安全。下面的内容涉及到逆向开发，可能有点跑偏，如果感兴趣的小伙伴也可以进一步研究一下。<br>我们加密数据就是为了防止中间人攻击，假设如果别人拿到我们的APP，别人肯定不会知道我们的源码，也不知道在数据核心加密的地方是不是用的CCCrypt，这时别人会进行符号断点，当然这个只要是没有去符号，或者系统的都是可以拦截到的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-b73c172a7ca12ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="符号断点"></p>
<h5 id="前方高能！！！"><a href="#前方高能！！！" class="headerlink" title="前方高能！！！"></a>前方高能！！！</h5><p>下了断点后，我们继续运行刚才的demo，程序果断进入断点，接下来要读寄存器了！！！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-76d1819cc5f6e894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WeChat112460611fd045da8d8d9a181882dc6d.png"></p>
<p>刚刚说过，CCCrypt第7个参数是我们加密的数据，所以在寄存器中X6（从X0开始）就是我们的加密数据，我们在lldb中读取X6的地址值，也就是指针，拿到X6的地址值是0x00000001c403ee00，再p (char *)0x00000001c403ee00查看X6的值，回车！！！我们刚刚加密的数据显示出来了，我们原以为很安全的手段就这样被别人拿到了！所以我们有很多核心的加密算法不能直接用。</p>
<p>那怎么防御呢？先想到去符号，前面也说了，这个库是系统的，所以没办法去符号，当然自己实现或者三方库，比如支付宝就是直接用的OpenSSL，可以去符号来避免被直接破解。最好的方式是加密之前不能直接使用关键数据，我们可以自己对关键数据处理一下比如异或，方法肯定不止一个，如果各位有什么好的解决办法欢迎交流。</p>
<p>后面可能会介绍下怎么隐藏函数调用，怎样保护核心数据，当然逆向大神还是很多的，这也仅仅是让逆向变的更难而已。该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>OpenSSL</tag>
        <tag>对称加密原理</tag>
        <tag>CCCrypt安全隐患</tag>
      </tags>
  </entry>
  <entry>
    <title>Category实现原理--源码分析</title>
    <url>/2019/07/27/categort-yuan-li/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-b9c059d5a3119823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Category实现原理"></p>
<blockquote>
<p>在Objective-C 2.0中新增的Category可以动态地为已有类添加新的对象方法、类方法、协议、和属性。注：这里的属性只会生成set/get方法的声明，并不会自动生成成员变量（分类是在运行时才去加载，对象的内存布局已经确定，无法在程序运行时将分类的成员变量添加到实例对象的结构体中），可以利用关联对象来实现。</p>
</blockquote>
<a id="more"></a>
<p>在Runtime层，Category用结构体category_t表示，<code>name</code>：类的名字，<code>cls</code>：类，<code>instanceMethods</code>：Category中所有给类添加的实例方法的列表，<code>classMethods</code>：Category中所有添加的类方法的列表，<code>protocols</code>：Category实现的所有协议的列表，<code>instanceProperties</code>：Category中添加的所有属性。我们在分类中声明的方法、属性等都会存在对应的字段中，有多少个分类就会有多少的category_t结构体。<br></p><pre class="line-numbers language-none"><code class="language-none">struct category_t {
    const char *name;    // 类的名字
    classref_t cls;    // 类
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="源码分析Category加载过程"><a href="#源码分析Category加载过程" class="headerlink" title="源码分析Category加载过程"></a>源码分析Category加载过程</h4><p>首先从镜像加载开始，<code>_objc_init</code>通过<code>map_images</code>加载并缓存所有镜像文件，比如类、方法编号等信息加载。<code>map_images</code>内部执行<code>_getObjc2CategoryList</code>来获取category<em>t数组，<code>addUnattachedCategoryForClass</code>把类和Category做一个关联映射，然后执行<code>remethodizeClass</code>。<br></em></p><pre class="line-numbers language-none"><em><code class="language-none">/ Discover categories. 
    for (EACH_HEADER) {
        category_t **catlist = 
            _getObjc2CategoryList(hi, &amp;count);
        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();

        for (i = 0; i &lt; count; i++) {
            category_t *cat = catlist[i];
            Class cls = remapClass(cat-&gt;cls);

            if (!cls) {
                // Category's target class is missing (probably weak-linked).
                // Disavow any knowledge of this category.
                catlist[i] = nil;
                if (PrintConnecting) {
                    _objc_inform("CLASS: IGNORING category \?\?\?(%s) %p with "
                                 "missing weak-linked target class", 
                                 cat-&gt;name, cat);
                }
                continue;
            }

            // Process this category. 
            // First, register the category with its target class. 
            // Then, rebuild the class's method lists (etc) if 
            // the class is realized. 
            bool classExists = NO;
            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  
                ||  cat-&gt;instanceProperties) 
            {
                addUnattachedCategoryForClass(cat, cls, hi);
                if (cls-&gt;isRealized()) {
                    remethodizeClass(cls);
                    classExists = YES;
                }
                if (PrintConnecting) {
                    _objc_inform("CLASS: found category -%s(%s) %s", 
                                 cls-&gt;nameForLogging(), cat-&gt;name, 
                                 classExists ? "on existing class" : "");
                }
            }

            if (cat-&gt;classMethods  ||  cat-&gt;protocols  
                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) 
            {
                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
                if (cls-&gt;ISA()-&gt;isRealized()) {
                    remethodizeClass(cls-&gt;ISA());
                }
                if (PrintConnecting) {
                    _objc_inform("CLASS: found category +%s(%s)", 
                                 cls-&gt;nameForLogging(), cat-&gt;name);
                }
            }
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></em></pre><em><br><code>remethodizeClass</code>通过<code>attachCategories</code>，将方法列表、属性列表和协议列表写入rw中（这里分类和类都是一样的）。<br><pre class="line-numbers language-none"><code class="language-none">// Attach method lists and properties and protocols from categories to a class.
// Assumes the categories in cats are all loaded and sorted by load order, 
// oldest categories first.
static void 
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return;
    if (PrintReplacedMethods) printReplacements(cls, cats);

    bool isMeta = cls-&gt;isMetaClass();

    // fixme rearrange to remove these intermediate allocations
    method_list_t **mlists = (method_list_t **)
        malloc(cats-&gt;count * sizeof(*mlists));
    property_list_t **proplists = (property_list_t **)
        malloc(cats-&gt;count * sizeof(*proplists));
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats-&gt;count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int propcount = 0;
    int protocount = 0;
    int i = cats-&gt;count;
    bool fromBundle = NO;
    while (i--) {
        auto&amp; entry = cats-&gt;list[i];

        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi-&gt;isBundle();
        }

        property_list_t *proplist = 
            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            proplists[propcount++] = proplist;
        }

        protocol_list_t *protolist = entry.cat-&gt;protocols;
        if (protolist) {
            protolists[protocount++] = protolist;
        }
    }

    auto rw = cls-&gt;data();

    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    rw-&gt;methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

    rw-&gt;properties.attachLists(proplists, propcount);
    free(proplists);

    rw-&gt;protocols.attachLists(protolists, protocount);
    free(protolists);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>通过<code>attachLists</code>把Category的实例方法列表、协议列表以及属性列表附加到原来类的相应列表中。以方法为例，先判断分类的方法列表hasArray()，然后利用散列表把分类的方法列表和原来类中的方法列表进行合并，如果分类和原来的类中有同名方法，就把分类的方法放在原来的类的前面，合并后copy到新的方法列表，如果原来类没有同名方法则放在方法列表后面，所以<strong>Category并没有覆盖原来类的方法</strong>。举个例子：如果分类和原来的类都有func方法，那么Category附加后，类的方法列表里会有两个func方法并且Category的func方法在前面，原来的类的func方法在后面，运行时在查找方法的时候是顺着方法列表的顺序查找的，当查找func方法时优先返回Category的imp，而不会继续查找下去，这就是<em>_不会执行原来类的同名方法而执行分类的方法的原因</em></em>。<br><pre class="line-numbers language-none"><code class="language-none">void attachLists(List* const * addedLists, uint32_t addedCount) {
        if (addedCount == 0) return;

        if (hasArray()) {
            // many lists -&gt; many lists
            uint32_t oldCount = array()-&gt;count;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            memmove(array()-&gt;lists + addedCount, array()-&gt;lists, 
                    oldCount * sizeof(array()-&gt;lists[0]));
            memcpy(array()-&gt;lists, addedLists, 
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
        else if (!list  &amp;&amp;  addedCount == 1) {
            // 0 lists -&gt; 1 list
            list = addedLists[0];
        } 
        else {
            // 1 list -&gt; many lists
            List* oldList = list;
            uint32_t oldCount = oldList ? 1 : 0;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)malloc(array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            if (oldList) array()-&gt;lists[addedCount] = oldList;
            memcpy(array()-&gt;lists, addedLists, 
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="Category的load方法调用栈"><a href="#Category的load方法调用栈" class="headerlink" title="Category的load方法调用栈"></a>Category的load方法调用栈</h4><p>进入开源objc源码<code>_objc_init</code>开始，进入<code>load_images</code>，<code>prepare_load_methods</code>做好准备工作后，<code>call_load_methods</code>开始调用。<br></p><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* load_images
* Process +load in the given images which are being mapped in by dyld.
*
* Locking: write-locks runtimeLock and loadMethodLock
**********************************************************************/
extern bool hasLoadMethods(const headerType *mhdr);
extern void prepare_load_methods(const headerType *mhdr);

void
load_images(const char *path __unused, const struct mach_header *mh)
{
    // Return without taking locks if there are no +load methods here.
    if (!hasLoadMethods((const headerType *)mh)) return;

    recursive_mutex_locker_t lock(loadMethodLock);

    // Discover load methods
    {
        mutex_locker_t lock2(runtimeLock);
        prepare_load_methods((const headerType *)mh);
    }

    // Call +load methods (without runtimeLock - re-entrant)
    call_load_methods();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="prepare-load-methods准备阶段"><a href="#prepare-load-methods准备阶段" class="headerlink" title="prepare_load_methods准备阶段"></a>prepare_load_methods准备阶段</h5><p>进入<code>prepare_load_methods</code>方法内部，<code>_getObjc2NonlazyClassList</code>取出所有加载进去的类列表，然后开始遍历执行<code>schedule_class_load</code>，<code>schedule_class_load</code>内部先递归父类<code>schedule_class_load(cls-&gt;superclass);</code>，然后<code>add_class_to_loadable_list</code>把当前类的load方法加载到list中，这里可以发现，父类永远在子类的前面，所以<strong>在加载类的load方法时先加载父类的load方法，再加载子类的load方法</strong>。类列表加载完执行<code>_getObjc2NonlazyCategoryList</code>开始加载分类列表，按照编译顺序取出分类的数据再for循环执行<code>realizeClass(cls);</code>和<code>add_category_to_loadable_list(cat);</code>加载分类中的load到list。这里可以知道，<strong>分类的load方法加载顺序就是谁先编译的，谁的load方法就被先加载。</strong>可以写个demo看下。<br></p><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* prepare_load_methods
* Schedule +load for classes in this image, any un-+load-ed 
* superclasses in other images, and any categories in this image.
**********************************************************************/
// Recursively schedule +load for cls and any un-+load-ed superclasses.
// cls must already be connected.
static void schedule_class_load(Class cls)
{
    if (!cls) return;
    assert(cls-&gt;isRealized());  // _read_images should realize

    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    // Ensure superclass-first ordering
    schedule_class_load(cls-&gt;superclass);

    add_class_to_loadable_list(cls);
    cls-&gt;setInfo(RW_LOADED); 
}


void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    runtimeLock.assertLocked();

    classref_t *classlist = 
        _getObjc2NonlazyClassList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        schedule_class_load(remapClass(classlist[i]));
    }

    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        category_t *cat = categorylist[i];
        Class cls = remapClass(cat-&gt;cls);
        if (!cls) continue;  // category for ignored weak-linked class
        realizeClass(cls);
        assert(cls-&gt;ISA()-&gt;isRealized());
        add_category_to_loadable_list(cat);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="Load方法调用阶段"><a href="#Load方法调用阶段" class="headerlink" title="Load方法调用阶段"></a>Load方法调用阶段</h5><p>进入<code>call_load_methods</code>中，<code>objc_autoreleasePoolPush</code>压栈自动释放池，之后在do-while循环中先执行<code>call_class_loads</code>加载类的load方法，再执行<code>call_category_loads</code>加载分类的load方法，最后<code>objc_autoreleasePoolPop(pool);</code>出栈。<code>call_class_loads</code>和<code>call_category_loads</code>内部都是通过初始化一个指向当前类的load方法的指针来访问load方法。<br></p><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* call_load_methods
* Call all pending class and category +load methods.
* Class +load methods are called superclass-first. 
* Category +load methods are not called until after the parent class's +load.
* 
* This method must be RE-ENTRANT, because a +load could trigger 
* more image mapping. In addition, the superclass-first ordering 
* must be preserved in the face of re-entrant calls. Therefore, 
* only the OUTERMOST call of this function will do anything, and 
* that call will handle all loadable classes, even those generated 
* while it was running.
*
* The sequence below preserves +load ordering in the face of 
* image loading during a +load, and make sure that no 
* +load method is forgotten because it was added during 
* a +load call.
* Sequence:
* 1. Repeatedly call class +loads until there aren't any more
* 2. Call category +loads ONCE.
* 3. Run more +loads if:
*    (a) there are more classes to load, OR
*    (b) there are some potential category +loads that have 
*        still never been attempted.
* Category +loads are only run once to ensure "parent class first" 
* ordering, even if a category +load triggers a new loadable class 
* and a new loadable category attached to that class. 
*
* Locking: loadMethodLock must be held by the caller 
*   All other locks must not be held.
**********************************************************************/
void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    // Re-entrant calls do nothing; the outermost call will finish the job.
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 1. Repeatedly call class +loads until there aren't any more
        while (loadable_classes_used &gt; 0) {
            call_class_loads();
        }

        // 2. Call category +loads ONCE
        more_categories = call_category_loads();

        // 3. Run more +loads if there are classes OR more untried categories
    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里我们可以知道，<strong>load方法的调用并不是消息发送objc_msgSend机制，而是直接找到类的load方法的地址，接下来调用类的load方法，然后再找到分类的load方法的地址，再去调用它。</strong><p></p>
<p>这里插一个题外话，我们平时在load方法内做交换方法的原因，一是load方法在main函数之前调用，执行比较早；二是load方法自动执行，不需要手动执行；三是唯一性，不用担心被紫烈覆盖。当然，这里也有很多坑</p>
<ul>
<li>找到真正的方法归属—NSArray，__NSSArray</li>
<li>可能被主动调用—单例原则保证只执行一次</li>
<li>子类没有实现父类的方法，导致调用交换，会找父类，但是父类没有swizzling的方法，会崩溃—先尝试给自己添加要交换的方法：personInstanceMethod(SEL)-&gt;swiMethod(IMP)，然后再将父类的IMP给swizzle personInstanceMethod(imp)-&gt;swizzledSEL</li>
<li>交换没有实现的方法—添加一个老方法编号的实现（swiMethod）,把swiMethod的具体实现赋值一个空实现，防止递归。</li>
<li>交换类方法—类方法存在元类中。</li>
</ul>
<p>该文章为记录本人的学习路程，希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Categort</tag>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO底层原理—利用Runtime自定义KVO</title>
    <url>/2019/08/16/kvo-di-ceng-yuan-li/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7fef9b095947a222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVO底层原理—利用Runtime自定义KVO"></p>
<blockquote>
<p>KVO：Key-value observer，也就是键值观察，是Objective-C对观察者模式的实现，每当被观察对象的某个属性值发生改变时，注册的观察者便能得到通知。<br>当然想了解KVO，还要先对KVC有所了解：<a href="https://www.jianshu.com/p/cce3a7b99c84">KVC底层原理</a>，本文利用Runtime实现自定义KVO，如果对Runtime不熟悉可以先了解下前几篇文章：<a href="https://www.jianshu.com/p/1ddd15e47343">Runtime底层原理</a>。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO-官网直通车</a></p>
</blockquote>
<p>先简单介绍一下KVO使用：</p>
<ul>
<li>添加观察：<code>addObserver:self forKeyPath：options:context:</code></li>
<li>观察回调：<code>observeValueForKeyPath：ofObject ：change:  context:</code></li>
<li>移除观察：<code>removeObserver: forKeyPath:</code></li>
</ul>
<blockquote>
<p>TIP：建议KVO还是手动添加移除。如果没有移除观察，会有隐藏奔溃隐患（单例），比如当观察者析构时不会自动移除，被观察对象继续发送消息, 像发送一个消息给已经释放的对象, 触发exception。</p>
</blockquote>
<h4 id="KVO原理："><a href="#KVO原理：" class="headerlink" title="KVO原理："></a>KVO原理：</h4><p>KVO默认观察setter，使用<code>isa-swizzling</code>来实现自动键值观察，也就是被观察对象的isa会被修改，指向一个动态生成的子类NSKVONotifying_xxxx（isa在移除观察者之后复原，动态生成的类不会被移除），但是通过<code>object_getClass</code>获取的还是原来的类，该子类重写了观察对象的setter方法，还有<code>class</code>、<code>dealloc</code>方法和<code>_isKVOA</code>标识，并在重写setter方法中调用<code>– willChangeValueForKey</code>和<code>– didChangeValueForKey</code>，然后向父类发送消息。如果<code>automaticallyNotifiesObserversForKey</code>返回NO的时候可以手动观察</p>
<ul>
<li>动态生成子类： NSKVONotifying_xxxx，用原来的类名做后缀</li>
<li>重写观察对象的setter，<code>class</code>、<code>dealloc</code>方法和<code>_isKVOA</code>标识</li>
<li>在重写setter方法中调用 – willChangeValueForKey和 – didChangeValueForKey</li>
<li>向父类发送消息</li>
</ul>
<h4 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h4><p>知道了KVO的原理后我们利用Runtime进行验证并自定义KVO的实现，在实现了系统KVO的功能基础上还<strong>添加了自动移除观察者机制、监听利用block回调等</strong>。</p>
<p>利用LLDB查看isa的指针，再利用Runtime查看添加观察前后的变化，可以通过下面的方法对原来的类和新增的NSKVONotifying_xxxx类进行对比<br></p><pre class="line-numbers language-none"><code class="language-none">// 遍历方法 -- 判断imp指针是否改变也就是重写
- (void)getClassAllMethod:(Class)cls {
    if (!cls) return;
    unsigned int count = 0;
    Method *methodList = class_copyMethodList(cls, &amp;count);
    for (int i = 0; i&lt;count; i++) {
        Method method = methodList[i];
        SEL sel = method_getName(method);
        IMP imp = class_getMethodImplementation(cls, sel);
        NSLog(@"%@ --- %p",NSStringFromSelector(sel), imp);
    }
    free(methodList);
}

// 遍历属性
- (void)getClassProperty:(Class)cls {
    if (!cls) return;
    //获取类中的属性列表
    unsigned int propertyCount = 0;
    objc_property_t * properties = class_copyPropertyList(cls, &amp;propertyCount);
    for (int i = 0; i&lt;propertyCount; i++) {
        NSLog(@"属性的名称为 : %s",property_getName(properties[i]));
        /**
         特性编码 具体含义
         R readonly
         C copy
         &amp; retain
         N nonatomic
         G(name) getter=(name)
         S(name) setter=(name)
         D @dynamic
         W weak
         P 用于垃圾回收机制
         */
        NSLog(@"属性的特性字符串为: %s",property_getAttributes(properties[i]));
    }
    //释放属性列表数组
    free(properties);
}

// 遍历变量
- (void)getClassAllIvar:(Class)cls {
    if (!cls) return;
    unsigned int count = 0;
    Ivar *ivarList = class_copyIvarList(cls, &amp;count);
    for (int i = 0; i&lt;count; i++) {
        Ivar ivar = ivarList[i];
        NSLog(@"%s",ivar_getName(ivar));
    }
    free(ivarList);
}

// 遍历类以及子类
- (void)getClasses:(Class)cls {
    if (!cls) return;
    // 注册类的总数
    int count = objc_getClassList(NULL, 0);
    // 创建一个数组，其中包含给定对象
    NSMutableArray *mArr = [NSMutableArray arrayWithObject:cls];
    // 获取所有已注册的类
    Class *classes = (Class *)malloc(sizeof(Class)*count);
    objc_getClassList(classes, count);
    for (int i = 0; i &lt; count; i++) {
        if (cls == class_getSuperclass(classes[i])) {
            [mArr addObject:classes[i]];
        }
    }
    free(classes);
    NSLog(@"classes --- %@", mArr);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>经过验证后开始自定义KVO实现系统功能，并额外加上自定义的一些功能。先添加用来保存KVO信息的Info类<code>VKVOInfo</code>用来保存信息，还有一个扩展<code>NSObject+VKVO</code>，主要实现系统的原有功能，再添加自定义的一些方法，比如自动移除观察者等。<p></p>
<ul>
<li>首先先动态生成子类，并添加<code>setter</code>，<code>class</code>、<code>dealloc</code>方法<pre class="line-numbers language-none"><code class="language-none">#pragma mark - 动态生成子类
- (Class)createChildClass:(NSString *)keyPath {
    NSString *oldName = NSStringFromClass([self class]);
    NSString *newName = [NSString stringWithFormat:@"%@%@", kVKVOPrefix, oldName];
    Class newClass = NSClassFromString(newName);
    // 如果内存不存在,创建生成新的类，防止重复创建生成新类
    if (newClass) return newClass;
    
    newClass = objc_allocateClassPair([self class], newName.UTF8String, 0);
    objc_registerClassPair(newClass);
    
    // 添加class方法
    SEL classSEL = NSSelectorFromString(@"class");
    Method classMethod = class_getInstanceMethod([self class], classSEL);
    const char *classType = method_getTypeEncoding(classMethod);
    class_addMethod(newClass, classSEL, (IMP)v_class, classType);
    
    // 添加setter方法
    SEL setterSEL = NSSelectorFromString(setterForGetter(keyPath));
    Method setterMethod = class_getInstanceMethod([self class], setterSEL);
    const char *setterType = method_getTypeEncoding(setterMethod);
    class_addMethod(newClass, setterSEL, (IMP)v_setter, setterType);
    
    // 添加dealloc方法
    SEL deallocSEL = NSSelectorFromString(@"dealloc");
    Method deallocMethod = class_getInstanceMethod([self class], deallocSEL);
    const char *deallocType = method_getTypeEncoding(deallocMethod);
    class_addMethod(newClass, deallocSEL, (IMP)v_dealloc, deallocType);
    
    return newClass;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>把isa指针指向动态生成的KVONotifying子类（Person类会动态生成KVONotifying_Person）<pre class="line-numbers language-none"><code class="language-none">object_setClass(self, newClass);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>保存KVO的信息<pre class="line-numbers language-none"><code class="language-none">VKVOInfo *KVOInfo = [[VKVOInfo alloc] initWithObserver:observer forKeyPath:keyPath options:options handleBlock:handleBlock];
    NSMutableArray *infoArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kVKVOAssiociateKey));
    if (!infoArr) {
        infoArr = [NSMutableArray arrayWithCapacity:1];
        objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kVKVOAssiociateKey), infoArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    [infoArr addObject:KVOInfo];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
下面是部分重要代码：在<code>setter</code>方法中，先将消息发送给原来的类，再利用block响应回调（这里也可以添加判断，利用block回调或者设置代理），也可以添加一些自定义的方法，比如去掉NSKeyValueObservingOptions参数。<pre class="line-numbers language-none"><code class="language-none">static void v_setter(id self, SEL _cmd, id newValue) {
    NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd));
    id oldValue = [self valueForKey:keyPath];
    /// Specifies the superclass of an instance.
    struct objc_super v_objc_super = {
        .receiver = self,
        .super_class = class_getSuperclass(object_getClass(self))
    };
    // 消息转发给父类
    void (*v_msgSendSuper)(void *, SEL, id) = (void *)objc_msgSendSuper;
    v_msgSendSuper(&amp;v_objc_super, _cmd, newValue);
    
    // 响应回调
    NSMutableArray *infoArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kVKVOAssiociateKey));
    for (VKVOInfo *info in infoArr) {
        if ([info.keyPath isEqualToString:keyPath]) {
            dispatch_async(dispatch_get_global_queue(0, 0), ^{
                if (info.options &amp; NSKeyValueObservingOptionNew) {
                    if (info.handleBlock) {
                        info.handleBlock(info.observer, info.keyPath, info.options, newValue, oldValue);
                    }
                }
//                SEL obserSEL = @selector(observeValueForKeyPath:ofObject:change:context:);
//                void (*v_objc_msgSend)(id, SEL, id, id, id, void *) = (void *)objc_msgSend;
//                Class supperClass = (object_getClass(self));
//                v_objc_msgSend(info.observer, obserSEL, keyPath, supperClass, @{keyPath:newValue}, NULL);
            });
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这里是<a href="https://github.com/JBWangWork/VCustomKVO">Demo地址：https://github.com/JBWangWork/VCustomKVO</a>，本Demo已更新，去掉了options和context参数（系统context可以起到快速定位观察键的作用）。本Demo只适用于学习KVO底层原理。</li>
</ul>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac电脑配置福利Alfred、Go2shell、iTerm2+Oh My Zsh</title>
    <url>/2019/03/05/mac-pei-zhi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d655dfa497bbcfd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电脑配置"></p>
<p>哎，一年换了个21-inch iMac，两个27-inch iMac，加上重做系统就更不说了，每次都要下载各种软件，各种配置。。。故记录这篇文章以免自己以后老了记不住，希望可以帮到更多人吧！</p>
<h4 id="效率神器Alfred、Go2shell"><a href="#效率神器Alfred、Go2shell" class="headerlink" title="效率神器Alfred、Go2shell"></a>效率神器Alfred、Go2shell</h4><p>首先，拿到新电脑，需要下载很多软件，第一时间把<code>Alfred</code>和<code>Go2shell</code>安装好，这里有<a href="xclient.info">各种破解软件免费下载平台</a>，里面安装教程很详细，默认<code>alt + 空格</code>打开Alfred，Go2shell就是可以快速打开当前路径的终端，用起来还是很方便的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-8400d17b9f794546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Go2shell"></p>
<h4 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h4><p>接下来根据个人喜好配置终端，之前也一直在用苹果自带的终端，但是自从接触了iTerm2后就无法自拔了。</p>
<ul>
<li><p>安装iTerm2<br>先去官网下载iTerm2，<a href="http s://www.iterm2.com/downloads.html">iTerm2下载地址：</a><a href="https://www.iterm2.com/downloads.html">https://www.iterm2.com/downloads.html</a></p>
</li>
<li><p>配置iTerm2<br>目前iTerm2 最常用的主题是<code>Solarized Dark theme</code>，下载地址：<a href="http://ethanschoonover.com/solarized">http://ethanschoonover.com/solarized</a>，下载好的压缩文件解压后，打开 iTerm2的<code>Preferences</code>配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-889dc79aadf6e185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加主题文件"></p>
<p>选择刚才解压的solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors文件，导入成功，最后选择 Solarized Dark 主题。</p>
<h4 id="配置Oh-My-Zsh"><a href="#配置Oh-My-Zsh" class="headerlink" title="配置Oh My Zsh"></a>配置Oh My Zsh</h4><p>一款用于管理zsh配置，可以提供超级多而强大的插件和漂亮的主题。可以去GitHub下载<a href="https://github.com/robbyrussell/oh-my-zsh">Oh My Zsh</a></p>
<ul>
<li>安装Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 使用 crul 安装：
$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
或者<pre class="line-numbers language-none"><code class="language-none">// 使用wget：
$ sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
安装成功后</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3fe231151c615c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Oh My Zsh"></p>
<ul>
<li>卸载Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 卸载oh-my-zsh命令：
$ uninstall_oh_my_zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>设置当前用户的默认Shell为Zsh<pre class="line-numbers language-none"><code class="language-none">$ chsh -s /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
接下来，将主题配置修改为ZSH_THEME=”agnoster”<pre class="line-numbers language-none"><code class="language-none">$ vim ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
到目前为止，不出意外的话，iTerm2外观应该是这样的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92007dc6e28a9a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2外观"></p>
<p>界面显示乱码原因是没有安装<code>Meslo</code>字体，字体下载地址：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a>，下载后安装接下来还是打开 iTerm2的Preferences 配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-ffed44579f071798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Meslo字体"><br>成功后的截图<br><img src="https://upload-images.jianshu.io/upload_images/5741330-e95f6971f45f9469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2+Oh My Zsh"></p>
<p>也可以修改合适的字体大小。</p>
<h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>这个功能是非常实用的，可以方便我们快速的敲命令。</p>
<p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：<br></p><pre class="line-numbers language-none"><code class="language-none">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后编辑<code>vim ~/.zshrc</code>文件，找到<code>plugins</code>配置，增加<code>zsh-autosuggestions</code>插件。如果配置不生效增加zsh-syntax-highlighting插件试试。<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-275b4a55100f9dac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动填充"></p>
<h4 id="隐藏用户名和主机名"><a href="#隐藏用户名和主机名" class="headerlink" title="隐藏用户名和主机名"></a>隐藏用户名和主机名</h4><p>进入Oh My Zsh主题文件列表<br></p><pre class="line-numbers language-none"><code class="language-none">$ cd ~/.oh-my-zsh/themes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>进入已选的主题，并找到<code>prompt_context</code>，然后进行修改<br><pre class="line-numbers language-none"><code class="language-none">### Prompt components
# Each component will draw itself, and hide itself if no information needs to be shown

# Context: user@hostname (who am I and where am I)
prompt_context() {
  if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then
    # prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"
    prompt_segment black default "Vincent" // Vincent是写死的名字 可以根据个人爱好随意设置
  fi
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://upload-images.jianshu.io/upload_images/5741330-3c6300f5a99d9272.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隐藏用户名和主机名"><p></p>
<p>还有一些插件和功能网上很多，暂不做更多介绍。</p>
<p>该文章为记录本人的电脑配置，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Mac配置</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程原理--NSOperation、NSOperationQueue</title>
    <url>/2020/01/06/nsoperation-yuan-li/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d8c4046683af6dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程原理--NSOperation、NSOperationQueue"></p>
<blockquote>
<p>NSOperation类是iOS2.0推出的，通过NSThread实现的,但是效率一般。从iOS4推出GCD时又重写了NSOperation和NSOperationQueue，NSOperation和NSOperationQueue分别对应GCD的任务和队列（<a href="https://www.jianshu.com/p/acc6e7bd6f10">了解GCD直通车：https://www.jianshu.com/p/acc6e7bd6f10</a>），所以NSOPeration和NSOperationQueue是基于GCD更高一层的封装，而且完全地面向对象。但是比GCD更简单易用、代码可读性也更高。NSOperation和NSOperationQueue对比GCD会带来一点额外的系统开销，但是可以在多个操作Operation中添加附属。</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>可添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ul>
<h4 id="NSOperation、NSOperationQueue"><a href="#NSOperation、NSOperationQueue" class="headerlink" title="NSOperation、NSOperationQueue"></a>NSOperation、NSOperationQueue</h4><p>NSOperation是一个和任务相关的抽象类，不具备封装操作的能力，必须使用其子类：NSInvocationOperation或者NSBlockOperation，当然也可以自定义子类,实现内部相应的⽅法，NSOperation实例在多线程上执行是线程安全的不需要添加额外的锁，不  必管理线程生命周期和同步等问题。NSInvocationOperation 和NSBlockOperation子类不同的是，因为NSInvocationOperation没有额外添加任务的方法，所以使用NSInvocationOperation创建的对象只会有一个任务，其次使用NSBlockOperation来执行任务切任务大于1的时候，系统可能会开辟新线程来异步执行任务。</p>
<p>NSOperationQueue有主队列和自定义队列（串行和并发），将NSOperation对象添加NSOperationQueue中，该NSOperationQueue对象从线程中拿取操作、以及分配到对应线程的工作都是由<strong>系统处理</strong>的。一般操作对象添加到NSOperationQueue之后，如果不存在依赖或者整个队列被暂停情况下通常短时间就开始运行。NSOperationQueue可以通过对象属性<code>suspended</code>来决定是否让队列暂时停止对任务的调度，或者<code>cancel、cancelAllOperations</code>方法来取消操作对象，不过使用这两个方法后操作对象无法恢复，操作时只会停止调度队列中操作对象（<strong>注意：正在执行的操作依然会执行，无法取消。</strong> ）， 且取消不可恢复。</p>
<p>首先创建一个NSOperation的子类（以NSInvocationOperation为例），再创建队列NSOperationQueue，最后将操作加入队列。这样我们就完成了多线程的操作。可以直接执行<code>start</code>方法，但不会开辟新线程去执行操作，而是在当前线程同步执行任务。这里注意，如果将操作添加到队列的同时再次执行<code>start</code>，这时会抛出异常，因为线程在创建后，开始进入Runnable就绪的状态，如果此时再次执行<code>start</code>会重复初始化操作。</p>
<pre class="line-numbers language-none"><code class="language-none">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(handleInvocation:) object:@"123"];

// 将op加入到队列中
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:op];
[[NSOperationQueue mainQueue] addOperation:op];

// 或者直接start
[op start];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为基于GCD更高一层的封装，NSOperation同样也具备线程之间的通讯以及控制并发数，举个简单的例子：<br></p><pre class="line-numbers language-none"><code class="language-none">NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 2;
for (int i = 0; i&lt;10; i++) {
    [queue addOperationWithBlock:^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"%d-%@",i,[NSThread currentThread]);
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            NSLog(@"%d-%@--%@",i,[NSOperationQueue currentQueue],[NSThread currentThread]);
        }];
    }];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>由于设置了最大并发数<code>maxConcurrentOperationCount</code>为2，所以每2秒输出四个任务。<p></p>
<pre class="line-numbers language-none"><code class="language-none">0-&lt;NSThread: 0x600003f08180&gt;{number = 4, name = (null)}
1-&lt;NSThread: 0x600003f17bc0&gt;{number = 5, name = (null)}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}
2-&lt;NSThread: 0x600003f31e00&gt;{number = 7, name = (null)}
3-&lt;NSThread: 0x600003f08180&gt;{number = 4, name = (null)}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}
... // 省略部分相似打印信息
9-&lt;NSThread: 0x600003f08180&gt;{number = 4, name = (null)}
8-&lt;NSThread: 0x600003f17bc0&gt;{number = 5, name = (null)}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}
&lt;NSOperationQueue: 0x7fce0de147f0&gt;{name = 'NSOperationQueue Main Queue'} --&lt;NSThread: 0x600003f5acc0&gt;{number = 1, name = main}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然我们也可以自定义子类，可能会添加到串行和并发队列的不同情况，需要重写不同的方法。TIP：并发操作时，需要自己创建自动释放池，因为异步操作无法访问主线程的自动释放池。经常通过cancelled属性检查方法是否取消，并且对取消做出响应。</p>
<h4 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h4><p>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系，可以使用依赖关系来控制操作间的启动顺序。当一个操作对象添加了依赖，被依赖的操作对象就会先执行，当被依赖的操作对象执行完才会当前的操作对象，通过操作依赖可以很方便的按照特定顺序控制操作之间的执行先后顺序。操作对象可以通过<code>addDependency</code>添加和<code>removeDependency</code>移除依赖。在添加线程对象NSOperationQueue之前进行依赖设置，操作对象会管理自己的依赖，因此在不相同队列中的操作对象可以建立依赖关系。</p>
<p>举例：现在有任务1、2、3，当任务1执行完毕后再执行任务2，任务2执行完毕后再执行任务3。</p>
<pre class="line-numbers language-none"><code class="language-none">NSBlockOperation *bo1 = [NSBlockOperation blockOperationWithBlock:^{
    [NSThread sleepForTimeInterval:0.5];
    NSLog(@"任务----1");
}];

NSBlockOperation *bo2 = [NSBlockOperation blockOperationWithBlock:^{
    [NSThread sleepForTimeInterval:0.5];
    NSLog(@"任务----2");
}];

NSBlockOperation *bo3 = [NSBlockOperation blockOperationWithBlock:^{
    [NSThread sleepForTimeInterval:0.5];
    NSLog(@"任务----3"); 
}];

// 建立依赖
[bo2 addDependency:bo1];
[bo3 addDependency:bo2];

[self.queue addOperations:@[bo1,bo2,bo3] waitUntilFinished:YES];

NSLog(@"执行结束");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里<code>waitUntilFinished</code>如果设置为YES，则会堵塞当前线程，直到该操作结束。<br>最终打印效果总是：<strong>任务1-&gt;任务2-&gt;任务3</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">任务----1
任务----2
任务----3
执行结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="优先级、服务质量"><a href="#优先级、服务质量" class="headerlink" title="优先级、服务质量"></a>优先级、服务质量</h4><blockquote>
<p>NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过<code>setQueuePriority</code>方法来改变当前操作在同一队列中的执行优先级。在iOS 8.0后，推出了服务质量，通过设置服务质量让系统优先处理某一个操作。</p>
</blockquote>
<p>NSOperation优先级的枚举和Quality of Service枚举：<br></p><pre class="line-numbers language-none"><code class="language-none">// NSOperation.h
typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
	NSOperationQueuePriorityVeryLow = -8L,
	NSOperationQueuePriorityLow = -4L,
	NSOperationQueuePriorityNormal = 0,
	NSOperationQueuePriorityHigh = 4,
	NSOperationQueuePriorityVeryHigh = 8
};

// ----------------------------
// NSObjCRuntime.h
typedef NS_ENUM(NSInteger, NSQualityOfService) {
//与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成.
    NSQualityOfServiceUserInteractive = 0x21,
// 由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成
    NSQualityOfServiceUserInitiated = 0x19,
// 一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间
    NSQualityOfServiceUtility = 0x11,
// 一些可能需要花点时间的任务，这些任务不需要马上返回结果
    NSQualityOfServiceBackground = 0x09,
// 一些可能需要花点时间的任务，这些任务不需要马上返回结果
    NSQualityOfServiceDefault = -1
} API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>Utility 及以下的优先级会受到 iOS9 中低电量模式的控制，另外在没有用户操作时，90% 任务的优先级都应该在 Utility 之下。<p></p>
<p>一般对于添加到队列中的任务，当这个任务的所有依赖都已经完成时，任务通常会进入准备就绪状态来等待执行，这时该任务的开始执行顺序由任务的优先级决定。如果一个队列中既包含高优先级就绪状态的任务，又包含低优先级就绪状态的任务，高优先级就绪状态的任务会优先被执行；</p>
<p>服务质量则根据CPU，网络和磁盘的分配来创建一个操作的系统优先级。一个高质量的服务意味着可以提供更多的资源来更快的完成操作，涉及到CPU调度的优先级、IO优先级、任务运行所在的线程以及运行的顺序等等。正确的指定线程或任务优先级可以让系统更加智能的管理队列的资源分配，以便于提高执行效率和控制电量等。</p>
<h4 id="自定义NSOperation子类"><a href="#自定义NSOperation子类" class="headerlink" title="自定义NSOperation子类"></a>自定义NSOperation子类</h4><p>当NSInvocationOperation或者NSBlockOperation无法满足我们日常需求，我们也可以定义串行和并发的2种类型的NSOperation子类，注意需要创建自动释放池，异步操作无法访问主线程的自动释放池。在自定义串行NSOperation子类时要重写<code>main</code>方法并且最好添加一个init方法用于初始化数据，在自定义并行NSOperation子类是需要重写<code>start、isFinished、isAsynchronous</code>和<code>isExecuting</code>方法。经常通过cancelled属性检查方法是否取消，并且对取消的做出响应，定期调用对象的isCancelled方法，如果返回“YES”，则立即返回，不再执行任务。</p>
<p>如果想进一步了解自定义NSOperation子类的具体实现，接下来将利用自定义NSOperation子类，同时借鉴了<code>AFNetworking、SDWebImage、YYKit</code>的部分思想来实现具有缓存支持的异步图像下载器。</p>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>NSOperation</tag>
      </tags>
  </entry>
  <entry>
    <title>React简述</title>
    <url>/2019/12/05/react-jian-shu/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d92ca6829b68471e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="React简述"></p>
<blockquote>
<p>React是Facebook在2013年推出的前段框架。React不是一个MVC框架，React是一个构造可组合式用户界面的库。它鼓励创建可重用的UI组件会随着时间而改变的数据。React采用不同的方法，当组件第一次初始化时，render方法调用，为试图生成一个轻量级的表现。通过这个表现，产生一个标签字符串，然后插入文档中。当数据变化时，render方法再次被调用。为了尽可能有效的完成更新，我们比较之前调用的render返回的值与新的值，然后产生一个最小的变更去应用DOM中。</p>
</blockquote>
<p><strong>问题出现的根源</strong></p>
<ul>
<li>传统 UI 操作关注太多细节</li>
<li>应用程序状态分散在各处难以追踪和维护</li>
</ul>
<p>Facebook认为MVC无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得MVC很快变得复杂，每当需要添加一项新功能或者特性时，系统的复杂就成级数的增长，致使代码变得脆弱而不可预测，结果导致他们的MVC正在土崩瓦解。认为MVC不适合大规模的应用。当系统中有很多模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试，特别是模型和视图可能存在双向数据流动。</p>
<p>React：始终整体”刷新”页面，无需关心细节。以组件的方式去描述UI，4个必须API，单向数据流，完善的错误提示。</p>
<h4 id="数据模型如何解决"><a href="#数据模型如何解决" class="headerlink" title="数据模型如何解决"></a>数据模型如何解决</h4><p>传统MVC难以扩展和维护，Model和View之间的关系错综复杂而且双向绑定，如果业务复杂出现问题后很难去追踪是Model的问题还是View的问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-b68448c8281d3033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统MVC难以扩展和维护"></p>
<p>针对这个问题，React提出Flux架构，该设计模式的核心思想就是单向数据流。首先用户操作产生Action，Action经过Dispatcher再发送到Store，Store根据Action来进行处理，View是绑定到Store上的，此时View随Store更新而更新。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-84f6f39938abd0a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flux架构：单向数据流"></p>
<p>Flux架构的衍生项目：Redux、Mobx。</p>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>React组件由props和state最终得到一个View。状态有外部传过来状态和内部维护状态，两种状态最终决定了View。React一般不提供方法，而是某种状态机，可以理解React组件为一个纯函数，React是单向数据绑定。<br>以组件的方式考虑UI的构建，将UI组织成组件树的形式。</p>
<p>下面的评论框由CommentBox、CommentList和CommentForm三个组件共同完成，代码部分除了div和h1标准的html的tag外还有CommentList和CommentForm两个自定义组件共同完成。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d4117fdca7057b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UI的构建"></p>
<p>受控组件的状态来自外部，要传递value和onChange，非受控组件的状态由内部维护，如果外部需要可以通过其他方式获取，也就不需要传递value和onChange。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-5044d8d3c4000229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="受控组件和非受控组件"></p>
<p>在创建组件时要遵守单一职责原则。每个组件只做一件事，组件是构建UI的最小元素，每个组件都应该尽量的小，这样才能够让复杂度分散出去，在以后的开发中如果组件变得复杂，应该拆分成小组件。<br>数据状态管理要遵守DRY原则。能计算得到的状态就不要单独存储；组件尽量无状态，所需数据通过props获取以提高组件的性能。</p>
<h4 id="JSX的本质"><a href="#JSX的本质" class="headerlink" title="JSX的本质"></a>JSX的本质</h4><p>JSX：在JavaScript代码中直接写HTML标记。JSX并不是模板语言，只是一种语法糖。TIP：自定义组件以大写字母开头，React认为小写的tag是原生DOM节点，如div；JSX标记可以直接使用属性语法，例如<code>&lt;menu.Item /&gt;</code>。</p>
<p>比如我们定义了一个变量name，又定义了一个HTML的element：<br></p><pre class="line-numbers language-none"><code class="language-none">const name = 'Vincent Wang';
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>实际上是动态创建了一个组件，而且是用JavaScript语法。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-dc3e9bcfb0456cb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><p></p>
<p>JSX本身也是表达式，element返回一个HTML的节点：<br></p><pre class="line-numbers language-none"><code class="language-none">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>在属性中使用表达式，如果给一个组件传递属性的值，这个属性的值可以是JavaScript的表达式：<br><pre class="line-numbers language-none"><code class="language-none">&lt;MyComment foo={1 + 2} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>延展属性，如果给一个组件传递一组值，此时我们不需要一个一个填写，只需要<code>...</code>语法，<br><pre class="line-numbers language-none"><code class="language-none">const props = { name: "Red", value: "red" };
const greeting = &lt;Greeting {...props} /&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>表达式作为子元素，子元素是React的一个特殊属性。只需要用大括号将JavaScript语法包起来。<br><pre class="line-numbers language-none"><code class="language-none">const element = &lt;li&gt;{props.message}&lt;/li&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong> JSX的优点</strong><p></p>
<ul>
<li>有声明式创建界面的直观</li>
<li>代码动态创建界面的灵活</li>
<li>不需要学习新的模板语言</li>
</ul>
<h4 id="React生命周期及使用场景"><a href="#React生命周期及使用场景" class="headerlink" title="React生命周期及使用场景"></a>React生命周期及使用场景</h4><p>React主要分三个阶段：Render阶段（计算当前的状态）、Pre-commit阶段（读取DOM内容）和Commit阶段（React把当前状态映射到DOM节点时需要实际更新DOM节点）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6a348940407ff2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期"></p>
<p>图片来源：<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>
<p>生命周期可以分为三个类型：挂载时、更新时和卸载时。</p>
<h5 id="创建时"><a href="#创建时" class="headerlink" title="创建时"></a>创建时</h5><ol>
<li>constructor<br>一个组件的构造函数的创建，也是唯一可以直接修改state的地方。</li>
<li>getDerivedStateFromProps<br>从外部的属性初始化内部的状态，在初始安装和后续更新上，都在调用render方法之前立即调用getDerivedStateFromProps。它返回一个对象以更新状态，或者返回null则不更新任何内容。这个方法一般不建议使用，如果state需要从props中获取的时候，可以通过props动态计算等到，不需要单独存储这个状态，否则要维护两者状态一致性，这样会增加复杂度，每次render都会调用。一般表单控件获取默认值。<br>3.render<br>描述UI DOM结构，类组件中唯一需要的方法。</li>
<li>componentDidMount<br>挂载组件（插入树中）后立即调用<code>componentDidMount（）</code>。我们可以在此处发起请求或者定义外部的资源等。只执行一次，可以获取外部资源。</li>
</ol>
<h5 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h5><p>当组件有新的属性或者修改了state内部状态，当然如果强制刷新<code>forceUpdate</code>可以会触发。</p>
<ol>
<li>getDerivedStateFromProps<br>同样是从外部属性得到内部的状态</li>
<li>shouldComponentUpdate<br>使用shouldComponentUpdate（）让React知道组件的输出是否不受当前状态或道具更改的影响。在这里可以做一些组件的性能优化，比如props即使发生变化且UI不需要更新，这时可以通知React组件直接返回false则不需要Update。一般可以由PureComponent自动实现，来判断当前state和props是否发生变化。</li>
<li>render<br>计算虚拟的DOM，虚拟DOM维持内部的UI状态，计算diff等。</li>
<li>getSnapshotBeforeUpdate<br>它使组件可以在DOM可能发生更改之前从DOM捕获一些信息（例如，滚动位置），返回的任何值都将作为参数传递给componentDidUpdate（），一般在获取render之前的DOM状态时使用。</li>
<li>componentDidUpdate<br>发生更新后，立即调用componentDidUpdate（），初始渲染不调用此方法。React更新的事情做完后可以根据实际业务在此处做一些处理，然后更新到UI上。页面根据props变化来重新获取数据。</li>
</ol>
<h5 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h5><ul>
<li>componentWillUnmount<br>当组件移除时，需要销毁组件来释放资源。</li>
</ul>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密算法--RSA加密原理及运用</title>
    <url>/2018/12/02/rsa-jia-mi-yuan-li-ji-yun-yong/</url>
    <content><![CDATA[<p><img src="https://s.im5i.com/2021/02/02/kIFKH.png" alt="RSA加密原理及运用"></p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81">密码</a>学是在编码与破译的斗争实践中逐步发展起来的,并随着先进科学技术的应用，已成为一门综合性的尖端技术科学。</p>
</blockquote>
<h4 id="密码学发展史"><a href="#密码学发展史" class="headerlink" title="密码学发展史"></a>密码学发展史</h4><p>在说RSA加密算法之前， 先说下密码学的发展史。其实密码学的诞生，就是为了运用在战场，在公元前，战争之中出现了秘密书信。在中国历史上最早的加密算法的记载出自于周朝兵书《六韬.龙韬》中的《阴符》和《阴书》。在遥远的西方，在希罗多德（Herodotus）的《历史》中记载了公元前五世纪，希腊城邦和波斯帝国的战争中，广泛使用了移位法进行加密处理战争通讯信息。</p>
<p>相传凯撒大帝为了防止敌人窃取信息，就使用加密的方式传递信息。那么当时的加密方式非常的简单，就是对二十几个罗马字母建立一张对照表，将明文对应成为密文。那么这种方式其实持续了很久。甚至在二战时期，日本的电报加密就是采用的这种原始加密方式。<br><img src="https://s.im5i.com/2021/02/02/kIVPa.webp" alt="凯撒密码对照表"></p>
<p>早期的密码学一直没有什么改进，几乎都是根据经验慢慢发展的。直到20世纪中叶，由香农发表的《秘密体制的通信理论》一文，标志着加密算法的重心转移往应用数学上的转移。于是，逐渐衍生出了当今重要的三类加密算法：非对称加密、对称加密以及哈希算法（HASH严格说不是加密算法，但由于其不可逆性，已成为加密算法中的一个重要构成部分）。</p>
<p>1976年以前，所有的加密方法都是同一种模式：加密和解密使用同样规则（简称”密钥”），这被称为<a href="http://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%AD%89%E5%8A%A0%E5%AF%86">“对称加密算法”</a>，使用相同的密钥，两次连续的对等加密运算后会恢复原始文字，也有很大的安全隐患。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">“Diffie-Hellman密钥交换算法”</a>。也正是因为这个算法的产生，人类终于可以实现非对称加密了：A给B发送信息</p>
<blockquote>
<ol>
<li>B要先生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</li>
<li>A获取B的公钥，然后用它对信息加密。</li>
<li>B得到加密后的信息，用私钥解密。<br>理论上如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</li>
</ol>
</blockquote>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">RSA算法</a>。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是232个十进制位，也就是768个二进制位，因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全，当然量子计算机除外。</p>
<h4 id="RSA算法的原理"><a href="#RSA算法的原理" class="headerlink" title="RSA算法的原理"></a>RSA算法的原理</h4><p>下面进入正题，解释RSA算法的原理，其实RSA算法并不难，只需要一点<a href="http://jeremykun.com/2011/07/30/number-theory-a-primer/">数论知识</a>就可以理解。</p>
<blockquote>
<ol>
<li><strong>素数</strong>：又称<strong>质数</strong>，指在一个大于1的<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F19911.htm">自然数</a>中，除了1和此<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F71484.htm">整数</a>自身外，不能被其他自然数<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F135932.htm">整除</a>的数。</li>
<li><strong>互质</strong>，又称<strong>互素</strong>。若N个整数的<a href="https://link.jianshu.com/?t=http%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%259C%2580%25E5%25A4%25A7%25E5%2585%25AC%25E5%259B%25A0%25E6%2595%25B8">最大公因子</a>是1，则称这N个整数互质。</li>
<li><strong>模运算</strong>即<strong>求余运算</strong>。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个<strong>正</strong>整数，若得相同<a href="https://link.jianshu.com/?t=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25BD%2599%25E6%2595%25B0">余数</a>，则二整数<strong>同余</strong>。<h5 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h5>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）计算这个值的方法就叫做<a href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>，以φ(n)表示。</li>
</ol>
<ul>
<li>计算8的欧拉函数，和8互质的 <strong>1</strong>、2、<strong>3</strong>、4、<strong>5</strong>、6、<strong>7</strong>、8<br>φ(8) = 4<br>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则φ(n) = φ(p^k) = p^k - p^(k-1)。也就是φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4</li>
<li>计算7的欧拉函数，和7互质的 <strong>1</strong>、<strong>2</strong>、<strong>3</strong>、<strong>4</strong>、<strong>5</strong>、<strong>6</strong>、7<br>φ(7) = 6<br>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</li>
<li>计算56的欧拉函数<br>φ(56) = φ(8) <em> φ(7) = 4 </em> 6 = 24<br>如果n可以分解成两个互质的整数之积，即 n = p <em> k ，则φ(n) = φ(p </em> k) = φ(p1)*φ(p2)</li>
</ul>
<p><strong>欧拉定理</strong>：如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。<br><img src="https://s.im5i.com/2021/02/02/kIyhQ.webp" alt="欧拉定理"></p>
<p><strong>费马小定理</strong>：欧拉定理的特殊情况，如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。<br><img src="https://s.im5i.com/2021/02/02/kI6Jq.webp" alt="费马小定理"></p>
<h5 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h5><p>还剩下最后一个概念，<strong>模反元素</strong>：如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除，或者说ed被x除的余数是1。<br>那么d就是e相对于x的模反元素。<br><img src="https://s.im5i.com/2021/02/02/kIR2h.webp" alt="d是模反元素"></p>
</blockquote>
<h5 id="等式转换"><a href="#等式转换" class="headerlink" title="等式转换"></a>等式转换</h5><ol>
<li><p>根据欧拉定理<br><img src="https://s.im5i.com/2021/02/02/kIwtX.webp" alt="等式转换1"></p>
</li>
<li><p>由于1^k ≡ 1，等号左右两边都来个k次方<br><img src="https://s.im5i.com/2021/02/02/kIoYf.webp" alt="等式转换2"></p>
</li>
<li><p>由于1* m ≡ m，等号左右两边都乘上m<br><img src="https://s.im5i.com/2021/02/02/kItVM.webp" alt="等式转换3"></p>
</li>
</ol>
<p>根据模反元素，因为e*d 一定是x的倍数加1。所以如下：<br><img src="https://s.im5i.com/2021/02/02/kIvO3.webp" alt="等式转换"></p>
<p>通过多次的等式转换。终于可以将这两个等式进行合并了！如下：<br><img src="https://s.im5i.com/2021/02/02/kIBD7.webp" alt="最终等式转换"></p>
<p>这个等式成立有一个前提！就是关于模反元素的，就是当整数e和φ(n)互质！一定有一个整数d是e相对于φ(n)的模反元素。<br>我们可以测试一下。<br>m取值为4<br>n取值为15<br>φ(n)取值为8<br>e 如果取值为3<br>d 可以为 11、19…(模反元素很明显不止一个，其实就是解二元一次方程)<br>如果你测试了，那么你可以改变m的值试一下，其实这个等式不需要m和n 互质。只要m小于n 等式依然成立。<br>这里需要注意的是，我们可以看做 m 通过一系列运算得到结果仍然是 m。这一系列运算中，分别出现了多个参数n、φ(n)、e还有d。</p>
<p>m 的 e乘上d 次方为<strong>加密运算</strong>，得到结果 c<br>c 模以 n  为<strong>解密运算</strong>，得到结果 m<br>这似乎可以用于加密和解密。但这样，加密的结果会非常大。明文数据将非常小（虽然RSA用于加密的数据也很小，但是没这么大悬殊），真正的RSA要更加强大，那么RSA是怎么演变来的呢？？<br>早期很多数学家也停留在了这一步！直到1967年迪菲赫尔曼密钥交换打破了僵局！</p>
<h5 id="迪菲赫尔曼密钥交换"><a href="#迪菲赫尔曼密钥交换" class="headerlink" title="迪菲赫尔曼密钥交换"></a>迪菲赫尔曼密钥交换</h5><p>这个密钥交换当时轰动了整个数学界！而且对人类密码学的发展非常重要，因为这个伟大的算法能够拆分刚才的等式。当非对称加密算法没有出现以前，人类都是用的对称加密。所以密钥的传递，就必须要非常小心。<br>迪菲赫尔曼密钥交换 就是解决了密钥传递的保密性，我们来看一下<br><img src="https://s.im5i.com/2021/02/02/kIukp.webp" alt="迪菲赫尔曼密钥交换"><br>假设一个传递密钥的场景。算法就是用3 的次方去模以17。 三个角色</p>
<ul>
<li>服务器 随机数 15<br>这个15只有服务器才知道。通过算法得到结果 6 因为 3的15次方 mod 17 = 6 。然后将结果 6 公开发送出去，拿到客户端的 12 ，然后用12^15 mod 17 得到结果10(10就是交换得到的密钥)</li>
<li>客户端 随机数13<br>客户端用3 的 13次方 mod 17 = 12 然后将得到的结果12公布出去。<br>拿到服务器的 6 ，然后用6^13 mod 17 得到结果10(10就是交换得到的密钥)</li>
<li>第三者<br>第三者只能拿到6 和 12 ，因为没有私密数据13、15，所以它没法得到结果10。</li>
</ul>
<p>为什么 6的13次方会和12的15次方得到一样的结果呢?因为这就是规律，我们可以用小一点的数字测试一下3^3 mod 17 = 10和10 ^ 2 mod 17 ； 3 ^ 2 mod 17 = 9和9^3 mod 17结果都是15。迪菲赫尔曼密钥交换最核心的地方就在于这个规律<br><img src="https://s.im5i.com/2021/02/02/kI4AG.webp" alt="迪菲赫尔曼密钥交换转换"></p>
<h5 id="RSA的诞生"><a href="#RSA的诞生" class="headerlink" title="RSA的诞生"></a>RSA的诞生</h5><p><img src="https://s.im5i.com/2021/02/02/kIIEY.webp" alt="RSA原理"></p>
<blockquote>
<p>现在我们知道了m^e % n = c是加密，c^d % n = m是解密，m就是原始数据，c是密文，公钥是n和e，私钥是n和d，所以只有n和e是公开的。加密时我们也要知道φ(n)的值，最简单的方式是用两个质数之积得到，别人想破解RSA也要知道φ(n)的值，只能对n进行因数分解，那么我们不想m被破解，n的值就要非常大，就是我们之前说的，长度一般为1024个二进制位，这样就很安全了。但是据说量子计算机(用于科研，尚未普及)可以破解，理论上量子计算机的运行速度无穷快，大家可以了解一下。</p>
</blockquote>
<p>以上就是RSA的数学原理</p>
<h5 id="检验RSA加密算法"><a href="#检验RSA加密算法" class="headerlink" title="检验RSA加密算法"></a>检验RSA加密算法</h5><p>我们用终端命令演示下这个加密、解密过程。<br>假设m = 12(随便取值，只要比n小就OK)，n = 15(还是随机取一个值)，φ(n) = 8，e = 3(只要和φ(n)互质就可以)，d = 19（3d - 1 = 8，d也可以为3,11等等，也就是d = (8k + 1)/3 ）<br>终端分别以m=12，7输入结果<br><img src="https://s.im5i.com/2021/02/02/kIX2w.webp" alt="终端演示"></p>
<h5 id="OpenSSL进行RSA的命令运行"><a href="#OpenSSL进行RSA的命令运行" class="headerlink" title="OpenSSL进行RSA的命令运行"></a>OpenSSL进行RSA的命令运行</h5><p>Mac可以直接使用OpenSSL，首先进入相应文件夹</p>
<ul>
<li>生成公私钥<pre class="line-numbers language-none"><code class="language-none">// 生成RSA私钥，文件名为private.pem，长度为1024bit
openssl genrsa -out private.pem 1024<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 从私钥中提取公钥
openssl rsa -in private.pem -pubout -out publick.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<img src="https://s.im5i.com/2021/02/02/kImvF.webp" alt="生成私钥"></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// 查看刚刚生成好的私钥
cat private.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 查看刚刚生成好的公钥
cat publick.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://s.im5i.com/2021/02/02/kIPgd.webp" alt="查看公私钥"></p>
<p>我们可以看到base64编码，明显私钥二进制很大，公钥就小了很多。<br>这时候我们的文件夹内已经多了刚刚生成好的公私钥文件了</p>
<p><img src="https://s.im5i.com/2021/02/02/kXDVK.webp" alt="公私钥文件"></p>
<pre class="line-numbers language-none"><code class="language-none">// 将私钥转换为明文
openssl rsa -in private.pem -text -out private.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://s.im5i.com/2021/02/02/kXUQC.webp" alt="P1、P2信息"></p>
<p>里面就是P1、P2还有KEY等信息。</p>
<ul>
<li>对文件进行加密、解密<pre class="line-numbers language-none"><code class="language-none">// 编辑文件message内容为hello Vincent!!!
// 刚刚的public.pem写成了publick.pem(哎。。。)
 $ vi message.txt
 $ cat message.txt
 hello Vincent!!!
// 通过公钥加密数据时，使用encrypt对文件进行加密
 $ openssl rsautl -encrypt -in message.txt -inkey publick.pem -pubin -out enc.txt
// 此时查看该文件内容为乱码
 $ cat enc.txt
j��E]֌a��d�kUE�&amp;&lt;
                 ��I*��V/��pL[���ˋ�O�+�-�M��K�ܱ�&amp;⪅ծO��2���o34�:�$���6��C�L��,b�'M�S�k�0���A��3%�[I���1�����ps"%
// 通过私钥解密数据
 $ openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt
// 已成功解密，正确显示文件内容
 $ cat dec.txt
  hello Vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 通过私钥加密数据时，要使用sign对文件进行重签名
$ openssl rsautl -sign -in message.txt -inkey private.pem -out enc.bin
// 此时查看该文件内容同样为乱码
$ cat enc.bin
{���Ew�3�1E��,8-OA2�Is�:���:�ԅ@MU����؜
                                      �i1B���#��6���ׂm�D(�t#/���	�ہ�������ݬ&gt;(�&gt;�^@�C��3�ӸMQт�O%
// 通过公钥解密数据
$ openssl rsautl -verify -in enc.bin -inkey publick.pem -pubin -out dec.bin
// 已成功解密，正确显示文件内容
$ cat dec.bin
 hello Vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="RSA用途及特点"><a href="#RSA用途及特点" class="headerlink" title="RSA用途及特点"></a>RSA用途及特点</h5>到这里，大家都知道RSA相对比较安全，但是通过数学算法来加密和解密，效率比较低，所以一般RSA的主战场是加密比较小的数据，比如对大数据进行对称加密，再用RSA给对称加密的KEY进行加密，或者加密Hash值，也就是数字签名。</li>
</ul>
<p>关于RSA数字签名后面再慢慢阐述。该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime底层原理总结--反汇编分析消息转发</title>
    <url>/2019/06/22/runtime-fan-hui-bian/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0353c6ce7788cf39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反汇编分析消息转发"></p>
<blockquote>
<p>消息转发：发送一个消息，也就是sel查找imp，当没有找到imp，接下来进入动态方法解析，如果开发者并没有处理，会进入消息转发。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>前几篇文章介绍了<a href="https://www.jianshu.com/p/1ddd15e47343">Runtime底层原理</a>和<a href="https://www.jianshu.com/p/a7db9f0c82d6">动态方法解析总结</a></p>
</blockquote>
<p>，我们知道如果前面的动态方法解析也没有解决问题的话，那么就会进入消息转发<code>_objc_msgForward_impcache</code>方法，会有快速消息转发和慢速消息转发。<br><code>_objc_msgForward_impcache</code>方法会从C转换到汇编部分<code>__objc_msgForward_impcache</code>进行快速消息转发，执行闭源<code>__objc_msgForward</code>。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-3eb7d8eb18b221b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="汇编部分__objc_msgForward"></p>
<p>如果我们的方法没有查找到会报错<code>_forwarding_prep_0</code><br><img src="https://upload-images.jianshu.io/upload_images/5741330-9ef2ef6fcc43679a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃信息"></p>
<p>但是我们在源代码中找不到该方法，除了前面文章—<a href="https://www.jianshu.com/p/1ddd15e47343">Runtime底层原理—动态方法解析、消息转发源码分析</a>提到的方法外，我们可以用反汇编分析消息转发。</p>
<p>首先进入<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/CoreFoundation.framework</code>中，找到可执行文件<code>CoreFoundation</code>，将该文件拖入hopper中，找到<code>CFInitialze</code>可以看到了<code>___forwarding_prep_0___</code><br><img src="https://upload-images.jianshu.io/upload_images/5741330-0b90c8c5ea93efc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forwarding_prep_0"></p>
<p>进入<code>___forwarding_prep_0___</code>内部，<br><img src="https://upload-images.jianshu.io/upload_images/5741330-05fba25f458f9938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="____forwarding___"></p>
<p>从崩溃堆栈信息中看到有执行forwarding，进入forwarding内部，里面判断了_objc_msgSend_stret、_objc_msgSend、taggedpointer之后有个<code>forwardingTargetForSelector:</code>，判断<code>forwardingTargetForSelector:</code>没有实现，没有实现跳转到loc_126fc7，<br><img src="https://upload-images.jianshu.io/upload_images/5741330-0a615756710dd4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forwardingTargetForSelector"></p>
<p>进入loc_126fc7，判断僵尸对象之后执行方法签名<code>methodSignatureForSelector:</code>，如果有值，获取Name、是否有效的位移等，之后会响应<code>_forwardStackInvocation:</code>，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-828729004c8eb7f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_forwardStackInvocation"></p>
<p>如果没有响应<code>_forwardStackInvocation:</code>，则会响应<code>forwardInvocation:</code>，给rdi发送rax消息，rdi就是NSInvocation，rax就是sel<code>forwardInvocation:</code>，<strong>这就是消息转发的流程</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-025bfb972fbb00fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="selforwardInvocation"></p>
<p>对<code>_objc_msgForward</code>部分进行反汇编成OC代码：<br></p><pre class="line-numbers language-none"><code class="language-none">
int __forwarding__(void *frameStackPointer, int isStret) {
    id receiver = *(id *)frameStackPointer;
    SEL sel = *(SEL *)(frameStackPointer + 8);
    const char *selName = sel_getName(sel);
    Class receiverClass = object_getClass(receiver);
    
    // 调用 forwardingTargetForSelector:
    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {
        id forwardingTarget = [receiver forwardingTargetForSelector:sel];
        if (forwardingTarget &amp;&amp; forwarding != receiver) {
            if (isStret == 1) {
                int ret;
                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);
                return ret;
            }
            return objc_msgSend(forwardingTarget, sel, ...);
        }
    }
    
    // 僵尸对象
    const char *className = class_getName(receiverClass);
    const char *zombiePrefix = "_NSZombie_";
    size_t prefixLen = strlen(zombiePrefix); // 0xa
    if (strncmp(className, zombiePrefix, prefixLen) == 0) {
        CFLog(kCFLogLevelError,
              @"*** -[%s %s]: message sent to deallocated instance %p",
              className + prefixLen,
              selName,
              receiver);
        &lt;breakpoint-interrupt&gt;
    }
    
    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation
    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {
        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];
        if (methodSignature) {
            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;
            if (signatureIsStret != isStret) {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.",
                      selName,
                      signatureIsStret ? "" : not,
                      isStret ? "" : not);
            }
            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {
                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];
                
                [receiver forwardInvocation:invocation];
                
                void *returnValue = NULL;
                [invocation getReturnValue:&amp;value];
                return returnValue;
            } else {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message",
                      receiver,
                      className);
                return 0;
            }
        }
    }
    
    SEL *registeredSel = sel_getUid(selName);
    
    // selector 是否已经在 Runtime 注册过
    if (sel != registeredSel) {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort",
              sel,
              selName,
              registeredSel);
    } // doesNotRecognizeSelector
    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {
        [receiver doesNotRecognizeSelector:sel];
    }
    else {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort",
              receiver,
              className);
    }
    
    // The point of no return.
    kill(getpid(), 9);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该文章为记录本人的学习路程，希望能够帮助大家！！！<p></p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Runtime</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Runloop底层原理--源码分析</title>
    <url>/2019/04/05/runtime-jian-jie/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7f293e1c5c8cb366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runtime底层原理"></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106-SW2">Runtime官方文档介绍直通车</a></p>
<blockquote>
<p>扩展：编译时<br>看到运行时就会想到编译时，编译时主要是将源代码翻译成可识别的机器语言，如果编译时类型检查等翻译过程中发现语法分析之类有错误会给出相应的提示。比如OC，swift，Java等高级语言的可读性比较强，但是一般不会被机器直接识别，所以需要将他们编译成机器语言（汇编等），转为二进制</p>
</blockquote>
<h4 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h4><p>在 Objective-C 中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，<br></p><pre class="line-numbers language-none"><code class="language-none">[receiver message]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数:消息接收者和消息对应的方法——也就是方法编号（name），<strong>发送消息时候，通过sel找到函数实现的指针imp</strong><br><pre class="line-numbers language-none"><code class="language-none">objc_msgSend(receiver, selector)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>编译器将自动插入调用该消息函数的代码，同时接收消息中的任意数目的参数:<br><pre class="line-numbers language-none"><code class="language-none">objc_msgSend(receiver, selector, arg1, arg2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>该消息函数做了动态绑定所需要的一切:</strong><p></p>
<ul>
<li>它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。</li>
<li>然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传给找到的方法实现。</li>
<li>最后，将方法实现的返回值作为该函数的返回值返回。</li>
</ul>
<p><strong>消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素:</strong></p>
<ul>
<li>指向父类的指针。</li>
<li>类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。</li>
</ul>
<h4 id="和运行时系统的交互"><a href="#和运行时系统的交互" class="headerlink" title="和运行时系统的交互"></a>和运行时系统的交互</h4><p>Objective-C 程序有三种途径和运行时系统交互:</p>
<ul>
<li>通过Objective-C源代码<br>大部分情况下，运行时系统在后台自动运行，当编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。运行时系统的主要功能就是根据源代码中的表达式发送消息。</li>
<li>通过Foundation框架中 NSObject 的方法<br>Cocoa程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承 了NSObject的行为。然而，某些情况下， NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码（比如 description 方法）。某些 NSObject 的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查（比如methodForSelector方法返回指定方法实现的地址）。</li>
<li>通过调用运行时系统函数<br>直接调用运行时系统给我们提供的API接口</li>
</ul>
<h4 id="Runtime函数注释"><a href="#Runtime函数注释" class="headerlink" title="Runtime函数注释"></a>Runtime函数注释</h4><pre class="line-numbers language-none"><code class="language-none">
// 1.objc_xxx系列函数  宏观使用,如类与协议的空间分配,注册,注销等操作
// 函数名称     函数作用
objc_getClass     获取Class对象
objc_getMetaClass     获取MetaClass对象
objc_allocateClassPair     分配空间,创建类(仅在 创建之后,注册之前 能够添加成员变量)
objc_registerClassPair     注册一个类(注册后方可使用该类创建对象)
objc_disposeClassPair     注销某个类
objc_allocateProtocol     开辟空间创建协议
objc_registerProtocol     注册一个协议
objc_constructInstance     构造一个实例对象(ARC下无效)
objc_destructInstance     析构一个实例对象(ARC下无效)
objc_setAssociatedObject     为实例对象关联对象
objc_getAssociatedObje*ct     获取实例对象的关联对象
objc_removeAssociatedObjects     清空实例对象的所有关联对象

// 2.class_xxx系列函数   类的内部,如实例变量,属性,方法,协议等相关问题
函数名称     函数作用
class_addIvar     为类添加实例变量
class_addProperty     为类添加属性
class_addMethod     为类添加方法
class_addProtocol     为类遵循协议
class_replaceMethod     替换类某方法的实现
class_getName     获取类名
class_isMetaClass     判断是否为元类
objc_getProtocol     获取某个协议
objc_copyProtocolList     拷贝在运行时中注册过的协议列表
class_getSuperclass     获取某类的父类
class_setSuperclass     设置某类的父类
class_getProperty     获取某类的属性
class_getInstanceVariable     获取实例变量
class_getClassVariable     获取类变量
class_getInstanceMethod     获取实例方法
class_getClassMethod     获取类方法
class_getMethodImplementation     获取方法的实现
class_getInstanceSize     获取类的实例的大小
class_respondsToSelector     判断类是否实现某方法
class_conformsToProtocol     判断类是否遵循某协议
class_createInstance     创建类的实例
class_copyIvarList     拷贝类的实例变量列表
class_copyMethodList     拷贝类的方法列表
class_copyProtocolList     拷贝类遵循的协议列表
class_copyPropertyList     拷贝类的属性列表

// 3.object_xxx系列函数   对象的角度,如实例变量
函数名称     函数作用
object_copy     对象copy(ARC无效)
object_dispose     对象释放(ARC无效)
object_getClassName     获取对象的类名
object_getClass     获取对象的Class
object_setClass     设置对象的Class
object_getIvar     获取对象中实例变量的值
object_setIvar     设置对象中实例变量的值
object_getInstanceVariable     获取对象中实例变量的值 (ARC中无效,使用object_getIvar)
object_setInstanceVariable     设置对象中实例变量的值 (ARC中无效,使用object_setIvar)

// 4.method_xxx系列函数   方法内部,如方法的参数及返回值类型和方法的实现
函数名称     函数作用
method_getName     获取方法名
method_getImplementation     获取方法的实现
method_getTypeEncoding     获取方法的类型编码
method_getNumberOfArguments     获取方法的参数个数
method_copyReturnType     拷贝方法的返回类型
method_getReturnType     获取方法的返回类型
method_copyArgumentType     拷贝方法的参数类型
method_getArgumentType     获取方法的参数类型
method_getDescription     获取方法的描述
method_setImplementation     设置方法的实现
method_exchangeImplementations     替换方法的实现

// 5.property_xxx系列函数   属性*内部,如属性的特性等
函数名称     函数作用
property_getName     获取属性名
property_getAttributes     获取属性的特性列表
property_copyAttributeList     拷贝属性的特性列表
property_copyAttributeValue     拷贝属性中某特性的值

// 6.protocol_xxx系列函数 协议相关
函数名称     函数作用
protocol_conformsToProtocol     判断一个协议是否遵循另一个协议
protocol_isEqual     判断两个协议是否一致
protocol_getName     获取协议名称
protocol_copyPropertyList     拷贝协议的属性列表
protocol_copyProtocolList     拷贝某协议所遵循的协议列表
protocol_copyMethodDescriptionList     拷贝协议的方法列表
protocol_addProtocol     为一个协议遵循另一协议
protocol_addProperty     为协议添加属性
protocol_getProperty     获取协议中的某个属性
protocol_addMethodDescription     为协议添加方法描述
protocol_getMethodDescription     获取协议中某方法的描述

// 7.ivar_xxx 系列函数  实例变量相关
函数名称     函数作用
ivar_getName     获取Ivar名称
ivar_getTypeEncoding     获取类型编码
ivar_getOffset     获取偏移量

// 8.sel_xxx系列函数   方法编号相关
函数名称     函数作用
sel_getName     获取名称
sel_getUid     注册方法
sel_registerName     注册方法名
sel_isEqual     判断方法是否相等

// 9.imp_xxx系列函数   方法实现相关
函数名称     函数作用
imp_implementationWithBlock     通过代码块创建IMP
imp_getBlock     获取函数指针中的代码块
imp_removeBlock     移除IMP中的代码块
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想继续探究Runtime底层原理，下篇是<a href="[https://www.jianshu.com/p/1ddd15e47343](https://www.jianshu.com/p/1ddd15e47343">Runtime源码分析</a><br>)，包括动态方法解析和消息转发。<br>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode无线调试</title>
    <url>/2019/06/13/xcode-diao-shi/</url>
    <content><![CDATA[<blockquote>
<p>Xcode无线调试是WWDC2017的一个新功能，首先要满足iOS11以上，Xcode9以上；</p>
</blockquote>
<p>首先，把iOS11以上的iOS设备连接到Xcode9，<code>shift + Commond + 2</code>快速打开设备列表，或者在菜单中打开window，找到Device and simulators。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-7238d561bae28e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设备列表"><br>打开后，勾选Connect via network，成功后拔掉数据线。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-01c0b1accb60a294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接局域网"></p>
<p>在左侧列表中，右击刚刚连接的iOS设备，找到Connect via IP address<br><img src="https://upload-images.jianshu.io/upload_images/5741330-c61c242cf41572b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置局域网"></p>
<p>输入iOS设备的IP地址，connect连接成功。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-d12495841f163111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置IP地址"></p>
<blockquote>
<p>IP地址在iOS设备的设置-&gt;无线局域网，找到当前的网络，进入详情中查看IP地址。</p>
</blockquote>
<p>现在iOS设备不需要连接数据线就可以进行调试了，这个也是很早就开始用了，只不过最近突然出现点问题，重新配置并记录下。</p>
<p>如果出现<code>The device must have a passcode set in order to allow this operation</code>错误，那么给手机设置一个密码，再次重新操作就OK了。希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Xcode调试</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC底层原理--YYModel简述</title>
    <url>/2019/07/15/yymodel-jian-jie/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-29717fbfde50dc23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVC底层原理"></p>
<p>YYModel的作用就是字典转模型，在了解YYModel前，我们先了解下KVC的知识。</p>
<blockquote>
<p>KVC：也称之键值编码，是一种采用了<code>NSKeyValueCoding</code>协议的对象（直接或间接继承NSObject时会为基本方法提供默认实现）通过间接访问其属性的机制，也就是符合键值编码，对象可通过字符串参数来简单而统一的消息对其属性进行寻址，例如<code>valueForKey:</code>和 <code>setValue:forKey:</code>。在一些特殊情况下，KVC还可以简化代码。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">官方文档直通车</a><br><a id="more"></a></p>
</blockquote>
<h4 id="KVC底层原理"><a href="#KVC底层原理" class="headerlink" title="KVC底层原理"></a>KVC底层原理</h4><p>举例：用键值编码实现数据源方法<br></p><pre class="line-numbers language-none"><code class="language-none">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row
{
    return [[self.people objectAtIndex:row] valueForKey:[column identifier]];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>或者我们常用的设置textFiled的placeholder颜色<br><pre class="line-numbers language-none"><code class="language-none">[self.textFiled setValue:[UIColor greenColor] forKeyPath:@"_placeholderLabel.textColor"];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p>
<blockquote>
<p>当调用协议的 getter（比如<code>valueForKey:</code>）， 默认实现根据<code>Accessor Search Patterns</code>中描述的规则确定为指定键提供值的特定访问器方法或实例变量. 如果返回值不是对象，getter会使用这个值初始一个NSNumber对象或NSValue（对于结构体）对象替代。同样setter（比如<code>setValue:forKey:</code>）通过特定键或访问方法或实例变量时确定的数据类型，如果数据类型不是对象，setter首先会向传入的值对象发送适当的 <type>Value 消息(intValue)提取基础数据并存储该数据。仅限<strong>Objective-C</strong>，因为<strong>Swift</strong>的所有属性都是对象。</type></p>
</blockquote>
<p>自动包装和解包不仅限于 NSPoint，NSRange，NSRect，和 NSSize. 也可以是 NSValue 对象。举例：<br></p><pre class="line-numbers language-none"><code class="language-none">typedef struct {
    float x, y, z;
} ThreeFloats;
 
@interface MyClass
@property (nonatomic) ThreeFloats threeFloats;
@end
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>使用KVC获取myClass的<code>threeFloats</code>：默认调用threeFloats的<code>getter</code>，然后将返回值包装在NSValue中返回。<br><pre class="line-numbers language-none"><code class="language-none">NSValue* result = [myClass valueForKey:@"threeFloats"];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>当然，我们也可以使用KVC来设置threeFloats的值<br><pre class="line-numbers language-none"><code class="language-none">ThreeFloats floats = {1., 2., 3.};
NSValue* value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];
[myClass setValue:value forKey:@"threeFloats"];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="KVC取值和赋值的过程"><a href="#KVC取值和赋值的过程" class="headerlink" title="KVC取值和赋值的过程"></a>KVC取值和赋值的过程</h5><p>首先，我们先根据官方文档找到<code>Accessor Search Patterns</code>来查看根据输入<code>key</code>的搜索流程。下面是官方文档的部分说明，具体参考官方文档</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-1e29125d421d21c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方文档"></p>
<p>说的就是在getter的时候，先按照<code>get&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;, or _&lt;key&gt;</code>的顺序来查找，找到了就直接调用，然后判断收到的属性值是一个对象指针直接返回，该值是NSNumber支持的标量类型则用包装NSNumber返回，否则包装成 NSValue 对象返回。如果没有找到则在实例中搜索<code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex:（对应于NSArray基本方法）和&lt;key&gt;AtIndexes:（对应于NSArray的objectsAtIndexes）</code>，如果找到则创建一个响应所有NSArray方法的集合代理对象并返回，如果还是没有找到则查找<code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt;:（对应于 NSSet 类的基本方法）</code>，如果三个方法都找到，会创建一个响应所有NSSet方法的集合代理对象并返回该方法。如果还没找到并且接收者对象的<code>accessInstanceVariablesDirectly</code>（是否开启间接访问）返回 YES，则会顺序查找<code>_&lt;key&gt;, _is&lt;key&gt;, &lt;key&gt;, is&lt;key&gt;</code>，如果找到了则返回相应的值（对象指针、NSNumber或者NSValue），如果最后还是没找到则会执行<code>valueForUndefindKey:</code>，默认抛出异常，NSObject子类可以重写。</p>
<p>在setter的时候也是顺序查找访问方法名<code>set&lt;key&gt;, _set&lt;key&gt;</code>，找到了就则使用输入值执行，没找到且<code>accessInstanceVariablesDirectly</code>返回YES，则按照顺序查找<code>_&lt;key&gt;, _is&lt;key&gt;, &lt;key&gt;, is&lt;key&gt;</code>，如果找到了就执行没找到则执行<code>setValue:forUndefinedKey:</code>抛出未定义key的异常，同样NSObject子类可以重写。</p>
<p>当没有对异常进行处理的话，不出意外会崩溃。</p>
<blockquote>
<p>在赋值和取值过程中，当value为空的时候，会执行<code>setNilValueForKey</code>，如果Key值不存在则执行<code>setValue:forUndefinedKey</code>。<br>KVC也可以用于验证key或key-path的方法，我们也可以为属性提供验证方法。在响应<code>validateValue:forKey:error:</code>方法的时候，会查找<code>valudate&lt;Key&gt;:error:</code>是否实现，如果实现了则根据实现方法的自定义逻辑返回YES或者NO，如果没实现则系统默认返回YES，NSError用来返回error信息。</p>
</blockquote>
<h5 id="KVC异常处理"><a href="#KVC异常处理" class="headerlink" title="KVC异常处理"></a>KVC异常处理</h5><p>那在实际运用的时候万一出现意外，要怎么规避呢？可以在NSObject的分类做下相应的处理（OC的对象几乎都可以追溯到NSObject）。<br></p><pre class="line-numbers language-none"><code class="language-none">// .h文件代码
- (void)k_setValue:(nullable id)value forKey:(NSString *)key;
- (nullable id)k_valueForKey:(NSString *)key;
// ------------------华丽的分割线----------------------
// .m文件代码
- (void)k_setValue:(id)value forKey:(NSString *)key {
    NSError  *error;
    BOOL validate = [self validateValue:&amp;value forKey:key error:&amp;error];
    NSArray *arr = [self getIvarListName];
    if (validate) {
        if ([arr containsObject:key]) {
            [self setValue:value forKey:key];
        }else{
            NSLog(@"%@ 不存在变量",key);
        }
    }
}

- (nullable id)k_valueForKey:(NSString *)key {
    if (key == nil || key.length == 0) {
        NSLog(@"key为nil或者空值");
        return nil;
    }
    NSArray *arr = [self getIvarListName];
    if ([arr containsObject:key]) {
        return [self valueForKey:key];
    }
    NSLog(@"%@ 不存在变量",key);
    return nil;
}

- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError {
    if (*ioValue == nil || inKey == nil || inKey.length == 0) {
        NSLog(@"value 可能为nil  或者key为nil或者空值");
        return NO;
    }
    return YES;
}

- (NSMutableArray *)getIvarListName {
    NSMutableArray *mulArr = [NSMutableArray arrayWithCapacity:1];
    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([self class], &amp;count);
    for (int i = 0; i&lt;count; i++) {
        Ivar ivar = ivars[i];
        const char *ivarNameChar = ivar_getName(ivar);
        NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar];
        NSLog(@"ivarName == %@",ivarName);
        [mulArr addObject:ivarName];
    }
    free(ivars);
    return mulArr;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>记得添加<code>#import &lt;objc/runtime.h&gt;</code>，在调用<code>k_setValue forKey</code>或者<code>k_valueForKey</code>的时候会自动检测value和key是否有效值，如果不是有效值会抛出<p></p>
<h5 id="KVC使用"><a href="#KVC使用" class="headerlink" title="KVC使用"></a>KVC使用</h5><ul>
<li>字典的使用<pre class="line-numbers language-none"><code class="language-none">NSDictionary* dict = @{
                           @"oneString":@"one",
                           @"num":@123,
                           @"list":@[@1, @2, @3]
                           };
    Person *p = [[Person alloc] init];
    // 字典转模型
    [p setValuesForKeysWithDictionary:dict];
    NSLog(@"%@--%d---%@",p.oneString, p.num, p.list);
    // 键数组转模型到字典
    NSArray *array = @[@"oneString",@"num"];
    NSDictionary *dic = [p dictionaryWithValuesForKeys:array];
    NSLog(@"%@",dic);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
打印结果如下：<pre class="line-numbers language-none"><code class="language-none">one--123---(
    1,
    2,
    3
)

{
    num = 123;
    oneString = one;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>KVC消息传递<pre class="line-numbers language-none"><code class="language-none">NSArray *array = @[@"One",@"Two",@"Three",@"HH"];
NSArray *lenStr= [array valueForKeyPath:@"length"];
NSLog(@"%@",lenStr);// 消息从array传递给了string
NSArray *lowStr= [array valueForKeyPath:@"lowercaseString"];
NSLog(@"%@",lowStr);
// 也支持聚合操作符
int count = [[array valueForKeyPath:@"@count.length"] intValue];
NSLog(@"%d", count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
打印结果：<pre class="line-numbers language-none"><code class="language-none">(
    3,
    3,
    5,
    2
)

(
    one,
    two,
    three,
    hh
)

 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>补充<br>当然了，聚合操作符还有很多，列举一些可能用到的：<br><strong>@avg：</strong>通过right-key-path读取集合中每个元素读取属性，并转换为double类型(nil用0代替)，计算他们的平均值，然后返回NSNumber。<br><strong>@ sum：</strong>原理同 ‘@avg’，返回所有元素的和。<br><strong>@ count：</strong>以NSNumber实例返回集合中所有对象的数量，如果有right-key-path忽略。<br><strong>@ max：</strong>通过right-key-path在集合中查找并返回最大的元素。查找会使用由Foundation类(例如 NSNumber) 定义的compare: 方法，所以right-key-path指定的属性必须是一个对这个消息有意义的响应，查找忽略集合中的nil值。<br><strong>@min：</strong>原理同 ‘@max’，返回最小的元素。<br>下面的也可以对集合进行操作<br><strong>@distinctUnionOfObjects：</strong>返回对right-key-path指定属性进行合并操作后的去重数组。<br><strong>@ unionOfObjects：</strong>和distinctUnionOfObjects行为相似, 但是不会删除重复对象。<br><strong>@ distinctUnionOfSets：</strong>和distinctUnionOfObjects行为相似获取交集。</li>
</ul>
<h4 id="键值模型—YYModel"><a href="#键值模型—YYModel" class="headerlink" title="键值模型—YYModel"></a>键值模型—YYModel</h4><blockquote>
<p>字典转模型的大概流程是分析对象，获取到对象的所有ivar，并将ivar一一赋值。</p>
</blockquote>
<p>首先，我们进入YYModel的字典转模型入口<code>yy_modelWithDictionary</code>、<code>modelWithJSON</code>方法，部分代码展示：<br></p><pre class="line-numbers language-none"><code class="language-none">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary {
    if (!dictionary || dictionary == (id)kCFNull) return nil;
    if (![dictionary isKindOfClass:[NSDictionary class]]) return nil;
    
    Class cls = [self class];
    // 分析cls
    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];
    if (modelMeta-&gt;_hasCustomClassFromDictionary) {
        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;
    }
    
    NSObject *one = [cls new];
    if ([one yy_modelSetWithDictionary:dictionary]) return one;
    return nil;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在<code>metaWithClass:</code>方法内部先用Core Foundation的CFMutableDictionaryRef进行缓存已经处理过的key-value，以备下次直接使用，并用dispatch_semaphore_t来确保字典的读取安全。如果没有该缓存或者不需要更新则进行创建<code>_YYModelMeta</code>对象，<code>_YYModelMeta</code>首先对黑名单和白名单进行处理，再次判断<code>modelContainerPropertyGenericClass</code>是否需要对特殊属性进行替换（按照不同的类型进行遍历 ），然后开始遍历自己和父类所有的属性和方法，生成与数据源相对应的字典映射（具体可网上查找），接着处理_YYModelPropertyMeta，判断是NSString、NSArray，一切准备好后开始执行<code>yy_modelSetWithDictionary:</code>方法响应<code>CFArrayApplyFunction</code>，再次执行<code>ModelSetWithPropertyMetaArrayFunction</code>，获取到的value传入<code>ModelSetValueForProperty</code>中，通过objc_msgSend发送<code>meta-&gt;_setter</code>来完成属性值的设置。<br><pre class="line-numbers language-none"><code class="language-none">switch (meta-&gt;_nsType) {
                case YYEncodingTypeNSString:
                case YYEncodingTypeNSMutableString: {
                    if ([value isKindOfClass:[NSString class]]) {
                        if (meta-&gt;_nsType == YYEncodingTypeNSString) {
                            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, value);
                        } else {
                            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, ((NSString *)value).mutableCopy);
                        }
                    } else if ([value isKindOfClass:[NSNumber class]]) {
                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,
                                                                       meta-&gt;_setter,
                                                                       (meta-&gt;_nsType == YYEncodingTypeNSString) ?
                                                                       ((NSNumber *)value).stringValue :
                                                                       ((NSNumber *)value).stringValue.mutableCopy);
                    } else if ([value isKindOfClass:[NSData class]]) {
                        NSMutableString *string = [[NSMutableString alloc] initWithData:value encoding:NSUTF8StringEncoding];
                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, string);
                    } else if ([value isKindOfClass:[NSURL class]]) {
                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,
                                                                       meta-&gt;_setter,
                                                                       (meta-&gt;_nsType == YYEncodingTypeNSString) ?
                                                                       ((NSURL *)value).absoluteString :
                                                                       ((NSURL *)value).absoluteString.mutableCopy);
                    } else if ([value isKindOfClass:[NSAttributedString class]]) {
                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,
                                                                       meta-&gt;_setter,
                                                                       (meta-&gt;_nsType == YYEncodingTypeNSString) ?
                                                                       ((NSAttributedString *)value).string :
                                                                       ((NSAttributedString *)value).string.mutableCopy);
                    }
                } break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该文章为记录本人的学习路程，希望能够帮助大家，知识共享，共同成长，共同进步！！！<p></p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中实例变量、成员变量和属性变量的区别</title>
    <url>/2019/06/23/ios-shu-xing/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-99ec68ecf0493fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例变量、成员变量和属性变量的区别"></p>
<p>作为iOS开发，会经常听到成员变量、实例变量和属性；那他们有什么区别吗？</p>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p><strong>实例变量:</strong> class类进行实例化出来的对象为实例对象；比如:<br></p><pre class="line-numbers language-none"><code class="language-none">Person *p = [Person new];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p><strong>成员变量:</strong> 在<code>{ }</code>中所声明的变量都是成员变量(实例变量是一种特殊的成员变量)。其中的hell、btn也是实例对象，id是一种特殊的class，是OC特有的对象。成员变量是私有变量，外部不会获取到。<br></p><pre class="line-numbers language-none"><code class="language-none">@interface Person : NSObject{
    @public
    NSString *myName; //成员
    id hell; // id - &gt; class
    UIButton *btn;
    int age;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="属性变量"><a href="#属性变量" class="headerlink" title="属性变量"></a>属性变量</h4><p><strong>属性变量:</strong> 属性是与其他对象交互的变量，会生成默认的setter和getter方法。苹果早期的编译器是GCC，后来发展到LLVM，LLVM在没有匹配实例变量的属性时会自动创建一个带下划线的成员变量。<strong>注意：分类中添加的属性是不会自动生成setter和getter方法的，必须要手动添加</strong>。如果已经手动实现了get和set方法的话Xcode不会再自动生成带有下划线的私有成员变量了，因为xCode自动生成成员变量的目的就是为了根据成员变量而生成get/set方法的，但是如果get和set方法缺一个的话都会生成带下划线的变量。</p>
<h5 id="给分类添加属性"><a href="#给分类添加属性" class="headerlink" title="给分类添加属性"></a>给分类添加属性</h5><p>.h文件<br></p><pre class="line-numbers language-none"><code class="language-none">#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (Person)

@property (nonatomic, copy) NSString *name;

@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>.m文件<br><pre class="line-numbers language-none"><code class="language-none">#import "NSObject+Person.h"
#import &lt;objc/runtime.h&gt; /*或者 #import &lt;objc/message.h&gt;*/
static NSString *nameKey = @"nameKey"; // name的key

@interface NSObject ()

@end

@implementation NSObject (Person)

/**
 setter方法
 */
- (void)setName:(NSString *)name {
    objc_setAssociatedObject(self, &amp;nameKey, name, OBJC_ASSOCIATION_COPY);
}

/**
 getter方法
 */
- (NSString *)name {
    return objc_getAssociatedObject(self, &amp;nameKey);
}
@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>使用：<br><pre class="line-numbers language-none"><code class="language-none">- (void)viewDidLoad {
    NSObject *objc = [[NSObject alloc] init];
    objc.name = @"Vincent";
    NSLog(@"%@", objc.name);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="property和-synthesize"><a href="#property和-synthesize" class="headerlink" title="@property和@synthesize"></a><code>@property</code>和<code>@synthesize</code></h5><p><code>@synthesize</code>让编译器自动生成setter和getter，可以制定属性对应的成员变量。</p>
<p>在Xcode4.4版本之前<code>@property</code>和<code>@synthesize</code>的功能是独立分工的：</p>
<ol>
<li><code>@property</code>的作用是：自动的生成成员变量set/get方法的声明如代码：  <pre class="line-numbers language-none"><code class="language-none">@property int age; // 它的作用和下面两行代码的作用一致
- (void)setAge:(int)age;
- (int)age;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<strong>注意：属性名称不要加前缀下划线，否则生成的get/set方法中也会有下划线_</strong> </li>
<li><p><code>@synthesize</code>的作用是实现<code>@property</code>定义的方法代码如：</p>
   <pre class="line-numbers language-none"><code class="language-none">@synthesize age<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   将<code>@property</code>中定义的属性自动生成get/set的实现方法而且默认访问成员变量age，如果指定访问成员变量_age的话代码如：</p>
   <pre class="line-numbers language-none"><code class="language-none">@synthesize age = _age；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   把@property中声明的age成员变量生成get/set实现方法，并且在实现方法内部访问_age这个成员变量，也就意味着给成员_age赋值。</p>
<blockquote>
<p>注意：访问成员变量 _age 如果在.h文件中没有定义_age成员变量的话，就会在.m文件中自动生成@private类型的成员变量_age</p>
</blockquote>
</li>
</ol>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac电脑配置福利Alfred、Go2shell、iTerm2+Oh My Zsh</title>
    <url>/2021/02/02/itunes/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d655dfa497bbcfd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电脑配置"></p>
<p>哎，一年换了个21-inch iMac，两个27-inch iMac，加上重做系统就更不说了，每次都要下载各种软件，各种配置。。。故记录这篇文章以免自己以后老了记不住，希望可以帮到更多人吧！</p>
<h4 id="效率神器Alfred、Go2shell"><a href="#效率神器Alfred、Go2shell" class="headerlink" title="效率神器Alfred、Go2shell"></a>效率神器Alfred、Go2shell</h4><p>首先，拿到新电脑，需要下载很多软件，第一时间把<code>Alfred</code>和<code>Go2shell</code>安装好，这里有<a href="xclient.info">各种破解软件免费下载平台</a>，里面安装教程很详细，默认<code>alt + 空格</code>打开Alfred，Go2shell就是可以快速打开当前路径的终端，用起来还是很方便的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-8400d17b9f794546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Go2shell"></p>
<h4 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h4><p>接下来根据个人喜好配置终端，之前也一直在用苹果自带的终端，但是自从接触了iTerm2后就无法自拔了。</p>
<ul>
<li><p>安装iTerm2<br>先去官网下载iTerm2，<a href="http s://www.iterm2.com/downloads.html">iTerm2下载地址：</a><a href="https://www.iterm2.com/downloads.html">https://www.iterm2.com/downloads.html</a></p>
</li>
<li><p>配置iTerm2<br>目前iTerm2 最常用的主题是<code>Solarized Dark theme</code>，下载地址：<a href="http://ethanschoonover.com/solarized">http://ethanschoonover.com/solarized</a>，下载好的压缩文件解压后，打开 iTerm2的<code>Preferences</code>配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-889dc79aadf6e185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加主题文件"></p>
<p>选择刚才解压的solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors文件，导入成功，最后选择 Solarized Dark 主题。</p>
<h4 id="配置Oh-My-Zsh"><a href="#配置Oh-My-Zsh" class="headerlink" title="配置Oh My Zsh"></a>配置Oh My Zsh</h4><p>一款用于管理zsh配置，可以提供超级多而强大的插件和漂亮的主题。可以去GitHub下载<a href="https://github.com/robbyrussell/oh-my-zsh">Oh My Zsh</a></p>
<ul>
<li>安装Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 使用 crul 安装：
$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
或者<pre class="line-numbers language-none"><code class="language-none">// 使用wget：
$ sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
安装成功后</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3fe231151c615c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Oh My Zsh"></p>
<ul>
<li>卸载Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 卸载oh-my-zsh命令：
$ uninstall_oh_my_zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>设置当前用户的默认Shell为Zsh<pre class="line-numbers language-none"><code class="language-none">$ chsh -s /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
接下来，将主题配置修改为ZSH_THEME=”agnoster”<pre class="line-numbers language-none"><code class="language-none">$ vim ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
到目前为止，不出意外的话，iTerm2外观应该是这样的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92007dc6e28a9a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2外观"></p>
<p>界面显示乱码原因是没有安装<code>Meslo</code>字体，字体下载地址：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a>，下载后安装接下来还是打开 iTerm2的Preferences 配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-ffed44579f071798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Meslo字体"><br>成功后的截图<br><img src="https://upload-images.jianshu.io/upload_images/5741330-e95f6971f45f9469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2+Oh My Zsh"></p>
<p>也可以修改合适的字体大小。</p>
<h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>这个功能是非常实用的，可以方便我们快速的敲命令。</p>
<p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：<br></p><pre class="line-numbers language-none"><code class="language-none">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后编辑<code>vim ~/.zshrc</code>文件，找到<code>plugins</code>配置，增加<code>zsh-autosuggestions</code>插件。如果配置不生效增加zsh-syntax-highlighting插件试试。<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-275b4a55100f9dac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动填充"></p>
<h4 id="隐藏用户名和主机名"><a href="#隐藏用户名和主机名" class="headerlink" title="隐藏用户名和主机名"></a>隐藏用户名和主机名</h4><p>进入Oh My Zsh主题文件列表<br></p><pre class="line-numbers language-none"><code class="language-none">$ cd ~/.oh-my-zsh/themes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>进入已选的主题，并找到<code>prompt_context</code>，然后进行修改<br><pre class="line-numbers language-none"><code class="language-none">### Prompt components
# Each component will draw itself, and hide itself if no information needs to be shown

# Context: user@hostname (who am I and where am I)
prompt_context() {
  if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then
    # prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"
    prompt_segment black default "Vincent" // Vincent是写死的名字 可以根据个人爱好随意设置
  fi
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://upload-images.jianshu.io/upload_images/5741330-3c6300f5a99d9272.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隐藏用户名和主机名"><p></p>
<p>还有一些插件和功能网上很多，暂不做更多介绍。</p>
<p>该文章为记录本人的电脑配置，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Mac配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime底层原理--动态方法解析总结</title>
    <url>/2019/05/28/dong-tai-fang-fa/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-c73a334b9284e2bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态方法解析总结"></p>
<blockquote>
<p>方法的底层会编译成消息，消息进行递归，先从实例方法开始查找，到父类最后到NSObject。如果在汇编部分快速查找没有找到IMP，就会进入C/C++中的动态方法解析进入<code>lookUpImpOrForward</code>方法进行递归。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>动态方法解析分为实例方法和类方法两种。</p>
</blockquote>
<h5 id="实例方法查找imp流程和动态方法解析"><a href="#实例方法查找imp流程和动态方法解析" class="headerlink" title="实例方法查找imp流程和动态方法解析"></a>实例方法查找imp流程和动态方法解析</h5><p>比如执行一个Student实例方法eat，会先去这个类中查找是否有该方法（sel）,如果有则进行存储以便下次直接从汇编部分快速查找。<br></p><pre class="line-numbers language-none"><code class="language-none">// Try this class's cache.
    // Student元类 - 父类 (根元类) -- NSObject
    // resovleInstance 防止递归 --
    imp = cache_getImp(cls, sel);
    if (imp) goto done;

    // Try this class's method lists.
    {
        Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {
            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
            imp = meth-&gt;imp;
            goto done;
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br> 如果没有sel那么接下来去父类（直到NSObject）的缓存和方法列表找查找。如果在父类中找到先缓存再执行done.<br><pre class="line-numbers language-none"><code class="language-none">// 元类的父类 - NSObject 是否有 实例方法
        for (Class curClass = cls-&gt;superclass;
             curClass != nil;
             curClass = curClass-&gt;superclass)
        {
            // Halt if there is a cycle in the superclass chain.
            if (--attempts == 0) {
                _objc_fatal("Memory corruption in class list.");
            }
            
            // Superclass cache.
            imp = cache_getImp(curClass, sel);
            if (imp) {
                if (imp != (IMP)_objc_msgForward_impcache) {
                    // Found the method in a superclass. Cache it in this class.
                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    goto done;
                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>如果最终还是没找到，则会进入动态方法解析<code>_class_resolveMethod</code>，先判断当前cls对象是不是元类，也就是如果是对象方法会走到<code>_class_resolveInstanceMethod</code>方法，<br><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* _class_resolveMethod
* Call +resolveClassMethod or +resolveInstanceMethod.
* Returns nothing; any result would be potentially out-of-date already.
* Does not check if the method already exists.
**********************************************************************/
void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&gt;isMetaClass()) {
        // try [cls resolveInstanceMethod:sel]

        _class_resolveInstanceMethod(cls, sel, inst);
    } 
    else {
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst, 
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) 
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>如果元类，那么执行<code>_class_resolveInstanceMethod(cls, sel, inst)</code>方法，该方法会执行<code>lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, 
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)</code>，查找当前的cls的<code>isa</code>是否实现了<code>resolveInstanceMethod</code>，也就是是否有自定义实现、是否重写了。如果查到了就会给类对象发送消息<code>objc_msgSend</code>，调起<code>resolveInstanceMethod</code>方法<br><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* lookUpImpOrNil.
* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
**********************************************************************/
IMP lookUpImpOrNil(Class cls, SEL sel, id inst, 
                   bool initialize, bool cache, bool resolver)
{
    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);
    if (imp == _objc_msgForward_impcache) return nil;
    else return imp;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>lookUpImpOrNil</code>的内部是通过<code>lookUpImpOrForward</code>方法进行查找，再次回到递归调用。<p></p>
<p>如果还是没查到，这里就不会再次进入动态方法解析（<strong>注：如果再次进入动态方法解析会形成死递归</strong>），首先对cls的元类进行查找，然后元类的父类，也就是根元类（系统默认实现的虚拟的）进行查找、最终到NSObjece，只不过NSObjece中默认实现<code>resolveInstanceMethod</code>方法返回NO，也就是此时在元类进行查找的时候找到了<code>resolveInstanceMethod</code>方法，并停止继续查找，<strong>这就是为什么动态方法解析后的递归没有再次进入动态方法解析的原因</strong>。如果最终还是没有找到<code>SEL_resolveInstanceMethod</code>则说明程序有问题，直接返回。下面是isa走位图：<br><img src="https://upload-images.jianshu.io/upload_images/5741330-8051fda5345fa755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa走位流程"></p>
<p>如果找到的imp不是转发的imp，则返回imp。<br>举个例子：<br>在Student中有个对象run方法，但是并没有实现，当调用run方法时，最终没有找到imp会崩溃。通过动态方法解析，实现run方法<br></p><pre class="line-numbers language-none"><code class="language-none">#pragma mark - 动态方法解析
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    
    NSLog(@"动态方法解析 - %@",self);
    if (sel == @selector(run)) {
        // 我们动态解析对象方法
        NSLog(@"对象方法 run 解析走这里");
        SEL readSEL = @selector(readBook);
        Method readM= class_getInstanceMethod(self, readSEL);
        IMP readImp = method_getImplementation(readM);
        const char *type = method_getTypeEncoding(readM);
        return class_addMethod(self, sel, readImp, type);
    }
    return [super resolveInstanceMethod:sel];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此时只是给对象方法添加了一个imp，接下来再次进入查找imp流程，重复之前的操作，只不过现在对象方法已经有了imp。<br><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* _class_resolveInstanceMethod
* Call +resolveInstanceMethod, looking for a method to be added to class cls.
* cls may be a metaclass or a non-meta class.
* Does not check if the method already exists.
**********************************************************************/
static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)
{
    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, 
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) 
    {
        // Resolver not implemented.
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    IMP imp = lookUpImpOrNil(cls, sel, inst, 
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);
// ...省略N行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>动态方法解析的实质：</strong> 经过漫长的查找并没有找到sel的imp，系统会发送<code>resolveInstanceMethod</code>消息，为了防止系统崩溃，可以在该方法内对sel添加imp，系统会自动再次查找imp。<p></p>
<h5 id="类方法查找imp流程和动态方法解析"><a href="#类方法查找imp流程和动态方法解析" class="headerlink" title="类方法查找imp流程和动态方法解析"></a>类方法查找imp流程和动态方法解析</h5><p>类方法查找imp流程和实例方法查找imp前面流程一样，也是从汇编部分快速查找，之后判断cls是不是元类，在元类方法列表中查找，如果元类中没有当前的sel，就去元类的父类中查找，还没有就去根元类的父类NSObject中查找，此时查找的就是NSObject中是否有这个实例对象方法，如果NSObject中也没有就会进入动态方法解析<code>_class_resolveMethod</code>。类对象这里的cls和对象方法不一样，因为cls是元类所以直接走<code>_class_resolveClassMethod</code>方法。进入<code>_class_resolveClassMethod</code>方法还是先判断<code>resolveClassMethod</code>方法是否有实现，之后发送消息<code>objc_msgSend</code>，这里和实例方法有所区别，类方法会执行<code>_class_getNonMetaClass</code>方法，内部实现<code>getNonMetaClass</code>，<code>getNonMetaClass</code>会判断当前cls是不是NSObject，判断当前的cls是不是根元类，也就是自己，接下来判断inst类对象，判断inst类对象的isa如果不是元类，那么返回类对象的父类，不是就返回类对象。在<code>_class_resolveClassMethod</code>方法中添加了imp后还是和实例方法一样，再次进入重新查找流程，此时如果还是没有，那么类方法还会再一次的进入<code>_class_resolveInstanceMethod</code>方法，和实例方法不同的是<code>resolveInstanceMethod</code>方法内部的cls是元类，所以找的方法也就是<code>- (BOOL)resolveClassMethod:(SEL)sel</code>，可以在NSObject中添加<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>方法，这样无论类方法还是实例方法都会走到这里，可以作为<strong>防崩溃的处理</strong>。<br></p><pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* getNonMetaClass
* Return the ordinary class for this class or metaclass. 
* `inst` is an instance of `cls` or a subclass thereof, or nil. 
* Non-nil inst is faster.
* Used by +initialize. 
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static Class getNonMetaClass(Class metacls, id inst)
{
    static int total, named, secondary, sharedcache;
    runtimeLock.assertLocked();

    realizeClass(metacls);

    total++;

    // return cls itself if it's already a non-meta class
    if (!metacls-&gt;isMetaClass()) return metacls;

    // metacls really is a metaclass

    // special case for root metaclass
    // where inst == inst-&gt;ISA() == metacls is possible
    if (metacls-&gt;ISA() == metacls) {
        Class cls = metacls-&gt;superclass;
        assert(cls-&gt;isRealized());
        assert(!cls-&gt;isMetaClass());
        assert(cls-&gt;ISA() == metacls);
        if (cls-&gt;ISA() == metacls) return cls;
    }

    // use inst if available
    if (inst) {
        Class cls = (Class)inst;
        realizeClass(cls);
        // cls may be a subclass - find the real class for metacls
        while (cls  &amp;&amp;  cls-&gt;ISA() != metacls) {
            cls = cls-&gt;superclass;
            realizeClass(cls);
        }
        if (cls) {
            assert(!cls-&gt;isMetaClass());
            assert(cls-&gt;ISA() == metacls);
            return cls;
        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们在Student类中添加未实现的类方法<code>walk</code>，在NSObject类中添加一个对象方法<code>walk</code>，运行程序不会崩溃。类方法先递归，开始找父类，最终在NSObject类中好到对象方法<code>walk</code>。<p></p>
<p><strong>TIP：对象方法存储在类中，类方法存储在元类里面</strong>，类对象以实例方法的形式存储在元类中。可以通过输出<code>class_getInstanceMethod</code>方法和<code>class_getClassMethod</code>方法的imp指针来验证，当然源码也可以解释在cls的元类中查找实例方法</p>
<pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* class_getClassMethod.  Return the class method for the specified
* class and selector.
**********************************************************************/
Method class_getClassMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;

    return class_getInstanceMethod(cls-&gt;getMeta(), sel);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以通过LLDB进行验证，动态方法解析的时候执行<code>lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)</code>方法，这里的cls就是inst的元类<br></p><pre class="line-numbers language-none"><code class="language-none">#   define ISA_MASK        0x00007ffffffffff8ULL

// -------------------------------------------------
#if SUPPORT_NONPOINTER_ISA

inline Class 
objc_object::ISA() 
{
    assert(!isTaggedPointer()); 
#if SUPPORT_INDEXED_ISA
    if (isa.nonpointer) {
        uintptr_t slot = isa.indexcls;
        return classForIndex((unsigned)slot);
    }
    return (Class)isa.bits;
#else
    return (Class)(isa.bits &amp; ISA_MASK);
#endif
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里看到初始化的时候<code>isa.bits &amp; ISA_MASK</code>，我们先后打印cls和inst的信息，也可以验证当前指针指向当前的元类。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-ff111821fd6d77fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LLDB信息"><p></p>
<h5 id="动态方法解析作用"><a href="#动态方法解析作用" class="headerlink" title="动态方法解析作用"></a>动态方法解析作用</h5><p>适用于重定向，也可以做防崩溃处理，也可以做一些错误日志收集等等。动态方法解析本质就是提供机会（任何没有实现的方法都可以重新实现）。</p>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>快速了解iOS单元测试</title>
    <url>/2020/07/23/dan-yuan-ce-shi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3e831016044de130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速了解iOS单元测试"></p>
<h4 id="XCTestCase"><a href="#XCTestCase" class="headerlink" title="XCTestCase"></a>XCTestCase</h4><p>进入xxUITests.m文件，会看到继承自XCTestCase:Xcode集成的一套单元测试框架<br></p><pre class="line-numbers language-none"><code class="language-none">XCTestCase
The primary class for defining test cases, test methods, and performance tests.

## Overview

A test case is a group of related test methods, with optional setup and teardown before and after tests are run. See&nbsp;[Defining Test Cases and Test Methods](apple-reference-documentation://tc2870870)&nbsp;for more information.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>每个测试用例在运行前都会执行<code>setup</code>方法(<code>Provides an opportunity to customize initial state before a test case begins.</code>)，并且在运行后会执行<code>teardown</code>方法(<code>Provides an opportunity to perform cleanup after a test case ends.</code>)。我们可以在此时做一些初始化、销毁回收等操作。<br><code>testExample</code>作为逻辑测试，测试逻辑是否有问题；<code>testPerformanceExample</code>作为性能测试，测试当前用例的性能，耗时等操作，先看一个逻辑测试的demo。<p></p>
<blockquote>
<p>每个测试用例都要以<code>test</code>开头，比如<code>testExampl</code><br></p><pre class="line-numbers language-none"><code class="language-none">- (void)setUp {
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
}

- (void)testExample {
    // This is an example of a functional test case.
    // Use XCTAssert and related functions to verify your tests produce the correct results.
    int a = 10;
    int b = 20;
    int c = a + b;
    XCTAssertEqual(c, 30, @"计算正确");
}

- (void)testPerformanceExample {
    // This is an example of a performance test case.
    [self measureBlock:^{
        // Put the code you want to measure the time of here.
    }];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在此测试用例demo运行时，当<code>c</code>等于30的时候直接通过，否则这里会报错！这里使用<code>XCTAssertEqual</code>断言来进行判断条件是否成立。<p></p>
</blockquote>
<h4 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h4><blockquote>
<pre class="line-numbers language-none"><code class="language-none">XCTAssertEqual：Asserts that two expressions have the same value.
XCTAssertEqualObjects：Asserts that two objects are considered equal.
XCTAssertNotEqual：Asserts that two expressions do not have the same value.
XCTAssertNotEqualObjects：Asserts that two objects are not considered equal.
XCTAssertEqualWithAccuracy：Asserts that two expressions have the same value within a certain accuracy.
XCTAssertNotEqualWithAccuracy：Asserts that two expressions do not have the same value within a certain accuracy.
XCTAssertNil：Asserts that an expression is nil.
XCTAssertNotNil：Asserts that an expression is not nil.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  <strong>检验平等和不平等（Testing for Equality and Inequality ）</strong></p>
<ul>
<li><code>XCTAssertEqual(expression1, expression2, format...)</code>：当expression1不等于expression2时报错，这个测试用于C语言的标量。</li>
<li><code>XCTAssertEqualObjects(expression1, expression2, format...)</code>：当expression1不等于expression2时报错（或者一个对象为空，另一个不为空）。</li>
<li><code>XCTAssertNotEqual(expression1, expression2, format...)</code>：当expression1等于expression2时报错，这个测试用于C语言的标量。</li>
<li><code>XCTAssertNotEqualObjects(expression1, expression2, format...)</code>：当expression1等于expression2时报错。</li>
</ul>
</blockquote>
<p>  <strong>在给定精度内测试是否相等</strong></p>
<ul>
<li><code>XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)</code>：当expression1和expression2之间的差别高于accuracy 将报错。这种测试适用于floats和doubles这些标量，两者之间的细微差异导致它们不完全相等，但是对所有的标量都有效。</li>
<li><code>XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)</code>：当expression1和expression2之间的差别低于accuracy将产生失败。这种测试适用于floats和doubles这些标量，两者之间的细微差异导致它们不完全相等，但是对所有的标量都有效。</li>
</ul>
<p><strong>测试一个条件是否为空</strong></p>
<ul>
<li><code>XCTAssertNil(expression, format...)</code>:当expression参数非nil时报错。</li>
<li><code>XCTAssertNotNil(expression, format...)</code>:当expression参数为nil时报错。</li>
</ul>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>//性能测试方法，通过测试block中方法执行的时间，比对设定的标准值和偏差觉得是否可以通过测试<br></p><pre class="line-numbers language-none"><code class="language-none"> // Measures the performance of a block of code.
- measureBlock:
 // Measures the performance of a block of code, optionally deferring the starting point for measurement.
- measureMetrics:automaticallyStartMeasuring:forBlock:
 // Starts the measurement of performance metrics within a block of code.
 - startMeasuring
 // Ends the measurement of performance metrics within a block of code.
-&nbsp;stopMeasuring
// Identifies the performance metrics measured when&nbsp;[`measure&lt;wbr style="margin-bottom: 0px;"&gt;Block:`](apple-reference-documentation://hcnJonuUfI)&nbsp;is invoked.
defaultPerformanceMetrics
 // Performance metrics that can be measured by XCTest.
XCTPerformanceMetric<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>- measureBlock</code>主要是通过block内部代码块的执行时间来测试性能，通过设置baseline（基准）和stddev（标准偏差）来判断方法是否能通过性能测试。<br><code>- measureMetrics:automaticallyStartMeasuring:forBlock</code>测量代码块的性能，可以选择推迟测量的起点。<br><code>- startMeasuring</code>在代码块中开始性能度量。<br><code>- stopMeasuring</code>结束代码块内的性能度量。<br><code>defaultPerformanceMetrics</code>标识在调用measureBlock:时度量的性能指标。<br><code>XCTPerformanceMetricXCTest</code>可以测量的性能指标。<p></p>
<h4 id="创建异步测试期望"><a href="#创建异步测试期望" class="headerlink" title="创建异步测试期望"></a>创建异步测试期望</h4><p>要创建异步测试期望，请使用下面的方便方法，或者手动创建<code>XCTestExpectation</code>及其子类的实例。<br></p><pre class="line-numbers language-none"><code class="language-none">// Creates a new expectation with an associated description.
- expectationWithDescription:
// Creates an expectation that is fulfilled if the predicate returns YES when evaluated with the given object.
- expectationForPredicate:evaluatedWithObject:handler:
// Creates an expectation that is fulfilled when a specific&nbsp;[`NSNotification`](apple-reference-documentation://hcmB87CArc)&nbsp;is received for a given object.
- expectationForNotification:object:handler:
// Creates an expectation that uses Key Value Observing to observe a value until it matches an expected value.
- keyValueObservingExpectationForObject:keyPath:expectedValue:
// Creates an expectation that uses Key Value Observing to observe a value and respond to changes in that value by calling a provided handler.
- keyValueObservingExpectationForObject:keyPath:handler:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>- expectationWithDescription</code>：创建带有关联描述的新期望，比如操作出错的原因描述。<br><code>- expectationForPredicate:evaluatedWithObject:handler</code>：创建一个期望，如果<code>predicate</code>在对给定对象进行计算时返回YES，则该期望将被满足。<br><code>- expectationForNotification:object:handler</code>：创建期望，该期望在接收到给定对象的特定NSNotification时被实现。该方法监听一个通知,如果在规定时间内正确收到通知则测试通过。<br><code>- keyValueObservingExpectationForObject:keyPath:expectedValue</code>：创建一个期望，该期望使用键值观察来观察一个值，直到它与期望的值匹配为止。<br><code>- keyValueObservingExpectationForObject:keyPath:handler</code>：创建一个期望，该期望使用键值观察来观察值，并通过<code>handler</code>来响应该值中的更改。<p></p>
<h4 id="等待的期望"><a href="#等待的期望" class="headerlink" title="等待的期望"></a>等待的期望</h4><p>可以使用下面的方法实现等待异步测试期望，或者创建XCTWaiter的实例。<br></p><pre class="line-numbers language-none"><code class="language-none">// Waits on a group of expectations for up to the specified timeout.
- waitForExpectations:timeout:
// Waits on an array of expectations and specifies whether they must be fulfilled in the given order.
- waitForExpectations:timeout:enforceOrder:
// Waits until all expectations are fulfilled or the timeout is reached.
- waitForExpectationsWithTimeout:handler:
// A block to be called when a call to waitForExpectationsWithTimeout:handler: has all of its expectations fulfilled, or times out.
XCWaitCompletionHandler
// Error codes for errors that can occur while waiting for expectations to be fulfilled.
XCTestErrorCode
// Error domain for errors that can occur while waiting for expectations to be fulfilled.
XCTestErrorDomain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>- waitForExpectations:timeout</code>：等待一组期望，直到指定的超时。<br><code>- waitForExpectations:timeout:enforceOrder</code>：等待一系列期望，并指定它们是否必须按照给定的顺序实现。<br><code>- waitForExpectationsWithTimeout:handler</code>：等待，直到所有期望都满足或达到超时，执行<code>handler</code>。设置延迟时间（秒），如果没有满足测试条件就报错。<br><code>XCWaitCompletionHandler</code>：当waitForExpectationsWithTimeout:handler:的调用完成了所有的期望或超时时的回调。<br><code>XCTestErrorCode</code>:在等待期望实现时可能发生的错误的错误代码。<br><code>XCTestErrorDomain</code>:在等待期望实现时可能发生的错误的错误域。<p></p>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Xcode调试</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程简介</title>
    <url>/2019/10/22/duo-xian-cheng-jian-jie/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-36c976bc4790807b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程简介"></p>
<blockquote>
<p>iOS系统 中，每一个应用都是一个进程。具体了解<a href="https://www.jianshu.com/p/9cb4edc0670d">Runloop底层原理：https://www.jianshu.com/p/9cb4edc0670d</a>，除了Runloop底层原理还介绍了线程间的通讯等。</p>
</blockquote>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程</li>
<li>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存。</li>
</ul>
<h4 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h4><ul>
<li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。</li>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</li>
<li>执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，但是进程不是。</li>
</ul>
<h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h4><p>多线程的原理其实就是CPU在单位时间片里快速在各个线程之间切换。一般情况下无论多核还是单核，我们的线程运行总是 “并发” 的，这时候我们所说的”并发”是一种模拟出来的状态，CPU在单位时间片里快速在各个线程之间切换，每个线程执行一小段时间，让多个线程看起来就像在同时运行。只有当cpu数量大于等于线程数量，这个时候是真正并发，可以多个线程同时执行计算。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>能适当提高程序的执行效率。</li>
<li>能适当提高资源的利用率（CPU、内存）。</li>
<li>线程上的任务执行完成后，线程会自动销毁。<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>开启线程需要占用一定的内存空间（默认情况下，每一个线程占用512KB）。</li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能。</li>
<li>线程越多，CPU在调度线程上的开销就越大。</li>
<li>程序设计更加复杂，比如线程间的通讯、多线程的数据共享。</li>
</ul>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>线程在创建后，start开始进入Runnable就绪的状态，这时会执行很多初始化的操作；接下进入running状态，CPU会调度当前线程，如果线程池中有当前线程会直接执行，在时间片的影响后CPU再次调度其他线程，直到当前线程任务执行完毕或强制退出，或者堵塞（调用sleep、等待同步锁或者从可调度线程池中移除）结束再次回到Runnable状态。</p>
<h4 id="多线程相关补充"><a href="#多线程相关补充" class="headerlink" title="多线程相关补充"></a>多线程相关补充</h4><h5 id="多线程技术方案"><a href="#多线程技术方案" class="headerlink" title="多线程技术方案"></a>多线程技术方案</h5><p><img src="https://upload-images.jianshu.io/upload_images/5741330-541b220237e3920d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>线程池可以使线程得到复用，所谓线程复用就是线程在执行完一个任务后并不被销毁，该线程可以继续执行其他的任务。在线程池大小小于核心线程池大小的时候，如果小于则直接创建线程执行任务。如果超出核心线程池大小则依赖队列，此时线程池会判断当前队列是不是已经满了，如果没有满，则提交任务到工作队列中，等待线程池调度执行任务。如果满了，并且当前工作队列所依赖的线程没有执行工作，那么则可以利用当前线程执行任务，如果此时线程都在工作，接下来会交给饱和策略。饱和策略一般默认都是中止策略，调用者可以捕获到该异常；还有抛弃策略，会悄悄抛弃该任务，不过一般会抛弃最旧的任务或者优先级比较低的任务等；还有调用者运行策略，实现了一种机制，这个机制不会抛弃任务也不会抛出异常，而是将任务回退到调用者，来达到降低新任务的流量。还有等待策略，也就是需要排队等候执行。</p>
<h5 id="线程安全—锁"><a href="#线程安全—锁" class="headerlink" title="线程安全—锁"></a>线程安全—锁</h5><p>在开发高性能程序的时候几乎都会用到多线程，但是用到多线程也会碰到一些安全问题。比如多个线程同时对一块内存发生读和写的操作，或者程序执行的顺序会被打乱,可能造成提前释放一个变量,造成计算结果错误等，所以我们经常会用到锁。我们用锁来保证代码操作的原子性，让多线程对同一个数据或者资源进行访问同步。</p>
<h6 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h6><p>这里简单说下锁，根据锁的状态、锁的特性和锁的设计等分为：</p>
<ul>
<li>公平锁/非公平锁</li>
<li>可重入锁—又名递归锁，一定程度上避免死锁。</li>
<li>独享锁/共享锁</li>
<li>互斥锁/读写锁</li>
<li>乐观锁/悲观锁</li>
<li>分段锁</li>
<li>偏向锁/轻量级锁/重量级锁</li>
<li>自旋锁</li>
</ul>
<h5 id="atomic与nonatomic"><a href="#atomic与nonatomic" class="headerlink" title="atomic与nonatomic"></a>atomic与nonatomic</h5><p>说到原子性就会想到属性关键字中atomic和nonatomic。设置atomic之后，默认生成的getter和setter方法执行是原子的，它只保证了自身的读/写操作，却不能说是线程安全。</p>
<ul>
<li>nonatomic 非原子属性</li>
<li>atomic 原子属性(线程安全)，针对多线程设计的，默认值</li>
</ul>
<blockquote>
<ul>
<li>保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值)</li>
<li>atomic 本身就有一把锁(自旋锁)</li>
<li>单写多读：单个线程写入，多个线程可以读取</li>
</ul>
</blockquote>
<p>atomic：线程安全，需要消耗大量的资源<br>nonatomic：非线程安全，适合内存小的移动设备<br>我们可以用读写锁来解决，例如：<br></p><pre class="line-numbers language-none"><code class="language-none">// 在 OC 中，如果同时重写 了 setter &amp; getter 方法，系统不再提供 _成员变量，需要使用合成指令
// @synthesize name 取个别名:_name
@synthesize name = _name;
- (NSString *)name {
    return _name;
}
- (void)setName:(NSString *)name {
    /**
     * 增加一把锁，就能够保证一条线程在同一时间写入!
     */
    @synchronized (self) {
        _name = name;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<ul>
<li><p>互斥锁小结</p>
<ul>
<li>保证锁内的代码，同一时间，只有一条线程能够执行！</li>
<li>互斥锁的锁定范围，应该尽量小，锁定范围越大，效率越差！</li>
</ul>
</li>
<li><p>互斥锁参数</p>
<ul>
<li>能够加锁的任意 NSObject 对象</li>
<li>注意：锁对象一定要保证所有的线程都能够访问</li>
<li>如果代码中只有一个地方需要加锁，大多都使用 self，这样可以避免单独再创建一个锁对象</li>
</ul>
</li>
</ul>
<p>关于线程安全问题，多线程安全比多线程性能更重要，建议用<code>@synchronized</code>，<code>NSLock</code>，可保证可读性和安全性。</p>
<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><pre class="line-numbers language-none"><code class="language-none">/**
 线程创建的方式
 */
- (void)creatThreadMethod{
    
    NSLog(@"%@", [NSThread currentThread]);
    
    //A: 1:开辟线程
    NSThread *t = [[NSThread alloc] initWithTarget:self.p selector:@selector(study:) object:@3];
    // 2. 启动线程
    [t start];
    t.name = @"学习线程";
    
    // detach 分离，不需要启动，直接分离出新的线程执行
    [NSThread detachNewThreadSelector:@selector(study:) toTarget:self.p withObject:@5];
    
    //NSObject (NSThreadPerformAdditions)的分类
    //C : `隐式`的多线程调用方法，没有thread，也没有 start
    self.p = [[Person alloc] init];
    [self.p performSelectorInBackground:@selector(study:) withObject:@10];
    

    // GCD
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        [self study;];
    });
    
    // NSOperation
    [[[NSOperationQueue alloc] init] addOperationWithBlock:^{
        [self threadTest];
    }];
    NSLog(@"%@", [NSThread currentThread]);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Person.m文件实现</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><pre class="line-numbers language-none"><code class="language-none">- (void)study:(id)time{
    for (int i = 0; i&lt;[time intValue]; i++) {
        NSLog(@"%@ 开始学习了 %d分钟",[NSThread currentThread],i);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><p>或者<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
//0: pthread
        
    /**
     pthread_create 创建线程
     参数：
     1. pthread_t：要创建线程的结构体指针，通常开发的时候，如果遇到 C 语言的结构体，类型后缀 `_t / Ref` 结尾
     同时不需要 `*`
     2. 线程的属性，nil(空对象 - OC 使用的) / NULL(空地址，0 C 使用的)
     3. 线程要执行的`函数地址`
     void *: 返回类型，表示指向任意对象的指针，和 OC 中的 id 类似
     (*): 函数名
     (void *): 参数类型，void *
     4. 传递给第三个参数(函数)的`参数`
     
     返回值：C 语言框架中非常常见
     int
     0          创建线程成功！成功只有一种可能
     非 0       创建线程失败的错误码，失败有多种可能！
     */
    // pthread
    pthread_t threadId = NULL;
    //c字符串
    char *cString = "HelloCode";
    // OC prethread -- 跨平台
    // 锁
    int result = pthread_create(&amp;threadId, NULL, pthreadTest, cString);
    if (result == 0) {
        NSLog(@"成功");
    } else {
        NSLog(@"失败");
    }
    // GCD
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        [self threadTest];
    });
    
    // NSOperation
    [[[NSOperationQueue alloc] init] addOperationWithBlock:^{
        [self threadTest];
    }];
}

- (void)threadTest{
    NSLog(@"begin");
    NSInteger count = 1000 * 100;
    for (NSInteger i = 0; i &lt; count; i++) {
        // 栈区
        NSInteger num = i;
        // 常量区
        NSString *name = @"zhang";
        // 堆区
        NSString *myName = [NSString stringWithFormat:@"%@ - %zd", name, num];
        NSLog(@"%@", myName);
    }
    NSLog(@"over");
}

void *pthreadTest(void *para){
    // 接 C 语言的字符串
    //    NSLog(@"===&gt; %@ %s", [NSThread currentThread], para);
    // __bridge 将 C 语言的类型桥接到 OC 的类型
    NSString *name = (__bridge NSString *)(para);
    
    NSLog(@"===&gt;%@ %@", [NSThread currentThread], name);
    
    return NULL;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<blockquote>
<p><strong>TIP：C与OC的桥接</strong></p>
<ul>
<li>__bridge只做类型转换，但是不修改对象（内存）管理权；</li>
<li>__bridge_retained（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，&gt; 后- 续需要使用CFRelease或者相关方法来释放对象；</li>
<li>__bridge_transfer（也可以使用CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给ARC。</li>
</ul>
</blockquote>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义NSOperation子类-图片下载器</title>
    <url>/2020/01/07/zi-ding-yi-nsoperation/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-a8bb9a75deb0f182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义NSOperation子类-图片下载器"></p>
<blockquote>
<p>研究过NSOperation后，想通过实战更好的理解NSOperation，适用于对下载图片不频繁的项目，免得为了一个小需求而导入比较重的框架。<a href="https://github.com/JBWangWork/VWebImage">Demo(直通车)</a>主要利用自定义NSOperation子类，同时借鉴了<code>AFNetworking、SDWebImage、YYKit</code>的部分思想来实现具有缓存支持的异步图像下载器。</p>
</blockquote>
<h4 id="架构思想"><a href="#架构思想" class="headerlink" title="架构思想"></a>架构思想</h4><p>整个架构共分为三层：Manager（单例，主要来管理总体的控制）、Operation（进行队列的控制）和UIImageView（对外）层。通过UIImageView的分类来通知Manager，Manager中注册了清理操作通知，Manager接收到信号后再把信号下发到对应的Operation中，Operation进行队列的操作。</p>
<p>UIImageView的分类主要对外提供接口，内部通过URL进行判断当前操作是否需要下载，如果需要下载则通知Manager来进行下载，下载完成后设置image。UIImageView分类的部分代码：<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)v_setImageWithUrlString:(NSString *)urlString title:(NSString *)title {
    if (!urlString) {
        VLog(@"下载地址为空");
        return;
    }
    
    if ([self.v_urlString isEqualToString:urlString]) {
        VLog(@"%@ 两次下载地址一样的 没必要重复下载",title);
        return;
    }
    
    if (self.v_urlString &amp;&amp; self.v_urlString.length &gt; 0 &amp;&amp; ![self.v_urlString isEqualToString:urlString]) {
        VLog(@"取消之前的下载操作:%@---%@ \n%@---%@",self.v_title,title,self.v_urlString,urlString);
        [[VWebImageManager sharedManager] cancelDownloadImageWithUrlString:self.v_urlString];
    }
    //记录新操作开始下载
    self.v_urlString = urlString;
    self.v_title = title;
    // 复用
    self.image = nil;
    
    [[VWebImageManager sharedManager] downloadImageWithUrlString:urlString completeHandle:^(UIImage *downloadImage,NSString *urlString) {
        //下载完成 要置空
        if ([urlString isEqualToString:self.v_urlString]) {
            self.v_urlString = @"";
            self.v_title = @"";
            self.image = downloadImage;
        }
    } title:title];
}

- (void)v_setImageWithUrlString:(NSString *)urlString {
    [self v_setImageWithUrlString:urlString title:@""];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>Manager接收到需要下载（或者取消下载）的信号后，首先从内存获取图片，有则利用block直接返回，否则继续从沙盒获取图片（内存的读取速度比沙盒快，所以先读内存），找到了则返回并把图片存入缓存。如果还是没有找到则进行判断是否需要下载，如果当前URL已经在下载中，则不需要再次进行下载，否则通知Operation来进行创建下载操作。Manager部分代码：<br><pre class="line-numbers language-none"><code class="language-none">- (void)downloadImageWithUrlString:(NSString *)urlString completeHandle:(VCompleteHandle)completeHandle title:(NSString *)title {
    //内存获取图片
    UIImage *cacheImage = self.imageCacheDict[urlString];
    if (cacheImage) {
        VLog(@"从内存缓存获取数据 %@",title);
        completeHandle(cacheImage,urlString);
        return;
    }
    //沙盒获取图片
    NSString *cachePath = [urlString getDowloadImagePath];
    cacheImage = [UIImage imageWithContentsOfFile:cachePath];
    if (cacheImage) {
        VLog(@"从沙盒缓存获取数据 %@",title);
        //沙盒图片 存入缓存
        [self.imageCacheDict setObject:cacheImage forKey:urlString];
        completeHandle(cacheImage,urlString);
        return ;
    }
    //对当前下载图片判断,是否需要创建操作
    if (self.operationDict[urlString]) {
        VLog(@"正在下载的回调Block %@的%@",title,completeHandle);
        NSMutableArray *mArray = self.handleDict[urlString];
        if (mArray == nil) {
            mArray = [NSMutableArray arrayWithCapacity:1];
        }
        [mArray addObject:completeHandle];
        [self.handleDict setObject:mArray forKey:urlString];
        return;
    }
    // 创建操作 下载 --- 自定义
    VWebImageDownloadOperation *downOp = [[VWebImageDownloadOperation alloc] initWithDownloadImageUrl:urlString completeHandle:^(NSData * _Nonnull imageData, NSString * _Nonnull v_urlString) {
        UIImage *downloadImage = [UIImage imageWithData:imageData];
        if (downloadImage) {
            [self.imageCacheDict setObject:downloadImage forKey:urlString];
            [self.operationDict removeObjectForKey:urlString];
            [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                completeHandle(downloadImage, v_urlString);
                // 去取回调
                if (self.handleDict[v_urlString]) {
                    NSMutableArray *mArray = self.handleDict[v_urlString];
                    for (VCompleteHandle completeHandle in mArray) {
                        completeHandle(downloadImage, v_urlString);
                    }
                    [self.handleDict removeObjectForKey:urlString];
                }
            }];
        }
    } title:title];
    // 操作加入队列
    [self.queue addOperation:downOp];
    // 操作缓存
    [self.operationDict setObject:downOp forKey:urlString];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>自定义NSOperation子类需要重写Start等函数，这里参考了SDWebImage的思想进行手动KVO观察当前的状态，防止自动KVO的影响。比如这里可以根据相应的url进行取消当前任务，而此时GCD就无法满足需求。自定义NSOperation子类部分代码：<br><pre class="line-numbers language-none"><code class="language-none">- (instancetype)initWithDownloadImageUrl:(NSString *)urlString completeHandle:(VDownCompleteHandle)completeHandle title:(NSString *)title{
    if (self = [super init]) {
        _urlString = urlString;
        _executing = NO;
        _finished  = NO;
        _cancelled = NO;
        _lock      = [NSRecursiveLock new];
        _completeHandle = completeHandle;
        _title = title;
    }
    return self;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
    VCustomCollectionViewCell *cell  = [collectionView dequeueReusableCellWithReuseIdentifier:reuseID forIndexPath:indexPath];
    VModel *model        = self.dataArray[indexPath.row];
    cell.titleLabel.text  = model.title;
    cell.moneyLabel.text  = model.money;
    [cell.imageView v_setImageWithUrlString:model.imageUrl];
    // debug
    // [cell.imageView v_setImageWithUrlString:model.imageUrl title:model.title];
    return cell;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Demo地址：<a href="https://github.com/JBWangWork/VWebImage">https://github.com/JBWangWork/VWebImage</a></p>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>NSOperation</tag>
      </tags>
  </entry>
  <entry>
    <title>本地进行证书签名</title>
    <url>/2019/01/17/ben-di-qian-ming/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-fb33597ad95d93e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地进行证书签名"></p>
<blockquote>
<p>之前说过<a href="https://www.jianshu.com/p/ad3d1dea63af">生成公私钥.pem文件</a>，实际上，我们在工作中一般不会用到.pem文件，我们完全可以在钥匙串中证书助理直接从证书颁发机构中申请证书，当然本地也可以。</p>
</blockquote>
<ul>
<li>终端生成证书<br>首先生成.csr请求证书文件，之后用这个.csr文件去证书颁发机构请求证书。<pre class="line-numbers language-none"><code class="language-none">// 通过private.pem，new一个rsacert.csr文件
$ openssl req -new -key private.pem -out rsacert.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
// 输入一些信息，地址、公司和邮箱等
Country Name (2 letter code) []:cn
State or Province Name (full name) []:shanghai
Locality Name (eg, city) []:shanghai
Organization Name (eg, company) []:personal
Organizational Unit Name (eg, section) []:personal
Common Name (eg, fully qualified host name) []:personal.com
Email Address []:76521244@qq.com

Please enter the following 'extra' attributes
to be sent with your certificate request
// 可以直接回车，不设置密码
A challenge password []:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这样，终端就生成好了一个.csr文件了，接下来继续用终端申请证书</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// x509标准格式，-req签名，-days 3650 时间，也就是10年，用刚刚生成的csr文件和private.pem私钥进行签名，输出rsacert.crt证书
$ openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt
Signature ok
subject=/C=cn/ST=shanghai/L=shanghai/O=personal/OU=personal/CN=personal.com/emailAddress=76521244@qq.com
Getting Private key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>证书生成好后，显示证书的信息，下面是生成好的两个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7da3590dde1c108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书文件"></p>
<p>这个证书大概一年5000大洋，刚刚的一个操作5W就出去了，哈哈哈。。。那这个证书可以用来干嘛呢</p>
<ul>
<li>用途<br>比如HTTPS协议，这个协议需要认证这个证书，我们把证书放在服务器，别人去接受。<br>当我们查看这个证书时，会发现这个证书还是Base64编码，所以开发的时候还是不能直接用，需要将其内容提取出来<pre class="line-numbers language-none"><code class="language-none">$ openssl x509 -outform der -in rsacert.crt -out rsacert.der<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
通过命令，生成一个rsacert.der文件，这个文件主要包含了公钥和一些信息，再通过这个.der文件生成可以直接用的P12文件，也就是对应这个公钥的私钥。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$ openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt
Enter Export Password:
Verifying - Enter Export Password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>用刚刚生成crt的private.pem和.crt文件提取出P12文件，提取过程中需要设置密码，输入两次相同的密码回车后，一个对应的P12文件已经生成了。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-a3c20781e11c6bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书文件"><br>有了它俩就可以进行加密和解密了，我们iOS开发就是用的这两个文件。当然这两个文件不需要都拿到，只用.der就OK，这里只是为了演示。</p>
]]></content>
      <categories>
        <category>签名</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程原理--了解GCD</title>
    <url>/2019/10/17/gcd-jian-jie/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7fde16d065552b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程原理--了解GCD"></p>
<h4 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h4><p>在iOS 4版本之后引用GCD。GCD全称是 Grand Central Dispatch，纯 C 语言，提供了非常多强大的函数。GCD是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），iOS开发人员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码，在多线程中GCD使用特别简单，这也是GCD 的优势。</p>
<p>GCD的任务使用没有参数也没有返回值的<code>block</code>封装，执行任务的函数：异步 <code>dispatch_async</code>（具备开启新线程的能力来执行<code>block</code>的任务，不用等待当前语句执行完毕，就可以执行下一条语句）；同步 <code>dispatch_sync</code>（不会开启线程，必须等待当前语句执行完毕，才会执行下一条语句）。先简单来个例子：把任务添加到队列，并指定函数</p>
<pre class="line-numbers language-none"><code class="language-none">- (void)syncTest{
    dispatch_block_t block = ^{
        NSLog(@"hello GCD");
    };
    //串行队列
    dispatch_queue_t queue = dispatch_queue_create("com.gcdTest", NULL);
    // 同步执行任务
//    dispatch_sync(queue, block);
//    dispatch_sync(queue, ^{
//        // 同步执行任务代码
//        NSLog(@"hello GCD");
//    });

    // 异步执行任务
//    dispatch_async(queue, block);
    dispatch_async(queue, ^{
    // 异步执行任务代码
        NSLog(@"hello GCD");
    });
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，推荐使用<code>AppId</code>这种逆序域名，可用于DEBUG；第二个参数用来识别是串行队列还是并发队列。用<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列，还有两种特殊队列：全局并发队列、主队列。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><ul>
<li>串行队列（Serial Dispatch Queue）：<br>每次只有一个任务被执行。让任务一个接着一个地执行（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。<pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = 
dispatch_queue_create("com.gcdTest", DISPATCH_QUEUE_SERIAL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>并发队列（Concurrent Dispatch Queue）：<br>可以让多个任务并发（同时）执行（可以开启多个线程，并且同时执行任务。）。只有在异步<code>dispatch_async</code>函数下才有效。<pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = 
dispatch_queue_create("com.gcdTest", DISPATCH_QUEUE_CONCURRENT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>全局并发队列（Global Dispatch Queue）：<br>GCD默认提供的全局并发队列，可以使用dispatch_get_global_queue来获取，需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可：<pre class="line-numbers language-none"><code class="language-none">/**
* arg1:队列优先级
* arg2:保留字段备用，一般为0
*/
dispatch_queue_t queue = 
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>主队列（Main Dispatch Queue）：<br>GCD提供的一种特殊的串行队列，所有放在主队列中的任务，都会放到主线程中执行。我们可以使用dispatch_get_main_queue()获得主队列：<pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = dispatch_get_main_queue();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
其中全局并发队列可以作为普通并发队列使用，这样我们在创建任务的时候，可以选择6种不同的任务执行方式，同步执行 + 并发队列；异步执行 + 并发队列；同步执行 + 串行队列；异步执行 + 串行队列；同步执行 + 主队列；异步执行 + 主队列；6种组合方式的区别：<br>区别|并发队列|串行队列|主队列<br>|:—-:|:—-:|:—-:|:—-:|<br>同步(sync-) | 没有开启新的线程 | 串行执行任务 | 没有开启新线程，串行执行任务<br>| 异步(async) | 开启新线程，并发执行任务 | 有开启新线程()，串行执行任务 | 没有开启新线程，串行执行任务</li>
</ul>
<h4 id="GCD的基本使用"><a href="#GCD的基本使用" class="headerlink" title="GCD的基本使用"></a>GCD的基本使用</h4><p><strong>并发队列异步函数内部再次执行异步函数：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = dispatch_queue_create("com.gcdTest", DISPATCH_QUEUE_CONCURRENT);
    NSLog(@"1");
    // 耗时
    dispatch_async(queue, ^{
        NSLog(@"2");
        dispatch_async(queue, ^{
            NSLog(@"3");
        });
        NSLog(@"4");
    });
    NSLog(@"5");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>执行结果为1-5-2-4-3。首先打印1，之后进入耗时操作，打印5，进入第一个异步函数打印2，再次进入耗时操作，打印4，再打印异步函数内的3。<p></p>
<p><strong>串行队列异步函数内部再次执行同步函数：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = dispatch_queue_create("com.gcdTest", DISPATCH_QUEUE_SERIAL);
    NSLog(@"1");
    // 耗时
    dispatch_async(queue, ^{
        NSLog(@"2");
        dispatch_sync(queue, ^{
            NSLog(@"3");
        });
        NSLog(@"4");
    });
    NSLog(@"5");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>以下串行队列：1-5-2 之后崩溃。首先打印1，之后进入耗时操作，打印5，进入第一个异步函数打印2，此时进入串行队列；正常逻辑是需要先执行block，之后打印4，block再执行3，因为串行队列是FIFO的，当任务执行到block的时候，block等待3执行完毕后，继续打印4；而3则是需要等待4执行完毕后才执行；而4需要等待block执行完毕后才执行，这样就形成了死锁，所以打印2后奔溃。<p></p>
<p><strong>以下代码会产生什么问题？</strong><br></p><pre class="line-numbers language-none"><code class="language-none">int a = 0;
while (a&lt;10) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
});
NSLog(@"主线程%d",a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>产生的问题：</strong>首先<code>a</code>会报错，我们需要添加<code>__block</code>修饰，以<code>a</code>的指针和值的struct形式从栈区copy到堆区的新的<code>A</code>；其次在while循环内是异步并发，需要开辟新线程，是个耗时操作，可能在上一个线程没有执行完毕的时候又创建一个新的线程继续执行<code>a++</code>操作，结果就是可能多条线程内的<code>a</code>的值都是相同的，这样导致最后<code>a</code>的结果可能大于等于10，即使已经打印了<code>a</code>的值后可能还会有很多线程在执行，导致最后<code>a</code>的真正的值会很大。<p></p>
<p><strong>解决问题：</strong>我们知道最后会创建出大于等于10条线程，我们可以利用锁的方式来保证最后只创建10条线程，以NSLock为例：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><pre class="line-numbers language-none"><code class="language-none">int a = 0;
NSLock *lock = [NSLock new];
while (a&lt;10) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
        [lock unlock];
});
[lock lock];
NSLog(@"主线程%d",a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><p> <strong>开发中我们经常会碰到一些有依赖关系的任务，比如在A请求后再进行B、C请求这样的操作。解决办法很多，比如直接先同步执行A，再异步执行B、C，或者可以把A、B和C放在一个task任务中再进行相同的执行顺序，这样虽然解决了问题但是会堵塞线程，影响其他操作，我们也可以用栅栏函数来解决。</strong></p>
<h4 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h4><blockquote>
<p>TIP :<br>栅栏函数可以保证顺序执行，也可以保证线程安全，但一定要是自定义并发队列。正因为栅栏函数只能控制同一自定义并发队列，所以不利于封装。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void
dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);

void
dispatch_barrier_sync(dispatch_queue_t queue,
		DISPATCH_NOESCAPE dispatch_block_t block);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的区别就是是否阻塞当前线程，很明显<code>dispatch_barrier_async</code>不会阻塞当前线程：<br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t concurrentQueue = dispatch_queue_create("concurrentQueue", DISPATCH_QUEUE_CONCURRENT);
    /* 1.异步函数 */
    dispatch_async(concurrentQueue, ^{
        for (NSUInteger i = 0; i &lt; 5; i++) {
            NSLog(@"加载1-%zd-%@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_async(concurrentQueue, ^{
        for (NSUInteger i = 0; i &lt; 5; i++) {
            NSLog(@"加载2-%zd-%@",i,[NSThread currentThread]);
        }
    });
    
    /* 2. 栅栏函数 */
    dispatch_barrier_async(concurrentQueue, ^{
        NSLog(@"---------------------%@------------------------",[NSThread currentThread]);
    });
    NSLog(@"**********加载完毕!!!**********");
    /* 3. 异步函数 */
    dispatch_async(concurrentQueue, ^{
        for (NSUInteger i = 0; i &lt; 5; i++) {
            NSLog(@"处理结果3-%zd-%@",i,[NSThread currentThread]);
        }
    });
    NSLog(@"**********继续!!!**********");
    
    dispatch_async(concurrentQueue, ^{
        for (NSUInteger i = 0; i &lt; 5; i++) {
            NSLog(@"处理结果4-%zd-%@",i,[NSThread currentThread]);
        }
    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>用栅栏函数<code>dispatch_barrier_async</code>打印效果：<br><pre class="line-numbers language-none"><code class="language-none">**********加载完毕!!!**********
加载2-0-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-0-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-1-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-1-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
**********继续!!!**********
加载2-2-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-2-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-3-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-3-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-4-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-4-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
---------------------&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}------------------------
处理结果3-0-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-0-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-1-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-1-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-2-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-2-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-3-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-3-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-4-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-4-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>同样代码，如果用栅栏函数<code>dispatch_barrier_sync</code>，打印结果为：<p></p>
<pre class="line-numbers language-none"><code class="language-none">加载2-0-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-0-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-1-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-1-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-2-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-2-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-3-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-3-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
加载2-4-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
加载1-4-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
---------------------&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}------------------------
**********加载完毕!!!**********
**********继续!!!**********
处理结果3-0-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-0-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-1-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-1-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-2-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-2-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-3-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-3-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}
处理结果3-4-&lt;NSThread: 0x6000002797c0&gt;{number = 5, name = (null)}
处理结果4-4-&lt;NSThread: 0x600000246100&gt;{number = 4, name = (null)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h4><p>虽然栅栏函数很好用，但是还不是很完美，可以利用调度组来解决栅栏函数的不足。<br>TIP：<code>dispatch_group_create</code>：创建调度组，<code>dispatch_group_async</code>：异步提交任务到调度组中，<code>dispatch_group_notify</code>：监听调度组任务是否执行完毕。<br></p><pre class="line-numbers language-none"><code class="language-none">//创建调度组
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

// SIGNAL
dispatch_group_async(group, queue, ^{
    NSLog(@"第一个走完了");
});

dispatch_group_async(group, queue, ^{
    NSLog(@"第二个走完了");
});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@"所有任务完成,可以更新UI");
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当我们不使用<code>dispatch_group_async</code>来提交任务的时候，我们也可以使用<code>dispatch_group_enter和</code>dispatch_group_leave`来实现：<p></p>
<pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group);
dispatch_async(queue, ^{
    NSLog(@"第一个走完了");
    dispatch_group_leave(group);
});

dispatch_group_enter(group);
dispatch_async(queue, ^{
    NSLog(@"第二个走完了");
    dispatch_group_leave(group);
});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@"所有任务完成,可以更新UI");
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>TIP：<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>必须配合使用。</p>
</blockquote>
<p>两种写法结果都是先执行前面两个任务，最后执行notify内部的block任务。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>GCD中的信号量是指<code>Dispatch Semaphore</code>，是持有计数的信号。除了调度组外，还可以使用信号量来解决问题。</p>
<p>GCD信号量机制主要提供了以下三个函数：<br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_semaphore_create(long value); // 创建信号量
dispatch_semaphore_signal(dispatch_semaphore_t deem); // 发送信号量
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); // 等待信号量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><code>dispatch_semaphore_create</code>：创建一个<code>dispatch_semaphore_t</code>类型的信号量，并设定信号量的大小。<br><code>dispatch_semaphore_wait</code>：等待信号量，对信号量的值进行减1操作，如果信号量值为0，那么该函数就会一直等待，相当于阻塞当前线程，直到该函数等待的信号量的值大于等于1。<br><code>dispatch_semaphore_signal</code>：对信号量的值进行加1操作。<p></p>
<p>一般等待信号量和发送信号量的函数是成对出现的。在并发执行任务时候，在当前任务执行之前，用<code>dispatch_semaphore_wait</code>函数对信号量的值减1操作（信号量为0时进行等待），执行当前任务后再通过<code>dispatch_semaphore_signal</code>函数对信号量的值加1操作来发送信号量，通知执行下一个任务。这样GCD就可以使用信号量来控制并发数，也可以保持线程同步，保证线程安全，当锁来使用。</p>
<p>举个例子，以下代码由于<code>dispatch_semaphore_create</code>创建2个信号量，所以先执行任务1和任务2，等任务1和任务2完成后再执行任务3。<br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);

//任务1
dispatch_async(queue, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@"执行任务1");
    sleep(1);
    NSLog(@"任务1完成");
    dispatch_semaphore_signal(semaphore);
});

//任务2
dispatch_async(queue, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@"执行任务2");
    sleep(1);
    NSLog(@"任务2完成");
    dispatch_semaphore_signal(semaphore);
});

//任务3
dispatch_async(queue, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@"执行任务3");
    sleep(1);
    NSLog(@"任务3完成");
    dispatch_semaphore_signal(semaphore);
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>GCD中的延迟执行<code>dispatch_after</code>是延时将任务追加到对应队列中，执行block块中的任务，具体延迟多少时间并不一定，对于一些模糊的延迟任务来说还是很有效的，比如在主线程中基本不会用<code>sleep</code>来延迟方法的调用，所以用<code>dispatch_after</code>是最合适的。<br></p><pre class="line-numbers language-none"><code class="language-none">//NSEC_PER_SEC : 1000000000ull 纳秒每秒 0.0000001
    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC));
    dispatch_queue_t queue = dispatch_queue_create("com.lg.cn", DISPATCH_QUEUE_CONCURRENT);
    dispatch_after(time, queue, ^{
        NSLog(@"延迟执行");
    });
    NSLog(@"继续执行");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="调度资源"><a href="#调度资源" class="headerlink" title="调度资源"></a>调度资源</h4><p>GCD中的调度资源<code>dispatch_source</code>是一种用于处理事件的数据类型，这些被处理的事件为操作系统中的底层级别。常用于处理跟系统有关的事件，协调处理指定的低级别的系统事件，在系统处理请求时应用程序可以继续处理自己的事情。 </p>
<p><strong>优势：</strong></p>
<ul>
<li>其CPU负荷非常小，尽量不占用资源。</li>
<li>联结的优势<br>当你配置一个dispatch source时，你指定要监测的事件、dispatch queue、以及处理事件的代码(block或函数)。当事件发生时（在任一线程上调用它的函数<code>dispatch_source_merge_data</code>），dispatch source会提交你的block或函数到指定的queue去执行和手工提交到queue的任务不同，dispatch source为应用提供连续的事件源。除非你显式地取消，dispatch source会一直保留与dispatch queue的关联。</li>
</ul>
<p><strong>使用：</strong></p>
<ul>
<li>创建源<code>dispatch_source_create</code>：<pre class="line-numbers language-none"><code class="language-none">/**
*  arg1：用于标识Dispatch Source要监听的事件类型，共有11个类型。
*  arg2：取决于要监听的事件类型，如果是监听Mach端口相关的事件，那么该参数就是mach_port_t类型的Mach端口号，如果是监听事件变量数据类型的事件那么该参数就不需要，设置为0就可以了。
* arg3：取决于要监听的事件类型，如果是监听文件属性更改的事件，那么该参数就标识文件的哪个属性，比如DISPATCH_VNODE_RENAME。Apple的API介绍说，使用DISPATCH_TIMER_STRICT，会引起电量消耗加剧，毕竟要求精确时间，所以一般传0即可，视业务情况而定。
* arg4：设置回调函数所在的队列，可以传Null，默认为全局队列。
*/
dispatch_source_t
dispatch_source_create(dispatch_source_type_t type,
	                   uintptr_t handle,
	                   unsigned long mask,
	                   dispatch_queue_t _Nullable queue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>设置源事件回调<code>dispatch_source_set_event_handler</code>(block形式)或者<code>dispatch_source_set_event_handler_f</code>(函数形式)<br>以<code>dispatch_source_set_event_handler</code>为例:<pre class="line-numbers language-none"><code class="language-none">void
dispatch_source_set_event_handler(dispatch_source_t source,
	dispatch_block_t _Nullable handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>源事件设置数据<code>dispatch_source_merge_data</code>：<pre class="line-numbers language-none"><code class="language-none">void
dispatch_source_merge_data(dispatch_source_t source, unsigned long value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>获取源事件数据<code>dispatch_source_get_data</code>：<pre class="line-numbers language-none"><code class="language-none">unsigned long
dispatch_source_get_data(dispatch_source_t source);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>继续<code>dispatch_resume</code>：<pre class="line-numbers language-none"><code class="language-none">void
dispatch_resume(dispatch_object_t object);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>挂起<code>dispatch_suspend</code>：<pre class="line-numbers language-none"><code class="language-none">void
dispatch_suspend(dispatch_object_t object);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<p>模拟下载进度部分业务代码：<br></p><pre class="line-numbers language-none"><code class="language-none">self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
// 封装我们需要回调的触发函数 -- 响应
dispatch_source_set_event_handler(self.source, ^{
    
    NSUInteger value = dispatch_source_get_data(self.source); // 取回来值 1 响应式
    self.totalComplete += value;
    NSLog(@"进度：%.2f", self.totalComplete/100.0);
    self.progressView.progress = self.totalComplete/100.0;
});
dispatch_resume(self.source);
self.isRunning     = YES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>触发函数：<br><pre class="line-numbers language-none"><code class="language-none">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{

    NSLog(@"点击开始加载");
    
    for (NSUInteger index = 0; index &lt; 100; index++) {
        dispatch_async(self.queue, ^{
            if (!self.isRunning) {
                NSLog(@"暂停下载");
                return ;
            }
            sleep(2);

            dispatch_source_merge_data(self.source, 1); // source 值响应
        });
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>具体代码：<a href="https://github.com/JBWangWork/DispatchSourceTest">Github直通车—&gt;https://github.com/JBWangWork/DispatchSourceTest</a><p></p>
<p>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程原理--GCD源码分析</title>
    <url>/2019/11/03/gcd-yuan-ma-fen-xi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0205b4b0f9893149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程原理--GCD源码分析"></p>
<p>阅读源码是枯燥的，可能暂时对我们的工作没什么帮助，现在但是作为一个有一定开发经验的开发人员而言，这一步是必须要走的；可能是受到了身边同事、同行的影响，看别人在读源码也跟着读源码，或者是开发中遇到了瓶颈，亦或者是开发不再局限于业务的开发，需要架构设计、设计模式以及数据结构和算法等需要阅读源码等等，一般开始的时候真的很难读懂，看的头大，但是当我们用尽办法研究通后，那个时候真的很爽。我们不再只是知道这样写，我们可以知其然知其所以然，知道有些函数是做什么的，知道其底层原理是怎样的，比如同样实现一个功能可以用很多种方法，我们知道这些方法底层原理后可以知道这些方法的本质区别，我们可以通过阅读源码学习到一些更好的设计思想、有更好的问题解决方案等等，也可以锻炼我们的耐心和毅力，阅读源码对我们来说真的受益无穷。</p>
<blockquote>
<p>如果还不是很了解GCD，可以先简单了解一下GCD：<a href="https://www.jianshu.com/p/acc6e7bd6f10">多线程原理—了解GCD</a>，接下来开始分析当前最新版本的源码：<a href="https://opensource.apple.com/tarballs/libdispatch/libdispatch-1008.200.78.tar.gz">libdispatch-1008.200.78.tar.gz</a>，建议去获取最新版本GCD源码：<a href="https://opensource.apple.com/tarballs/">opensource源</a>或者<a href="https://github.com/apple">github源</a>。</p>
</blockquote>
<h4 id="创建队列dispatch-queue-create"><a href="#创建队列dispatch-queue-create" class="headerlink" title="创建队列dispatch_queue_create"></a>创建队列dispatch_queue_create</h4><p>我们可以探索下串行和并发队列的区别。<br>首先跟着创建队列函数<code>dispatch_queue_create</code>进入源码，除了我们赋值的label和attr，系统还将tq赋值<code>DISPATCH_TARGET_QUEUE_DEFAULT</code>，legacy 赋值为<code>true</code>传给<code>dispatch_queue_create_with_target</code>，其内部首先通过<code>_dispatch_queue_attr_to_info</code>和我们传进来的attr来初始化<code>dispatch_queue_attr_info_t</code>。<br></p><pre class="line-numbers language-none"><code class="language-none">dispatch_queue_t
dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
	return _dispatch_lane_create_with_target(label, attr,
			DISPATCH_TARGET_QUEUE_DEFAULT, true);
}

---------------------

static dispatch_queue_t
_dispatch_lane_create_with_target(const char *label, dispatch_queue_attr_t dqa,
		dispatch_queue_t tq, bool legacy)
{
	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
  // ...省略N行代码--部分代码
	const void *vtable;
	dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : 0;
	if (dqai.dqai_concurrent) {
		vtable = DISPATCH_VTABLE(queue_concurrent);
	} else {
		vtable = DISPATCH_VTABLE(queue_serial);
	}

    dispatch_lane_t dq = _dispatch_object_alloc(vtable,
			sizeof(struct dispatch_lane_s));
	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?
			DISPATCH_QUEUE_WIDTH_MAX : 1, DISPATCH_QUEUE_ROLE_INNER |
			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : 0));
	dq-&gt;dq_label = label;
	dq-&gt;dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos,
			dqai.dqai_relpri);
    // 自定义的queue的目标队列是root队列
	dq-&gt;do_targetq = tq;
	_dispatch_object_debug(dq, "%s", __func__);
	return _dispatch_trace_queue_create(dq)._dq;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>再次通过全局搜索<code>_dispatch_queue_attr_to_info</code>，来查看<code>_dispatch_queue_attr_to_info</code>内部的实现。<br><pre class="line-numbers language-none"><code class="language-none">dispatch_queue_attr_info_t
_dispatch_queue_attr_to_info(dispatch_queue_attr_t dqa)
{
	dispatch_queue_attr_info_t dqai = { };

	if (!dqa) return dqai;

#if DISPATCH_VARIANT_STATIC
	if (dqa == &amp;_dispatch_queue_attr_concurrent) {
		dqai.dqai_concurrent = true;
		return dqai;
	}
#endif

	if (dqa &lt; _dispatch_queue_attrs ||
			dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) {
		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, "Invalid queue attribute");
	}

	size_t idx = (size_t)(dqa - _dispatch_queue_attrs);

	dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);
	idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;

	dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);
	idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;

	dqai.dqai_relpri = -(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);
	idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;

	dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;
	idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;

	dqai.dqai_autorelease_frequency =
			idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;
	idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;

	dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;
	idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;

	return dqai;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>_dispatch_queue_attr_to_info</code>方法内部首先判断我们传进来的dqa是否为空，如果为空则直接返回空结构体，也就是我们所说的串行队列（串行队列我们一般传DISPATCH<em>QUEUE_SERIAL或者NULL，其实DISPATCH_QUEUE_SERIAL的宏定义就是NULL）。如果不为空，则进入苹果的算法，通过结构体位域来设置dqai的属性并返回该结构体<code>dispatch_queue_attr_info_t</code>。结构体：<br><pre class="line-numbers language-none"><code class="language-none">typedef struct dispatch_queue_attr_info_s {
	dispatch_qos_t dqai_qos : 8;
	int      dqai_relpri : 8;
	uint16_t dqai_overcommit:2;
	uint16_t dqai_autorelease_frequency:2;
	uint16_t dqai_concurrent:1;
	uint16_t dqai_inactive:1;
} dispatch_queue_attr_info_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>再次回到<code>_dispatch_lane_create_with_target</code>内部，接下来出来overcommit（如果是串行队列的话默认是开启的，并行是关闭的）、<code>_dispatch_get_root_queue</code>获取一个管理自己队列的root队列，每一个优先级都有对应的root队列，每一个优先级又分为是不是可以过载的队列。再通过<code>dqai.dqai_concurrent</code>来区分并发和串行，<code>DISPATCH_VTABLE</code>内部利用`OS_dispatch</em>##name##_class<code>生成相应的class保存到结构体</code>dispatch_queue_t<code>内的do_vtable变量，接下来开辟内存</code>_dispatch_object_alloc <code>、构造方法</code>_dispatch_queue_init<code>这里的第三个参数判断是否并行队列，如果不是则最多开辟一条线程，如果是并行队列则最多可以开辟DISPATCH_QUEUE_WIDTH_FULL(0x1000) - 2条，也就是0xffe换算成10进制就是4094条线程，接下来就是设置dq的dq_label、dq_priority等属性，最后返回</code>_dispatch_trace_queue_create(dq)._dq<code>。进入其内部再次返回</code>_dispatch_introspection_queue_create(dqu)<code>，直到进入</code>_dispatch_introspection_queue_create_hook<code>内部的</code>dispatch_introspection_queue_get_info<code>返回串行或者并行的结构体用来保存关于队列的信息。</code>dispatch_introspection_queue_s<code>：
<pre class="line-numbers language-none"><code class="language-none">dispatch_introspection_queue_s diq = {
		.queue = dq-&gt;_as_dq,
		.target_queue = dq-&gt;do_targetq,
		.label = dq-&gt;dq_label,
		.serialnum = dq-&gt;dq_serialnum,
		.width = dq-&gt;dq_width,
		.suspend_count = _dq_state_suspend_cnt(dq_state) + dq-&gt;dq_side_suspend_cnt,
		.enqueued = _dq_state_is_enqueued(dq_state) &amp;&amp; !global,
		.barrier = _dq_state_is_in_barrier(dq_state) &amp;&amp; !global,
		.draining = (dq-&gt;dq_items_head == (void*)~0ul) ||
				(!dq-&gt;dq_items_head &amp;&amp; dq-&gt;dq_items_tail),
		.global = global,
		.main = dx_type(dq) == DISPATCH_QUEUE_MAIN_TYPE,
	};

---------

dispatch_introspection_queue_s diq = {
		.queue = dwl-&gt;_as_dq,
		.target_queue = dwl-&gt;do_targetq,
		.label = dwl-&gt;dq_label,
		.serialnum = dwl-&gt;dq_serialnum,
		.width = 1,
		.suspend_count = 0,
		.enqueued = _dq_state_is_enqueued(dq_state),
		.barrier = _dq_state_is_in_barrier(dq_state),
		.draining = 0,
		.global = 0,
		.main = 0,
	};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
对于</code>dispatch_get_global_queue<code>从底层</code>_dispatch_get_root_queue <code>中取得合适的队列，其可以开辟DISPATCH_QUEUE_WIDTH_FULL(0x1000) - 1条线程，也就是0xfff，并且从</code>dispatch_queue_s _dispatch_root_queues[]<code>全局属性里面存放各种global_queue；而对于</code>dispatch_get_main_queue <code>则是通过</code>DISPATCH_GLOBAL_OBJECT(dispatch_queue_main_t, _dispatch_main_q);<code>返回，通过全局搜索
<pre class="line-numbers language-none"><code class="language-none">DISPATCH_DECL_SUBCLASS(dispatch_queue_main, dispatch_queue_serial);
#define OS_OBJECT_DECL_SUBCLASS(name, super) \
		OS_OBJECT_DECL_IMPL(name, &lt;OS_OBJECT_CLASS(super)&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
可以发现</code>dispatch_queue_main<code>就是串行</code>dispatch_queue_serial`的子类，线程的width同样是0x1，也就是只有1条。<p></p>
<h4 id="同步dispatch-sync"><a href="#同步dispatch-sync" class="headerlink" title="同步dispatch_sync"></a>同步dispatch_sync</h4><p>接下来研究一下同步函数<code>dispatch_sync</code>，查看其源码进入内部方法<code>_dispatch_sync_f</code>，再次进入<code>_dispatch_sync_f_inline</code>内部：</p>
<pre class="line-numbers language-none"><code class="language-none">DISPATCH_NOINLINE
static void
_dispatch_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func,
		uintptr_t dc_flags)
{
	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);
}

---------

DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_sync_f_inline(dispatch_queue_t dq, void *ctxt,
		dispatch_function_t func, uintptr_t dc_flags)
{
	if (likely(dq-&gt;dq_width == 1)) {
		return _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);
	}

	if (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) {
		DISPATCH_CLIENT_CRASH(0, "Queue type doesn't support dispatch_sync");
	}

	dispatch_lane_t dl = upcast(dq)._dl;
	// Global concurrent queues and queues bound to non-dispatch threads
	// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE
	if (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) {
		return _dispatch_sync_f_slow(dl, ctxt, func, 0, dl, dc_flags);
	}

	if (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) {
		return _dispatch_sync_recurse(dl, ctxt, func, dc_flags);
	}
	_dispatch_introspection_sync_begin(dl);
	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(
			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先判断dq<em>width是否等于1,，也就是当前队列是否是串行队列，如果是则执行<code>_dispatch_barrier_sync_f</code>，经过一系列的嵌套最终走到<code>_dispatch_barrier_sync_f_inline</code>，<code>_dispatch_barrier_sync_f_inline</code>内部先通过<code>_dispatch_thread_port</code>获取当前线程ID，进入<code>_dispatch_queue_try_acquire_barrier_sync</code>判断线程状态，进入内部<code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code>，在这里会通过<code>os_atomic_rmw_loop2o</code>来获取当前队列依赖线程的状态信息；如果判断当前队列是全局并行队列或者绑定的是非调度线程的队列会直接进入if判断内执行<code>_dispatch_sync_f_slow</code>，在<code>_dispatch_sync_f_slow</code>内部会执行同步等待`<em>_DISPATCH_WAIT_FOR_QUEUE</em></em><code>，这里涉及到死锁的问题，其内部会将等待的队列</code>_dispatch_wait_prepare<code>和当前调度的队列进行对比</code>_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter)<code>，如果相同则直接抛出crash："dispatch_sync called on queue " "already owned by current thread"；如果没有产生死锁，最后执行</code>_dispatch_sync_invoke_and_complete_recurse <code>，其内部先执行</code>_dispatch_thread_frame_push<code>把任务压栈到队列后再执行func（block任务）后mach底层通过hook函数来监听complete，再</code>_dispatch_thread_frame_pop`把任务pop出去，这也就是为什么同步并发会顺序执行的原因。</p>
<p><code>_dispatch_barrier_sync_f_inline</code>：<br></p><pre class="line-numbers language-none"><code class="language-none">DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_barrier_sync_f_inline(dispatch_queue_t dq, void *ctxt,
		dispatch_function_t func, uintptr_t dc_flags)
{
	dispatch_tid tid = _dispatch_tid_self();

	if (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) {
		DISPATCH_CLIENT_CRASH(0, "Queue type doesn't support dispatch_sync");
	}

	dispatch_lane_t dl = upcast(dq)._dl;
	// The more correct thing to do would be to merge the qos of the thread
	// that just acquired the barrier lock into the queue state.
	//
	// However this is too expensive for the fast path, so skip doing it.
	// The chosen tradeoff is that if an enqueue on a lower priority thread
	// contends with this fast path, this thread may receive a useless override.
	//
	// Global concurrent queues and queues bound to non-dispatch threads
	// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE
	
	if (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) {
		return _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,
				DC_FLAG_BARRIER | dc_flags);
	}

	if (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) {
		return _dispatch_sync_recurse(dl, ctxt, func,
				DC_FLAG_BARRIER | dc_flags);
	}
	_dispatch_introspection_sync_begin(dl);
	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func
			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(
					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));
}

DISPATCH_NOINLINE
static void
_dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt,
		dispatch_function_t func, uintptr_t dc_flags)
{
	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>如果是全局并行队列或者绑定的是非调度线程的队列会直接进入<code>_dispatch_sync_f_slow</code>和上述逻辑相同。如果是加入栅栏函数的则开始验证target是否存在，<code>_dispatch_sync_recurse</code>内递归<code>_dispatch_sync_wait</code>进行查找target，直到找到target后执行<code>_dispatch_sync_invoke_and_complete_recurse</code>完成回调。<p></p>
<h4 id="异步dispatch-async"><a href="#异步dispatch-async" class="headerlink" title="异步dispatch_async"></a>异步dispatch_async</h4><p>进入<code>dispatch_async</code>源码内部，先进行了初始化操作：<br></p><pre class="line-numbers language-none"><code class="language-none">void
dispatch_async(dispatch_queue_t dq, dispatch_block_t work)
{
	dispatch_continuation_t dc = _dispatch_continuation_alloc();
	uintptr_t dc_flags = DC_FLAG_CONSUME;
	dispatch_qos_t qos;

	qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>进入<code>_dispatch_continuation_init</code>内部将<code>dispatch_async</code>的block任务重新赋值给func并保持为dc的dc_func属性。接下来执行<code>_dispatch_continuation_async</code>，最后进入<code>_dispatch_continuation_async</code>内部的<code>dx_push</code>，通过宏定义<code>#define dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</code>，我们选择进入全局并发队列<code>_dispatch_root_queue_push</code>，最终进入<code>_dispatch_root_queue_poke_slow</code>：<br><pre class="line-numbers language-none"><code class="language-none">static void
_dispatch_root_queue_poke_slow(dispatch_queue_global_t dq, int n, int floor)
{
	int remaining = n;
	int r = ENOSYS;

	_dispatch_root_queues_init();
	_dispatch_debug_root_queue(dq, __func__);
	_dispatch_trace_runtime_event(worker_request, dq, (uint64_t)n);

#if !DISPATCH_USE_INTERNAL_WORKQUEUE
#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
	if (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)
#endif
	{
		_dispatch_root_queue_debug("requesting new worker thread for global "
				"queue: %p", dq);
		r = _pthread_workqueue_addthreads(remaining,
				_dispatch_priority_to_pp_prefer_fallback(dq-&gt;dq_priority));
		(void)dispatch_assume_zero(r);
		return;
	}
#endif // !DISPATCH_USE_INTERNAL_WORKQUEUE
#if DISPATCH_USE_PTHREAD_POOL
	dispatch_pthread_root_queue_context_t pqc = dq-&gt;do_ctxt;
	if (likely(pqc-&gt;dpq_thread_mediator.do_vtable)) {
		while (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) {
			_dispatch_root_queue_debug("signaled sleeping worker for "
					"global queue: %p", dq);
			if (!--remaining) {
				return;
			}
		}
	}

	bool overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
	if (overcommit) {
		os_atomic_add2o(dq, dgq_pending, remaining, relaxed);
	} else {
		if (!os_atomic_cmpxchg2o(dq, dgq_pending, 0, remaining, relaxed)) {
			_dispatch_root_queue_debug("worker thread request still pending for "
					"global queue: %p", dq);
			return;
		}
	}

	int can_request, t_count;
	// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;
	t_count = os_atomic_load2o(dq, dgq_thread_pool_size, ordered);
	do {
		can_request = t_count &lt; floor ? 0 : t_count - floor;
		if (remaining &gt; can_request) {
			_dispatch_root_queue_debug("pthread pool reducing request from %d to %d",
					remaining, can_request);
			os_atomic_sub2o(dq, dgq_pending, remaining - can_request, relaxed);
			remaining = can_request;
		}
		if (remaining == 0) {
			_dispatch_root_queue_debug("pthread pool is full for root queue: "
					"%p", dq);
			return;
		}
	} while (!os_atomic_cmpxchgvw2o(dq, dgq_thread_pool_size, t_count,
			t_count - remaining, &amp;t_count, acquire));

	pthread_attr_t *attr = &amp;pqc-&gt;dpq_thread_attr;
	pthread_t tid, *pthr = &amp;tid;
#if DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_USE_PTHREAD_ROOT_QUEUES
	if (unlikely(dq == &amp;_dispatch_mgr_root_queue)) {
		pthr = _dispatch_mgr_root_queue_init();
	}
#endif
	do {
		_dispatch_retain(dq); // released in _dispatch_worker_thread
		while ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) {
			if (r != EAGAIN) {
				(void)dispatch_assume_zero(r);
			}
			_dispatch_temporary_resource_shortage();
		}
	} while (--remaining);
#else
	(void)floor;
#endif // DISPATCH_USE_PTHREAD_POOL
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>_dispatch_root_queue_poke_slow</code>先判断当前队列是否有问题，接下来执行<code>_pthread_workqueue_addthreads</code>调用底层直接添加线程到工作队列；下面第一个do-while循环来判断当前队列的缓存池的大小能否继续申请线程，如果大于可申请的大小则出现容积崩溃<code>_dispatch_root_queue_debug("pthread pool reducing request from %d to %d",
                    remaining, can_request);</code>，如果等于0，则报<code>_dispatch_root_queue_debug("pthread pool is full for root queue: "
                    "%p", dq);</code>。如果可以开辟的话，则进入下一个do-while循环，这时我们可以发现全局并发队列<code>pthread_create</code>来创建线程，直到要创建的线程为0。<p></p>
<h4 id="单例dispatch-once"><a href="#单例dispatch-once" class="headerlink" title="单例dispatch_once"></a>单例dispatch_once</h4><p>进入dispatch_once源码内部<code>dispatch_once_f</code>方法内，首先对<code>dispatch_once_t</code>做标记，如果当前状态为<code>DLOCK_ONCE_DONE</code>说明有加载过下次就不再次加载；如果从来没加载过则进入<code>_dispatch_once_gate_tryenter</code>，如果当前状态是<code>DLOCK_ONCE_UNLOCKED</code>则执行<code>_dispatch_once_callout</code>内部通过<code>_dispatch_client_callout</code>来进行单例调用，<code>_dispatch_once_gate_broadcast</code>来做<code>DLOCK_ONCE_DONE</code>标记已经加载过。<br></p><pre class="line-numbers language-none"><code class="language-none">void
dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)
{
	dispatch_once_gate_t l = (dispatch_once_gate_t)val;
	//DLOCK_ONCE_DONE
#if !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER
	uintptr_t v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);
	if (likely(v == DLOCK_ONCE_DONE)) {
		return;
	}
#if DISPATCH_ONCE_USE_QUIESCENT_COUNTER
	if (likely(DISPATCH_ONCE_IS_GEN(v))) {
		return _dispatch_once_mark_done_if_quiesced(l, v);
	}
#endif
#endif
	if (_dispatch_once_gate_tryenter(l)) {
		// 单利调用 -- v-&gt;DLOCK_ONCE_DONE
		return _dispatch_once_callout(l, ctxt, func);
	}
	return _dispatch_once_wait(l);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="信号量dispatch-semaphore"><a href="#信号量dispatch-semaphore" class="headerlink" title="信号量dispatch_semaphore"></a>信号量dispatch_semaphore</h4><p>首先创建信号量dispatch_semaphore_create源码内部主要是初始化信号量的信息和保存信号量dsema_value。接下来进入等待信号量dispatch_wait源码内部<code>dispatch_semaphore_wait</code>，先执行<code>os_atomic_dec2o</code>对信号量-1操作后，再判断当前信号量如果大于等于0则直接返回，否则进入等待<code>_dispatch_semaphore_wait_slow</code>逻辑，其内部会一直等待直到信号量为0或者调用<code>semaphore_signal()</code>才能唤醒。<br></p><pre class="line-numbers language-none"><code class="language-none">long
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
	long value = os_atomic_dec2o(dsema, dsema_value, acquire);
	if (likely(value &gt;= 0)) {
		return 0;
	}
	return _dispatch_semaphore_wait_slow(dsema, timeout);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>再看dispatch_semaphore_signal的源码内部实现，首先等待信号量dispatch_wait正好相反，执行<code>os_atomic_inc2o</code>对信号量+1操作。<br><pre class="line-numbers language-none"><code class="language-none">long
dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
	long value = os_atomic_inc2o(dsema, dsema_value, release);
	if (likely(value &gt; 0)) {
		return 0;
	}
	if (unlikely(value == LONG_MIN)) {
		DISPATCH_CLIENT_CRASH(value,
				"Unbalanced call to dispatch_semaphore_signal()");
	}
	return _dispatch_semaphore_signal_slow(dsema);
}

long
_dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)
{
	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);
	_dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, 1);
	return 1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="调度组dispatch-group"><a href="#调度组dispatch-group" class="headerlink" title="调度组dispatch_group"></a>调度组dispatch_group</h4><p>首先进入<code>dispatch_group_create</code>源码内部，利用<code>_dispatch_object_alloc</code>来创建dispatch_group_t并初始化，最后返回。接下来看<code>dispatch_group_enter</code>，其内部先通过<code>os_atomic_sub_orig2o</code>来进行-1操作，<code>dispatch_group_leave</code>则是进行+1操作，这里可以看到如果进行<code>dispatch_group_enter</code>操作信号量不为0或者进行<code>dispatch_group_leave</code>操作后信号量等于0，则说明<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>不是匹配的，那么直接报出DISPATCH_CLIENT_CRASH信息。如果目前没问题的话那么<code>dispatch_group_leave</code>会执行<code>_dispatch_group_wake</code>，</p>
<pre class="line-numbers language-none"><code class="language-none">DISPATCH_ALWAYS_INLINE
static inline dispatch_group_t
_dispatch_group_create_with_count(uint32_t n)
{
	dispatch_group_t dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),
			sizeof(struct dispatch_group_s));
	dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;
	dg-&gt;do_targetq = _dispatch_get_default_queue(false);
	if (n) {
		os_atomic_store2o(dg, dg_bits,
				-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);
		os_atomic_store2o(dg, do_ref_cnt, 1, relaxed); // &lt;rdar://22318411&gt;
	}
	return dg;
}

void
dispatch_group_leave(dispatch_group_t dg)
{
	// The value is incremented on a 64bits wide atomic so that the carry for
	// the -1 -&gt; 0 transition increments the generation atomically.
	uint64_t new_state, old_state = os_atomic_add_orig2o(dg, dg_state,
			DISPATCH_GROUP_VALUE_INTERVAL, release);
	uint32_t old_value = (uint32_t)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);

	if (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) {
		old_state += DISPATCH_GROUP_VALUE_INTERVAL;
		do {
			new_state = old_state;
			if ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == 0) {
				new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;
				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;
			} else {
				// If the group was entered again since the atomic_add above,
				// we can't clear the waiters bit anymore as we don't know for
				// which generation the waiters are for
				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;
			}
			if (old_state == new_state) break;
		} while (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,
				old_state, new_state, &amp;old_state, relaxed)));
		return _dispatch_group_wake(dg, old_state, true);
	}

	if (unlikely(old_value == 0)) {
		DISPATCH_CLIENT_CRASH((uintptr_t)old_value,
				"Unbalanced call to dispatch_group_leave()");
	}
}

void
dispatch_group_enter(dispatch_group_t dg)
{
	// The value is decremented on a 32bits wide atomic so that the carry
	// for the 0 -&gt; -1 transition is not propagated to the upper 32bits.
	uint32_t old_bits = os_atomic_sub_orig2o(dg, dg_bits,
			DISPATCH_GROUP_VALUE_INTERVAL, acquire);
	uint32_t old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;
	if (unlikely(old_value == 0)) {
		_dispatch_retain(dg); // &lt;rdar://problem/22318411&gt;
	}
	if (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) {
		DISPATCH_CLIENT_CRASH(old_bits,
				"Too many nested calls to dispatch_group_enter()");
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>_dispatch_group_wake</code>内部会通过do-while执行<code>_dispatch_continuation_async</code>来循环遍历添加到notify内的任务。这里<code>dispatch_group_leave</code>后和<code>_dispatch_group_notify</code>最后的操作一样都会调用<code>_dispatch_group_wake</code>来执行任务。<br></p><pre class="line-numbers language-none"><code class="language-none">DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,
		dispatch_continuation_t dsn)
{
	uint64_t old_state, new_state;
	dispatch_continuation_t prev;

	dsn-&gt;dc_data = dq;
	_dispatch_retain(dq);

	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);
	if (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);
	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);
	if (os_mpsc_push_was_empty(prev)) {
		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, release, {
			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;
			if ((uint32_t)old_state == 0) {
				os_atomic_rmw_loop_give_up({
					return _dispatch_group_wake(dg, new_state, false);
				});
			}
		});
	}
}

DISPATCH_NOINLINE
static void
_dispatch_group_wake(dispatch_group_t dg, uint64_t dg_state, bool needs_release)
{
	uint16_t refs = needs_release ? 1 : 0; // &lt;rdar://problem/22318411&gt;

	if (dg_state &amp; DISPATCH_GROUP_HAS_NOTIFS) {
		dispatch_continuation_t dc, next_dc, tail;

		// Snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;
		dc = os_mpsc_capture_snapshot(os_mpsc(dg, dg_notify), &amp;tail);
		do {
			dispatch_queue_t dsn_queue = (dispatch_queue_t)dc-&gt;dc_data;
			next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);
			_dispatch_continuation_async(dsn_queue, dc,
					_dispatch_qos_from_pp(dc-&gt;dc_priority), dc-&gt;dc_flags);
			_dispatch_release(dsn_queue);
		} while ((dc = next_dc));

		refs++;
	}

	if (dg_state &amp; DISPATCH_GROUP_HAS_WAITERS) {
		_dispatch_wake_by_address(&amp;dg-&gt;dg_gen);
	}

	if (refs) _dispatch_release_n(dg, refs);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>说到调度组肯定少不了<code>dispatch_group_async</code>，<code>dispatch_group_async</code>其实就是对<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的封装。进入<code>dispatch_group_async</code>源码在初始化<code>_dispatch_continuation_init</code>保存任务后开始执行<code>_dispatch_continuation_group_async</code>操作，我们可以看到内部先进行了<code>dispatch_group_enter</code>，然后经过<code>_dispatch_continuation_async</code>、<code>dx_push</code>、<code>_dispatch_root_queue_poke</code>等操作后最终调用<code>_dispatch_client_callout</code>执行任务，当任务执行完毕后再通过mach底层来通知完成complete操作，最后执行<code>dispatch_group_leave</code>。<br><pre class="line-numbers language-none"><code class="language-none">DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_continuation_group_async(dispatch_group_t dg, dispatch_queue_t dq,
		dispatch_continuation_t dc, dispatch_qos_t qos)
{
	dispatch_group_enter(dg);
	dc-&gt;dc_data = dg;
	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);
}

static inline void
_dispatch_continuation_with_group_invoke(dispatch_continuation_t dc)
{
	struct dispatch_object_s *dou = dc-&gt;dc_data;
	unsigned long type = dx_type(dou);
	if (type == DISPATCH_GROUP_TYPE) {
		_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);
		_dispatch_trace_item_complete(dc);
		dispatch_group_leave((dispatch_group_t)dou);
	} else {
		DISPATCH_INTERNAL_CRASH(dx_type(dou), "Unexpected object type");
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该文章为记录本人的学习路程，也希望能够帮助大家，知识共享，共同成长，共同进步！！！<p></p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime底层原理--IMP查找流程、动态方法解析、消息转发源码分析</title>
    <url>/2019/04/10/imp-yuan-ma-fen-xi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3e21c38f5be9a8d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runtime底层原理"></p>
<p>了解了<a href="https://www.jianshu.com/p/eddc9bdb46ea">Runtime函数含义</a>，我们就可以直接使用Runtime的API了，那接下来继续探究Runtime的源码，经过源码分析来更加深刻的了解Runtime原理。</p>
<h4 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h4><blockquote>
<p>都知道Runtime很重要，但是有很多小伙伴根本不了解，或者只是知道可以替换方法啊、可以交换两个方法的调用，项目中也用不到，<br>从进入iOS开始，写了无数个<code>[[objc alloc] init]</code>，这个到底在干嘛？初始化和init？alloc和init到底做了什么？</p>
</blockquote>
<h5 id="通过汇编查看方法调用"><a href="#通过汇编查看方法调用" class="headerlink" title="通过汇编查看方法调用"></a>通过汇编查看方法调用</h5><pre class="line-numbers language-none"><code class="language-none">Person *person = [Person alloc];
Person *person1 = [person init];
Person *person2 = [person init];
NSLog(@"%p-----%p------%p", person, person1, person2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里会输出什么呢？</p>
<pre class="line-numbers language-none"><code class="language-none">0x10102e1a0-----0x10102e1a0------0x10102e1a0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>来，让我们断点看下，<code>alloc</code>和<code>init</code>是怎么调用的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-df50f7ae402013ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc_msgSend"></p>
<p>我们看到调用<code>alloc</code>和<code>init</code>都调起了<code>objc_msgSend</code>，接下来跟着符号断点走</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7706f8564d5b447d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="libobjc"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7f2f3a95f30891e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callAlloc"></p>
<p>进入<code>libobjc</code>库的dylib之后走<code>+[NSObject alloc]</code>方法，指针调起<code>_objc_rootAlloc</code>，进入<code>_objc_rootAlloc</code>方法，继续调起<code>callAlloc</code>，通过寄存器，可以看到alloc已经通过类创建实例对象</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6839fe399aa384bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象"></p>
<p><code>init</code>按照同样方法 依然可以通过汇编看出方法调用顺序，可以用真机进行测试并打印 </p>
<h5 id="通过编译C"><a href="#通过编译C" class="headerlink" title="通过编译C++"></a>通过编译C++</h5><p>当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做 isa。通过该指针，对象可以访问它对应的类以及相应的父类。在 Objective-C 运行时系统中对象需要有 isa 指针，我们一般创建的从 NSObject 或者 NSProxy 继承的对象都自动包括 isa 变量。接下来看下对象被创建的过程<br>首先，我们通过clang命令<br></p><pre class="line-numbers language-none"><code class="language-none">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o testMain.c++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>也可以用<code>clang -rewrite-objc main.m -o test.c++</code>命令，只不过会有很多警告、代码会更长（大概9万多行）。<br>编译main函数中的OC代码为C++代码<br><pre class="line-numbers language-none"><code class="language-none">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        Person *p = [[Person alloc] init];
        [p run];
  
    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>编译后多一个testMain.c++文件，打开后在代码最后面会发现我们的main函数<br><pre class="line-numbers language-none"><code class="language-none">int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        Person *p = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init"));
        ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName("run"));

    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看出，我们的方法调用会编译成objc_msgSend，<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6b959a3252ac08d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="person对象"></p>
<p>由此还会发现对象的本质其实就是一个结构体</p>
<h4 id="下层通讯-通过源码查看objc-msgSend内部实现"><a href="#下层通讯-通过源码查看objc-msgSend内部实现" class="headerlink" title="下层通讯(通过源码查看objc_msgSend内部实现)"></a>下层通讯(通过源码查看objc_msgSend内部实现)</h4><p>首先我们到<a href="https://upload-images.jianshu.io/upload_images/5741330-3acf8ade7f319c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">苹果open source</a>官网下载最新源码<br><img src="https://upload-images.jianshu.io/upload_images/5741330-3acf8ade7f319c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码"></p>
<p>在<strong>方法调用的时候，会发送<code>objc_msgSend</code>消息，<code>objc_msgSend</code>会根据sel找到函数实现的指针imp</strong>，进而执行函数，那sel是如何找到imp的呢？<br><code>objc_msgSend</code>在发送消息时候根据sel查找imp有两种方式</p>
<ul>
<li>快速（通过汇编的缓存快速查找）</li>
<li>慢速（C配合C++、汇编一起查找）<br>先看下objc_class</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-da01958ba32dd572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc_class"></p>
<p>bits中包含各种数据，cache（每个类都有一个）用来存储方法select和imp，select和imp会以哈希表形式存在<br><code>objc_msgSend</code>在快速查找的时候，就是通过汇编查找objc_class中的cache，如果找到则直接返回，否则通过C的lookup，找到后再存入cache</p>
<h5 id="汇编部分快速查找"><a href="#汇编部分快速查找" class="headerlink" title="汇编部分快速查找"></a>汇编部分快速查找</h5><p>首先调用<code>objc_msgSend</code>会走到ENTRY</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-4d838bce5a43c8e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ENTRY"></p>
<p>先判断p0检查是否为空和tagged pointer（特殊类型）判断，调用<code>LNilOrTagged</code>进行isa处理，通过isa找到相应类class，最后调用<code>LGetIsaDone</code>来执行<code>CacheLookup</code>在缓存中查找imp，如果查找到直接调起imp否则调起objc_msgSend_uncached，objc_msgSend_uncached有两种情况</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-41e6fb32bc6de43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CacheLookup"></p>
<p>首先，第一个是CacheHit，直接调起imp，第二个是CheckMiss，之后调用objc_msgSend_uncached，第三个就是add，下面是CacheHit和CheckMiss的宏</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-a88860fb2c1871b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CacheLookup macro"></p>
<p>那如果在缓存中没有查找到imp，调起<code>objc_msgSend_uncached</code>，在方法列表中找到imp之后再<code>TailCallFunctionPointer</code>调起imp<br></p><pre class="line-numbers language-none"><code class="language-none">   STATIC_ENTRY __objc_msgSend_uncached
UNWIND __objc_msgSend_uncached, FrameWithNoSaves

// THIS IS NOT A CALLABLE C FUNCTION
// Out-of-band p16 is the class to search

MethodTableLookup      // 方法列表中找到imp
TailCallFunctionPointer x17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>重点:MethodTableLookup是怎么操作的</strong><p></p>
<blockquote>
<p>小知识点：通过method list查找method，下面是method_t的结构，method其实是一个哈希表，sel和imp是键值对<br></p><pre class="line-numbers language-none"><code class="language-none">struct method_t {
    SEL name;
    const char *types;       // 参数类型
    MethodListIMP imp;
    struct SortBySELAddress :
        public std::binary_function&lt;const method_t&amp;,
                                    const method_t&amp;, bool&gt;
    {
        bool operator() (const method_t&amp; lhs,
                         const method_t&amp; rhs)
        { return lhs.name &lt; rhs.name; }
    };
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>进入<code>MethodTableLookup</code>之后，调起了<code>__class_lookupMethodAndLoadCache3</code>，如下图<p></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-e53cc3c30a78bbe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MethodTableLookup"></p>
<p><code>__class_lookupMethodAndLoadCache3</code>是C方法，再次进入<code>_class_lookupMethodAndLoadCache3</code>方法，<strong>注意，因为这里由汇编跳转到C，所以要全局搜索<code>_class_lookupMethodAndLoadCache3</code>，要删去一个<code>"_"</code></strong>,下面是<code>_class_lookupMethodAndLoadCache3</code>函数</p>
<pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* This lookup avoids optimistic cache scan because the dispatcher 
* already tried that.
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="C-C-部分查找"><a href="#C-C-部分查找" class="headerlink" title="C/C++部分查找"></a>C/C++部分查找</h5><p>调起<code>lookUpImpOrForward</code>，因为当前cls对象已经经过汇编编译到结构，有了isa，并且在cache中没有找到，所以这里的initialize为YES，cache为NO，resolver为YES</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-71ad5c6ba37152f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>进入<code>lookUpImpOrForward</code>，这里再次判断是否存在cache，如果有则直接快速查找，但是这里是NO，所以不会走。接下来走<code>checkIsKnownClass</code>判断是否是已经声明的类，如果没有则报错”Attempt to use unknown class %p.”，之后走<code>realizeClass</code>判断是否已经实现，如果就相应赋值data。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-8916248bb091fe67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="realizeClass"></p>
<p>data赋值后走<code>_class_initialize</code>初始化cls，接下来开始<code>retry</code>操作。<br><strong>前方高能</strong><br>再次进行cache_getImp，why？并发啊，还有重映射（在初始化init的时候有个remap（class）第一次通过汇编找不到，但是在加载类的时候对当前类进行重映射）<br><img src="https://upload-images.jianshu.io/upload_images/5741330-cbe3379e8e73bf14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cache_getImp"></p>
<p>接下来开始先在自己的class_rw_t的methods中根据sel查找方法返回method_t</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-22158fedc376e3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="method_t"></p>
<p>如果拿到Method后保存到缓存中，保证以后调用可以直接走汇编的CacheHit快速查找，如果拿不到则继续从父类开始查找，直到找到NSObject(因为NSObject的父类为nil)，如果找到imp则一样保存在缓存中，如果到最后还是没有查找到，则进入动态方法解析。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-348eeda298ad6d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父类查找方法"></p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>如果前面一系列操作还是没有找到方法，那么就会进行动态方法解析，动态方法解析只执行一次</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-9cbb884006c3e59c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态方法解析"></p>
<p>首先执行<code>_class_resolveMethod</code>，这里会执行<code>+resolveClassMethod</code> 或者 <code>+resolveInstanceMethod</code>。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-c5cda417fae04acb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class resolveMethod"></p>
<p>先判断当前cls是否为元类，如果是元类则执行<code>_class_resolveClassMethod</code>，再执行<code>_class_resolveInstanceMethod</code>，如果不是元类则直接执行<code>_class_resolveInstanceMethod</code>，<code>_class_resolveInstanceMethod</code>内部调用objc_msgSend实现消息发送，对cls发送了<code>SEL_resolveInstanceMethod</code>类型的消息，所以在方法中会走到<code>resolveInstanceMethod</code>方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0ed2701ca3678b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class resolveInstanceMethod"></p>
<p>为什么元类最后也执行了<code>_class_resolveInstanceMethod</code>方法呢？因为类方法以实例对象的形态存在元类里面，比如类方法中没有找到方法，会去元类中查找，元类中没有再继续去根元类中查找，最后会查到NSObject。</p>
<h6 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h6><p>.h实现<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)run;
+ (void)eat;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>.m实现(没有实现-run方法和+eat方法)<br><pre class="line-numbers language-none"><code class="language-none">- (void)walk {
    NSLog(@"%s",__func__);
}
+ (void)drink {
    NSLog(@"%s",__func__);
}

// .m没有实现,并且父类也没有,那么我们就开启动态方法解析
//- (void)walk{
//    NSLog(@"%s",__func__);
//}
//+ (void)drink{
//    NSLog(@"%s",__func__);
//}


#pragma mark - 动态方法解析

+ (BOOL)resolveInstanceMethod:(SEL)sel{
    if (sel == @selector(run)) {
        // 我们动态解析我们的 对象方法
        NSLog(@"对象方法解析走这里");
        SEL walkSEL = @selector(walk);
        Method readM= class_getInstanceMethod(self, walkSEL);
        IMP readImp = method_getImplementation(readM);
        const char *type = method_getTypeEncoding(readM);
        return class_addMethod(self, sel, readImp, type);
    }
    return [super resolveInstanceMethod:sel];
}


+ (BOOL)resolveClassMethod:(SEL)sel{
    if (sel == @selector(eat)) {
        // 我们动态解析我们的 对象方法
        NSLog(@"类方法解析走这里");
        SEL drinkSEL = @selector(drink);
        // 类方法就存在我们的元类的方法列表
        // 类 类犯法
        // 元类 对象实例方法
        //        Method hellowordM1= class_getClassMethod(self, hellowordSEL);
        Method drinkM= class_getInstanceMethod(object_getClass(self), drinkSEL);
        IMP drinkImp = method_getImplementation(drinkM);
        const char *type = method_getTypeEncoding(drinkM);
        NSLog(@"%s",type);
        return class_addMethod(object_getClass(self), sel, drinkImp, type);
    }
    return [super resolveClassMethod:sel];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h5><p>经历了动态方法决议还没有找到，会进入苹果尚未开源的消息转发，继续查找方法，<code>_objc_msgForward_impcache</code>再次跨域到汇编。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-c9fa6f055cdbc9d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<p>走到<code>__objc_msgForward_impcache</code>后执行<code>__objc_msgForward</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-bb97c18875125e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__objc_msgForward_impcache"></p>
<p>没有了源码实现，但是我们可以通过<code>instrumentObjcMessageSends</code>函数来打印调用堆栈信息。可以进入<code>instrumentObjcMessageSends</code>内部看下具体实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-f7a9ba5a7514aff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instrumentObjcMessageSends"></p>
<p>先判断了是否可以写入日志信息等，接下来同步日志文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-e67afa0438c44bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logMessageSend"></p>
<p>所以我们每次运行会在<code>/private/tmp</code>文件下多一个<code>msgSends-xxx</code>文件，里面是所有调用过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7879482357d545ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆栈调用信息"></p>
<p>如果还没有找到的话最后会报错调用<code>__objc_forward_handler</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0c3110e83a8752ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__objc_forward_handler"></p>
<p>这也是我们在方法报错的时候会报<code>unrecognized selector sent to instance %p " "(no message forward handler is installed)"</code>错误的原因，会提示出元类信息，<code>+</code>或者<code>-</code>方法，方法的名字还有SEL方法编号</p>
<h6 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h6><pre class="line-numbers language-none"><code class="language-none">#pragma mark - 实例对象消息转发

- (id)forwardingTargetForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    //    if (aSelector == @selector(run)) {
    //        // 转发给Student对象
    //        return [Student new];
    //    }
    return [super forwardingTargetForSelector:aSelector];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    if (aSelector == @selector(run)) {
        // forwardingTargetForSelector 没有实现，就只能方法签名了
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation{
    NSLog(@"%s",__func__);
    NSLog(@"------%@-----",anInvocation);
    anInvocation.selector = @selector(walk);
    [anInvocation invoke];
}

#pragma mark - 类消息转发

+ (id)forwardingTargetForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    return [super forwardingTargetForSelector:aSelector];
}
//

+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    if (aSelector == @selector(walk)) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    return [super methodSignatureForSelector:aSelector];
}

+ (void)forwardInvocation:(NSInvocation *)anInvocation{
    NSLog(@"%s",__func__);
    
    NSString *sto = @"奔跑吧";
    anInvocation.target = [Student class];
    [anInvocation setArgument:&amp;sto atIndex:2];
    NSLog(@"%@",anInvocation.methodSignature);
    anInvocation.selector = @selector(run:);
    [anInvocation invoke];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们应该也知道了为什么<code>objc_msgSend</code>的源码用的汇编，因为汇编可以通过寄存器x0-x31来保留未知参数来跳转到任意的指针，还有汇编更高效一点，而C满足不了。</p>
<h4 id="言而总之，总而言之"><a href="#言而总之，总而言之" class="headerlink" title="言而总之，总而言之"></a>言而总之，总而言之</h4><blockquote>
<p>Runtime就是C、C++、汇编实现的一套API，给OC增加的一个运行时功能，也就是我们平时所说的运行时。<br>在运行工程时工程会被装载到内存，来提供运行时功能。</p>
</blockquote>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用签名原理--数字签名？代码签名？双层代码签名？</title>
    <url>/2019/03/02/ying-yong-qian-ming/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3d5330cfad68a1dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用签名"></p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><blockquote>
<p>数字签名（又称<a href="https://baike.baidu.com/item/%E5%85%AC%E9%92%A5">公钥</a>数字签名、<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E7%AD%BE%E7%AB%A0/4076522">电子签章</a>等）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。<br>数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>
</blockquote>
<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF">数字签名技术</a>是将摘要信息用发送者的私钥加密，与<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%96%87">原文</a>一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用<a href="https://baike.baidu.com/item/HASH%E5%87%BD%E6%95%B0">Hash函数</a>对收到的<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%96%87">原文</a>产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<p>举个例子：移动客户端向服务器发送数据</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-643b048c3213f611.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端发送数据"></p>
<p>如果不做任何处理，可能会遭到中间人的窃取攻击，后果如何严重就不说了。那么我们如何防止中间人拦截，或者检查数据是否被篡改呢？<br>直接用RSA（<a href="www.jianshu.com/p/ad3d1dea63af">RSA加密原理</a>）进行加密应该是不满足我们的需求，RSA只适合对小数据进行加密，我们知道验证数据的完整性可以用Hash（<a href="www.jianshu.com/p/a6fca79eb89c">Hash概述</a>）来验证，可以对数据进行Hash，把Hash值和原始数据一起打包发送给服务器，服务器将原始数据进行Hash，得到的hash值和客户端发送的Hash值做对比，如果一致则保证数据有效性。但是这样会有安全隐患，如果中间人篡改了客户端发送的数据，当然也可以修改客户端发送的Hash值，所以这样操作不可行。</p>
<p>这时我们可以用RSA来对hash值进行保护，此时客户端发送原始数据，和经RSA加密后的该数据的hash值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-2570cf7be94ba279.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数字签名"></p>
<p>服务器对RSA加密的数据进行解密，得到原始数据的hash值，接下来对原始数据进行通过同样的Hash算法，将得到的Hash值和解密后的Hash值做对比，如果一致则保证数据有效性，整个过程中，如果解密的Hash值和原始的Hash值不一致，或者无法解密RSA的数据，说明数据被篡改了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-091add7525e628eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg"></p>
<p>现在我们解决了服务端收到客户端发送数据的有效性，此时我们称，对原始数据Hash值进行RSA加密后的数据，是原始数据的数字签名。简单解释数字签名也就是对原始数据的Hash值进行非对称加密。</p>
<h4 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h4><blockquote>
<p>代码签名是对可执行文件或脚本进行数字签名，用来标识软件来源以及软件开发者的真实身份，确认软件在签名后未被修改或损坏的措施。和数字签名原来一样，只不过签名的数据是代码而已。</p>
</blockquote>
<p>苹果也是通过代码签名来保证每一个安装到iOS上的APP都是经过苹果官方允许的，防止盗版软件、病毒入侵、静默安装等。如果想要实现验证，最简单的方式就是通过苹果官方生成非对称加密的一对公私钥，在iOS系统中内置一个与服务器对应的公钥，私钥由苹果后台来保存，我们传APP到App Store时，苹果后来用私钥对APP数据进行签名，iOS系统下载这个APP后，用公钥验证这个签名，如果签名正确则这个APP肯定是由苹果后台认证的，并且没有被修改或损坏。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3f81b4ef5db3f1b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码签名"></p>
<p>整个过程很简单，这样就保证了苹果安装的每一个APP都是经过苹果官方允许的。对于大部分普通用户而言，这样一个数字签名就解决了安全隐患问题，但是实际上iOS设备安装APP并不是只有App Store这一个渠道，比如对于我们iOSer来说，我们在开发APP时还在真机调试，当然苹果还开放了企业内部分发的渠道，这时就无法通过简单的代码签名来满足这些需求了。</p>
<p>苹果为了实现这些需求，iOS签名的复杂度也就开始增加了，这样双层代码签名就出现了。前提，我们都知道描述文件，但是描述文件具体是干嘛的呢</p>
<h4 id="描述文件"><a href="#描述文件" class="headerlink" title="描述文件"></a>描述文件</h4><blockquote>
<p>在真机调试时候，都会有一个描述文件，描述文件就是在developer.apple.com创建的，在Xcode中填入AppID后会代办创建，Xcode运行时会打包进APP中。为了系统安全，苹果除了控制APP滥用问题还控制了推送、iCloud、调试器等附加这些权限，苹果把这些权限开关统一称为Entitlements（授权文件）。并将这个文件放在了一个叫做Provisioning Profile（描述文件）文件中，描述文件里面就包括权限、证书等配置相关文件。</p>
</blockquote>
<p>通常，描述文件会保存在~/Library/MobileDevice/Provisioning Profiles/这个文件中，可以在终端用 security cms -D -i  + [名称]命令查看描述文件里面的信息，我们会发现，描述文件是一个plist文件，下面是个人描述文件信息演示，并对一些信息做出了注释，部分关键内容被隐藏，Base64（<a href="www.jianshu.com/p/26f2ed1ed1f6">了解Base64编码解码</a>）内容被删减<br></p><pre class="line-numbers language-none"><code class="language-none">$ security cms -D -i 294b2de0-a877-4f33-9825-9a8***.mobileprovision 
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
	&lt;key&gt;AppIDName&lt;/key&gt;
	&lt;string&gt;com *** &lt;/string&gt;
	&lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt;
	&lt;array&gt;
	&lt;string&gt;***GCDB&lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;CreationDate&lt;/key&gt;
	&lt;date&gt;2019-03-06T08:54:06Z&lt;/date&gt;
	&lt;key&gt;Platform&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt;iOS&lt;/string&gt;
	&lt;/array&gt;
    &lt;key&gt;IsXcodeManaged&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;DeveloperCertificates&lt;/key&gt;
	&lt;array&gt;
		&lt;data&gt;***vcNAQELBQAwgZYxCzAJBgNVBAYTAlVTMRMwEQYDVQQKDApBcHBsZSBJbmMuMSwwKgYDVQQLDCNBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNzEwMDIzNsb3BtZW50IENvLixMdGQuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAO4xNm+/SXHwULul2Am4b+2/a919AfaDSy6Jw+nC3599RNhUlY+/PNTudcsBUsSw53+flAh6dVVGO77lebM1GaveXMLr65l9aZe2a6ewR0QOpSkvoBZBXlRA14WpyfdMbU7VlWutKiFHsuxA4KSQyoagY8GJ3tB5vSlxRtfix0TKtOCMx9v1iYdCztmhmtt5J6GZn8jKszkPgKxMNvm4MD9N/pr7/Z0gX06oywYb3DpS7uQKdffsLZyj05H0HvSg6V4nHZw5HNIf8qd1VjOiI7NGcvsOwltfGmiOhmxQjaESwalgX7vWg7ij8fh9ke1on8veQgptIxutKjLWG9JnJ2LPOeP7w3PJC03Yl89qJ6F0VAyA1+ck1ieimrG0yXkd9z/YWMd/puDoW7SmEQ/WdKyQkyld0iSnkQ90511uOAp0/yDgaaouyUDZlcIjL2/4JzdEJEiRkZEdmw63uYe4dwXSyTyLlA+ntka2QlKEiJmy8oyPTqjEuqcWWQmnFYWiEBqPaeEXlXT9uuGjqn9aN3MaTgD8QFIyOhonc6ReQHtx8apXGEzhVNAQXCLuKSB04JiCbL3YE2XT42QlygBL+7ROxC00pAIltrPkFfuoyBbpnj9pWQ==&lt;/data&gt;
		&lt;data&gt;***GVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNTI1MTMxMjA4WhcNMTkwNTI1MTMxMjA4WjCBrjEaMBgGCgmSJomT8ixkAQEMCjVFVE45NEpBNlUxMTAvBgNVBAMMKGlQaG9uZSBEZXZlbG9wZXI6IFhpbiBDaGVuZyAoNEU4Mk5RVzZDMikxEzARBgNVBAsMClpFV0pNSEdDREIxOzA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBvd2VyIERldmVsb3BtZW50IENvMDYGCCsGAQUFBwIBFipodHRwOi8dEU39NyqZsQBCA/P1txkkx9sI7JsMcMnjwa/N5QCg+gJLvMEh1ZvQ/rroTtyvDxFuuMrQkiZeeBGs8qBO2Jre6ma32mMo5kSjc9w9AtnFwlQHrW3+HPwwqlThRrMeNvbLZAvZhoENb04HE26sH4k1tk8CrNvutsjl+K3GGnuvWCnZy/dT57wrGAMrlkQZRWXomSxr9y+F4ArsMj+4UsA==&lt;/data&gt;
		&lt;data&gt;***sZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNTEzMDQ1OTQ0WhcNMTkwNTEzMDQ1OTQ0WjCBrjEaMBgGCgmSJomT8ixkAQEMCjVFVE45NEpBNlUxMTAvBgNVBAMMKGlQaG9uZSBEZXZlbG9wZXI6IFhpbiBDaGVuZyAoNEU4Mk5RVzZDMikxEzARBgNVBAsMClpFV0pNSEdDREIxOzA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBByYWN0aWNlIHN0YXRlbWVudHMuMDYGCCsGAQUFBwIBFipodHRwOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwMwHQYzizUHwwrgDSFxwfGfc71fr4hz3PmN6o7XqtGcNO4Af49JdDMZv6VQ5mr/plPBSDdun0D5ZfNDr9cXopDCzy+XPZB/H1ARmy1MT4vuKvdsGuUKBvJX/HinDi38G6AuwZ0alfPY9xqJ7WB7K14kaVdaaqOHMThOA7b7b1Stu+MjAKYJ6aUkrf9vvDbDAkQFi8lfh4L3Vya9MoXEpDpCNxQrUJhc6sy2eMf1NT5Q==&lt;/data&gt;
		&lt;data&gt;***zA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBvd2VyIERldmVsb3BtZW50IENvLixMdGQuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKIWs9nQdTq3yqKLYVmjrGrgh6MhaWlkZb5MeHWKwGfky3/n/FaXmrLNxFFFWeFihdg4zmFjSjRl8ccvPF3afdZU2qW4Co1aKu459CnPhknFNbFtcrs0V1T6u6p3RJn6togsWn1z33IakruJPYtwY7k4S5jb20vb2NzcDAzLXd3ZHIwMTCCAR0GA1UdIASCARQwggEQMIIBDAYJKoZIhvdjZAUBMIH+MIHDBggrBgEFBQcCAjCBtgyBs1JlbGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMgYWNjZXB0YW5jZSBvZiB0aGUgdGVAFqGwKrYTc+8/GyszOm3u4/mn5s5b58ORnITE+A9bNtDGv6Qz46ev3ZMCrQZFwye//Tk+BI7ms4++jkj/pcmUCULtZw178cTRBpMT4P7tzgH5mRP/BpcSd/rv8994UXYPYdpXa4epFhchlCvu8dT8sQ38fFeahyd85nS30c4RxyW32bzKnzzRSedr/j4Y1qIIvzKdWPcnwkA5RYH8naxYfzEXL2321tdwfR5skvApeP/S2oX9WC+18XBk8Yy693rJoqrKdwkOzQSVGcA==&lt;/data&gt;
		&lt;data&gt;***3NjZOMlBGS00xMzAxBgNVBAMMKmlQaG9uZSBEZXZlbG9wZXI6IEhhb3lhbmcgWmh1IChLTU5VVTI4QlBaKTETMBEGA1UECwwKWkVXSk1IR0NEQjE7MDkGA1UECgwyU2hhbmdoYWkgUmlzZW4gRWxlY3RyaWMgUG93ZXIgRGV2ZWxvcG1lbnQgQ28uLEx0ZC4xCzAJBgNVBAYTAlVTMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA19bNzMNJ0uSYvwNygYH8b4GQY11UmNvbS9vY3NwMDMtd3dkcjAxMIIBHQYDVR0gBIIBFDCCARAwggEMBgkqhkiG92NkBQEwgf4wgcMGCY2QGAQIBAf8EAgUAMA0GCSqGSIb3DQEBCwUAA4IBAQCJw3MoEbhJNVyc1PFG6FtY7QZAy+gmqRz9YiwnFh3y5Qj5lnC2n0WdG8SrlZA+TKQgfwRZNEB6ZIfDZOJAFsqpBMAauC1V0CDzP8UWBDfluoVCU89Ns5juag8ffk/ulEQfEN1NakgiSwihy+QEmd2PWBTn4dfGVSV9mYRjPppFdM6kik1WLgMDZfLRmNzZ0MzMZMAPy8gdMmQiM7uBY1v+EnUXfyjKnK7Y28AB9c6oQHPoTGmVQxZjJgkejyOlBPWwVPbNvvzNRPuBaHI8muX2HzjsA9SJowEBXKICinqLSFZ8NDQVBrw2fgDs5MD5vaDHXtrz9t6Ahw6/7nUB240U&lt;/data&gt;
		&lt;data&gt;***LDCNBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwOTI1MDIxMzA4WhcNMTkwOTI1MDIxMzA4WjCBrzEaMBgGCgmSJomT8ixkAQEMCjIzVDNTWlo0WjQxMjAwBgNVBAMMKWlQaG9uZSBEZXZlbG9wZXI6IOS9s+a7qCDnjosgKDN1UdDgQWBBT7im/bw3RlTv0soM/RVB2mmh9e4zAOBgNVHQ8BAf8EBAMCB4AwEwYKKoZIhvdjZAYBAgEB/wQCBQAwDQYJKoZIhvcNAQELBQADggEBACErmsYfmt/qn5yj86poEkDsDWhznabHVn1CJprtzyHbXNcbKJE1pY99ACzSUVW9iGaxXJ9m5dWmZsd+2gxOBthFDq4mSpU50OHQgg9AjjugvsQ+OH1r1qgqcJMPdLN4stJtkAC9Mb/rt3AYA5eEdHOXbhrsE3TXWmWfJzYS9PFyarGcJ9xFAWg76jTtFA6nlzYtl/YyMDS6Z075oMzKG/pRfCI13P4AqRKdx/DBtz4x0Wv59LVMVrXa4bfePLKMBJrBFdiiyCy4k4BIx4weG/Y/8OsEkmWkN0fDWmi4MZjy3I+FCNkv9tUzI/vRvDEiNR7qo5rGRKnAi+X1QbdLYcU=&lt;/data&gt;
		&lt;data&gt;***o0WjQxMjAwBgNVBAMMKWlQaG9uZSBEZXZlbG9wZXI6IOS9s+a7qCDnjosgKDNYTDJNRFdWOUcpMRMwEQYDVQQLDApaRVdKTUhHQ0RCMTswOQYDVQQKDDJTaGFuZ2hhaSBSaXNlbiBFbGVjdHJpYyBQb3dlciBEZXZlbG9wbWVudCBDby4sTHRkLjELMAkGA1UEBhMCVVMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC35nKt/AoSiANJn9e9H96rol/85zSEAjAAMB8GA1UdIwQYMBaAFIgnFwmpthhgi+zruvZHWcVSVKO3MD8GCCsGAQUFBwEBBDMwMTAvBggr1UdJQEB/wQMMAoGCCsGAQUFBwMDMB0GA1UdDgQWBBSIeBiIaX4EyW39H2laObRLnSyWVjAOBgNVHQ8BAf8EBAMCB4AwEwYKKoZIhvdjZAYBAgEB/wQCyETSZ/FOr8EBZBVLmMGXz03x6f2Hpd7QsmoJJM5+6hHu4qgstgXNg0RRsa0B4jScKTMlRxmdZuLjm3plaX+P+yo0ylAnvGWm1sx9mxPTgrDbUg7Rg0n1bhrBtkX47+r8SUz4+E6dHnqZ7x48hZlhv6SFkj4PQ/apeAvITvnLeq7bj586gkpwS30bjmrsqSO8aEnysvyxq6Xx3+seH9Uihmjb7XdnV25mKfbf5ms6sm+HrN6ifrDb0LePX8YAsSH4=&lt;/data&gt;
	&lt;/array&gt;


	&lt;key&gt;Entitlements&lt;/key&gt;      // 权限
	&lt;dict&gt;
		&lt;key&gt;keychain-access-groups&lt;/key&gt;
		&lt;array&gt;
			&lt;string&gt; *** .*&lt;/string&gt;		
		&lt;/array&gt;
		&lt;key&gt;get-task-allow&lt;/key&gt;    // APP是否允许调试
		&lt;true/&gt;
		&lt;key&gt;application-identifier&lt;/key&gt;    // appID
		&lt;string&gt; *** &lt;/string&gt;
		&lt;key&gt;com.apple.developer.associated-domains&lt;/key&gt;
		&lt;string&gt;*&lt;/string&gt;
		&lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
		&lt;string&gt; *** &lt;/string&gt;
		&lt;key&gt;aps-environment&lt;/key&gt;
		&lt;string&gt;development&lt;/string&gt;

	&lt;/dict&gt;
	&lt;key&gt;ExpirationDate&lt;/key&gt;    // 过期时间
	&lt;date&gt;2020-03-05T08:54:06Z&lt;/date&gt;
	&lt;key&gt;Name&lt;/key&gt;
	&lt;string&gt;iOS Team Provisioning Profile: *** &lt;/string&gt;
	&lt;key&gt;ProvisionedDevices&lt;/key&gt;    // 设备列表
	&lt;array&gt;
		&lt;string&gt;476c21e91700a0605a11a***3de7705a&lt;/string&gt;
		&lt;string&gt;98a1263783fb5538ec292f0***9d05690ffb&lt;/string&gt;
		&lt;string&gt;bc9144d7496e5337e1f***cb653dc42e&lt;/string&gt;
		&lt;string&gt;254fbcad0126f989b8980***d1dd8169b6ca&lt;/string&gt;
		&lt;string&gt;349f7aeb300473cc30c28***025d&lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;TeamIdentifier&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt; *** &lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;TeamName&lt;/key&gt;
	&lt;string&gt; *** Co.,Ltd.&lt;/string&gt;
	&lt;key&gt;TimeToLive&lt;/key&gt;
	&lt;integer&gt;365&lt;/integer&gt;
	&lt;key&gt;UUID&lt;/key&gt;    // 描述文件的UUID
	&lt;string&gt; *** &lt;/string&gt;
	&lt;key&gt;Version&lt;/key&gt;
	&lt;integer&gt;1&lt;/integer&gt;
&lt;/dict&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="双层代码签名"><a href="#双层代码签名" class="headerlink" title="双层代码签名"></a>双层代码签名</h4><ul>
<li>请求证书<br>开发过程中，首先Mac电脑（比如Xcode）会自动生成一对公私钥</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6ec3926ede28d14e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公私钥"></p>
<p>图中的证书就是公钥M，专用密钥就是私钥M（也就是我们导出的P12文件）</p>
<p>用一个CSR文件（就是在钥匙串访问中，证书助理，从证书颁发机构中获取的）向苹果申请一个证书，这个CSR文件主要包含了一个公钥文件，还有一些信息，比如邮箱、名字、签名信息、Hash值等等，苹果收到请求后，会用私钥A将公钥M进行签名，以供苹果设备进行验证（用公钥A进行验证）。苹果服务器将公钥M和签名信息打包成证书，并把appID、证书、设备IDs、权限文件等放入描述文件一并返回给Mac电脑，以备Mac电脑用这个描述文件中的证书到iOS设备去验证。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0df7c92d9f6b22ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求证书"></p>
<ul>
<li>生成IPA文件，发送到iOS设备上<br>iOS设备上的APP其实都是文件夹，最重要的是可执行文件MachO和framework，APP签名也就是对它俩进行签名，通过Mac电脑的私钥M对文件进行签名，把这个签名和从苹果申请的描述文件一并放入到APP中。当安装APP时，iOS设备用公钥A来解析描述文件中的证书进行验证证书的有效性，通过之后将证书中的公钥M拿出来，再去验证APP签名的有效性，这样就可以验证当前APP是否是苹果官方允许的。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92f2a337c5fac6e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双层代码签名"></p>
<p>在开发阶段，我们需要频繁的改动程序跑真机，苹果不需要关心这些，所以iOS设备没有对APP的更改进行验证，只是验证证书（公钥M是不是合法的，APP签名的有效性）。这样解决了安装问题，但是如果这样的话，可以在任何一部iOS设备上安装APP，苹果防止开发者滥用，又加了两个限制：</p>
<ol>
<li>要在苹果后台注册过的设备才可以安装</li>
<li>签名只能针对具体的某一个APP进行签名</li>
</ol>
<h4 id="关于APP签名"><a href="#关于APP签名" class="headerlink" title="关于APP签名"></a>关于APP签名</h4><blockquote>
<p>在开发中，编译一个APP后，用本地的私钥M对APP进行签名，同时把从苹果服务器得到的Provisioning Profile文件打包进APP中，文件名为embedded.mobileprovision，把APP安装到iOS设备后，系统进行验证。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-212efe0fca5a83df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看资源文件签名"></p>
<p>查看APP的包内容，里面会有_CodeSignature文件夹（里面的就是资源文件的签名），还有个可执行文件，可以用MachO查看，里面的Code signature就是应用签名。</p>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>签名</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>非对称加密原理</tag>
        <tag>数字签名</tag>
        <tag>代码签名</tag>
        <tag>双层代码签名</tag>
      </tags>
  </entry>
  <entry>
    <title>Runloop底层原理--源码分析</title>
    <url>/2019/06/23/runloop-yuan-ma-fen-xi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7686a91193dd3b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop底层原理"></p>
<h4 id="什么是Runloop？"><a href="#什么是Runloop？" class="headerlink" title="什么是Runloop？"></a>什么是Runloop？</h4><p>Runloop不仅仅是一个运行循环（do-while循环），也是提供了一个入口函数的对象，消息机制处理模式。运行循环从两种不同类型的源接收事件。<br>输入源提供异步事件，通常是来自另一个线程或来自不同应用程序的消息。定时器源提供同步事件，发生在预定时间或重复间隔。<br>两种类型的源都使用特定于应用程序的处理程序例程来处理事件。除了处理输入源之外，Runloop还会生成有关Runloop行为的通知。<br>已注册的运行循环观察器可以接收这些通知并使用它们在线程上执行其他处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-00d3a78c266ae9a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="run loop的结构及来源"></p>
<p>执行代码查看下主运行循环的部分信息：<br></p><pre class="line-numbers language-none"><code class="language-none">CFRunLoopRef mainRunloop = CFRunLoopGetMain();
NSLog(@"%@", mainRunloop);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>打印结果，里面有port源、modes、items等，items有很多实体（CFRunLoopSource，CFRunLoopObserver等），打印省略N行<br><pre class="line-numbers language-none"><code class="language-none">&lt;CFRunLoop 0x6000014c8300 [0x1034faae8]&gt;{wakeup port = 0x2207, stopped = false, ignoreWakeUps = false, 
current mode = kCFRunLoopDefaultMode,
common modes = &lt;CFBasicHash 0x60000268cb40 [0x1034faae8]&gt;{type = mutable set, count = 2,
entries =&gt;
	0 : &lt;CFString 0x1068ca070 [0x1034faae8]&gt;{contents = "UITrackingRunLoopMode"}
	2 : &lt;CFString 0x10350ced8 [0x1034faae8]&gt;{contents = "kCFRunLoopDefaultMode"}
}
,
common mode items = &lt;CFBasicHash 0x600002680ab0 [0x1034faae8]&gt;{type = mutable set, count = 13,
entries =&gt;
	0 : &lt;CFRunLoopSource 0x600001dc4a80 [0x1034faae8]&gt;{signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10b77e2bb)}}
	3 : &lt;CFRunLoopSource 0x600001dc8e40 [0x1034faae8]&gt;{signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;{version = 0, info = 0x600002680840, callout = __handleHIDEventFetcherDrain (0x1060e0842)}}
... // 省略N行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h5><pre class="line-numbers language-none"><code class="language-none">Foundation:NSRunLoop
[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象
[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象

Core Foundation:CFRunLoopRef
CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象
CFRunLoopGetMain(); // 获得主线程的RunLoop对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Runloop的作用："><a href="#Runloop的作用：" class="headerlink" title="Runloop的作用："></a>Runloop的作用：</h4><ol>
<li>Runloop可以保持程序的持续运行；</li>
<li>处理APP中的各种事件（比如触摸，定时器，performSelector）；</li>
<li>节省cup资源、提供程序的性能（需要执行事务就执行，不需要就休眠）；<h4 id="Runloop的应用："><a href="#Runloop的应用：" class="headerlink" title="Runloop的应用："></a>Runloop的应用：</h4></li>
<li>block应用：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></li>
<li>调用timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></li>
<li>响应source0：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></li>
<li>响应source1： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></li>
<li>GCD主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></li>
<li>observer源：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></li>
</ol>
<h4 id="Runloop与线程的关系"><a href="#Runloop与线程的关系" class="headerlink" title="Runloop与线程的关系"></a>Runloop与线程的关系</h4><ul>
<li>Runloop与线程是一一对应的；一个Runloop对应一个核心的线程，Runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。</li>
<li>Runloop是用来管理线程的；当线程的Runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。</li>
<li>Runloop在第一次获取时被创建，在线程结束时被销毁。</li>
<li>对于主线程来说，Runloop在程序一启动就默认创建好了。</li>
<li>对于子线程来说，Runloop是懒加载的。只有当我们使用的时候才会创建，所以在子线程用定时器要注意，确保子线程的Runloop被创建，不让定时器不会回调。</li>
</ul>
<h5 id="Runloop与线程源码分析"><a href="#Runloop与线程源码分析" class="headerlink" title="Runloop与线程源码分析"></a>Runloop与线程源码分析</h5><p>可以先去官方下载源码进行分析；通过主线程获取main<br></p><pre class="line-numbers language-none"><code class="language-none">#if DEPLOYMENT_TARGET_WINDOWS || DEPLOYMENT_TARGET_IPHONESIMULATOR
CF_EXPORT pthread_t _CF_pthread_main_thread_np(void);
#define pthread_main_thread_np() _CF_pthread_main_thread_np()
#endif

CFRunLoopRef CFRunLoopGetMain(void) {
    CHECK_FOR_FORK();
    static CFRunLoopRef __main = NULL; // no retain needed
    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed
    return __main;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>_CFRunLoopGet0内部调用：通过一个全局可变字典CFMutableDictionaryRef，<code>__CFRunLoopCreate(pthread_main_thread_np())</code>创建mainLoop，对CFMutableDictionaryRef进行setValue，pthread_main_thread_np()线程的指针会指向当前的mainLoop，从这里就可以看出，runLoop是基于线程创建的并且runLoop和线程是以key-value的形式一一对应的。当然CFDictionaryGetValue通过当前的__CFRunLoops，关联pthreadPointer(t)的指针，获取到当前的loop，都可以证明runloop和线程是一一对应的关系。<br><pre class="line-numbers language-none"><code class="language-none">__CFSpinLock(&amp;loopsLock);
    if (!__CFRunLoops) {
        __CFSpinUnlock(&amp;loopsLock);
        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
        
        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {
            CFRelease(dict);
        }
        CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&amp;loopsLock);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="Runloop与线程代码实现"><a href="#Runloop与线程代码实现" class="headerlink" title="Runloop与线程代码实现"></a>Runloop与线程代码实现</h5><p>程序启动创建了一个子线程，在子线程内添加了一个定时器timer，并开启子线程的runLoop，开始打印<code>hello word</code>，当点击屏幕时退出子线程停止打印。<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)viewDidLoad {
    [super viewDidLoad];

    // 主运行循环
//     CFRunLoopRef mainRunloop = CFRunLoopGetMain();
//    NSLog(@"%@", mainRunloop);
    
    self.isStopping = NO;
    NSThread *customThread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"%@---%@",[NSThread currentThread],[[NSThread currentThread] name]);
        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
            NSLog(@"hello word");     
            if (self.isStopping) {
                [NSThread exit];
            }
        }];
        [[NSRunLoop currentRunLoop] run];
    }];
    customThread.name = @"customThread";
    [customThread start];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{
    self.isStopping = YES;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>打印结果：<br><pre class="line-numbers language-none"><code class="language-none">&lt;NSThread: 0x600001fb21c0&gt;{number = 3, name = customThread}---customThread
hello word
hello word
hello word
hello word
hello word
hello word
hello word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h6 id="TIP："><a href="#TIP：" class="headerlink" title="TIP："></a>TIP：</h6><p>项目启动，通过isStopping变量来控制当前线程，线程控制runloop，runloop控制timer。注意子线程runloop默认不开启。timer依赖于runloop。</p>
<h4 id="Runloop源码分析"><a href="#Runloop源码分析" class="headerlink" title="Runloop源码分析"></a>Runloop源码分析</h4><pre class="line-numbers language-none"><code class="language-none">CFRunLoopRef runLoop     = CFRunLoopGetCurrent();
CFRunLoopMode loopMode  = CFRunLoopCopyCurrentMode(runLoop);
NSLog(@"mode == %@",loopMode);
CFArrayRef modeArray= CFRunLoopCopyAllModes(runLoop);
NSLog(@"modeArray == %@",modeArray);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="CFRunLoopRef源码分析"><a href="#CFRunLoopRef源码分析" class="headerlink" title="CFRunLoopRef源码分析"></a>CFRunLoopRef源码分析</h5><p>Runloop是利用线程创建的CFRunLoopRef类型，通过源码定位，看到__CFRunLoop是一个结构体，里面包含了_base、_lock、_wakeUpPort(激活port)、_commonModes、_commonModeItems、_modes等等，默认mode为kCFRunLoopDefaultMode类型</p>
<pre class="line-numbers language-none"><code class="language-none">typedef CFStringRef CFRunLoopMode CF_EXTENSIBLE_STRING_ENUM;

typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;

typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef;

typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef;

typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;


struct __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;            /* locked for accessing mode list */
    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp
    Boolean _unused;
    volatile _per_run_data *_perRunData;              // reset for runs of the run loop
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFTypeRef _counterpart;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="CFRunLoopMode源码分析"><a href="#CFRunLoopMode源码分析" class="headerlink" title="CFRunLoopMode源码分析"></a>CFRunLoopMode源码分析</h5><p>一个runLoop可以包含很多种Mode，CFRunLoopMode也是一个结构体，其中包含_sources0、_sources1、_observers、_timers等等</p>
<blockquote>
<p>RunLoop的五种运行模式：</p>
<ol>
<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</li>
</ol>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">typedef struct __CFRunLoopMode *CFRunLoopModeRef;

struct __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;    /* must have the run loop locked before locking this */
    CFStringRef _name;
    Boolean _stopped;
    char _padding[3];
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    CFMutableDictionaryRef _portToV1SourceMap;
    __CFPortSet _portSet;
    CFIndex _observerMask;
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    dispatch_source_t _timerSource;
    dispatch_queue_t _queue;
    Boolean _timerFired; // set to true by the source when a timer has fired
    Boolean _dispatchTimerArmed;
#endif
#if USE_MK_TIMER_TOO
    mach_port_t _timerPort;
    Boolean _mkTimerArmed;
#endif
#if DEPLOYMENT_TARGET_WINDOWS
    DWORD _msgQMask;
    void (*_msgPump)(void);
#endif
    uint64_t _timerSoftDeadline; /* TSR */
    uint64_t _timerHardDeadline; /* TSR */
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中的items通过<code>CFRunLoopAddSource</code>、<code>CFRunLoopAddObserver</code>、<code>CFRunLoopAddTimer</code>来添加CFRunLoopSourceRef、CFRunLoopObserverRef、CFRunLoopTimerRef。</p>
<h5 id="RunLoop-结构"><a href="#RunLoop-结构" class="headerlink" title="RunLoop 结构"></a>RunLoop 结构</h5><p>经过源码，我们发现，CFRunLoop和线程是一一对应的，一个CFRunLoop对应多个CFRunLoopMode，一个CFRunLoopMode对应多个CFRunLoopSource、CFRunLoopObserver、CFRunLoopTimer。</p>
<h4 id="RunLoop和Obsever的关系"><a href="#RunLoop和Obsever的关系" class="headerlink" title="RunLoop和Obsever的关系"></a>RunLoop和Obsever的关系</h4><p>Obsever就是观察者，能够监听RunLoop的状态改变，创建这个观察者，再通过<code>CFRunLoopAddObserver</code>把观察者添加到runloop中，<code>runLoopObserverCallBack</code>来监听状态的变化。<br>CFRunLoopObserverRef：<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)cfObseverDemo{
    
    CFRunLoopObserverContext context = {
        0,
        ((__bridge void *)self),
        NULL,
        NULL,
        NULL
    };
    CFRunLoopRef rlp = CFRunLoopGetCurrent();
    /**
     参数一:用于分配对象的内存
     参数二:你关注的事件
          kCFRunLoopEntry=(1&lt;&lt;0),
     &nbsp; &nbsp; &nbsp;kCFRunLoopBeforeTimers=(1&lt;&lt;1),
     &nbsp; &nbsp; &nbsp;kCFRunLoopBeforeSources=(1&lt;&lt;2),
     &nbsp; &nbsp; &nbsp;kCFRunLoopBeforeWaiting=(1&lt;&lt;5),
     &nbsp; &nbsp; &nbsp;kCFRunLoopAfterWaiting=(1&lt;&lt;6),
     &nbsp; &nbsp; &nbsp;kCFRunLoopExit=(1&lt;&lt;7),
     &nbsp; &nbsp; &nbsp;kCFRunLoopAllActivities=0x0FFFFFFFU
     参数三:CFRunLoopObserver是否循环调用
     参数四:CFRunLoopObserver的优先级 当在Runloop同一运行阶段中有多个CFRunLoopObserver 正常情况下使用0
     参数五:回调,比如触发事件,我就会来到这里
     参数六:上下文记录信息
     */
    CFRunLoopObserverRef observerRef = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, runLoopObserverCallBack, &amp;context);
    CFRunLoopAddObserver(rlp, observerRef, kCFRunLoopDefaultMode);
}

void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){
    NSLog(@"%lu-%@",activity,info);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://upload-images.jianshu.io/upload_images/5741330-aa756fcfc4344e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="run loop"><p></p>
<p>进入源码，runloop就是一个do-while循环，再次进入<code>CFRunLoopRunSpecific</code>方法，如果监听到有进入状态或者退出状态改变则执行<code>__CFRunLoopDoObservers</code>，其余的进入<code>__CFRunLoopRun</code>方法。<br></p><pre class="line-numbers language-none"><code class="language-none">void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
    do {
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        CHECK_FOR_FORK();
    } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}

// -----------------------------------

SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    __CFRunLoopLock(rl);
    // 根据modeName找到本次运行的mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    // 如果没找到 || mode中没有注册任何事件，则就此停止，不进入循环
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) {
        Boolean did = false;
        if (currentMode) __CFRunLoopModeUnlock(currentMode);
        __CFRunLoopUnlock(rl);
        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    // 取上一次运行的mode
    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;
    // 如果本次mode和上次的mode一致
    rl-&gt;_currentMode = currentMode;
    // 初始化一个result为kCFRunLoopRunFinished
    int32_t result = kCFRunLoopRunFinished;
    
    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    // 通知 Observers: RunLoop 即将进入 loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    // 通知 Observers: RunLoop 即将退出。
    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
   
    __CFRunLoopModeUnlock(currentMode);
    __CFRunLoopPopPerRunData(rl, previousPerRun);
    rl-&gt;_currentMode = previousMode;
    __CFRunLoopUnlock(rl);
    return result;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>进入<code>__CFRunLoopRun</code>方法，其内部有Observers监听timer、source0、source1。<br><pre class="line-numbers language-none"><code class="language-none">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    
    //获取系统启动后的CPU运行时间，用于控制超时时间
    uint64_t startTSR = mach_absolute_time();
    
    // 判断当前runloop的状态是否关闭
    if (__CFRunLoopIsStopped(rl)) {
        __CFRunLoopUnsetStopped(rl);
        return kCFRunLoopRunStopped;
    } else if (rlm-&gt;_stopped) {
        return kCFRunLoopRunStopped;
        rlm-&gt;_stopped = false;
    }
    
    //mach端口，在内核中，消息在端口之间传递。 初始为0
    mach_port_name_t dispatchPort = MACH_PORT_NULL;
    //判断是否为主线程
    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));
    //如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口
    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();
    
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    mach_port_name_t modeQueuePort = MACH_PORT_NULL;
    if (rlm-&gt;_queue) {
        //mode赋值为dispatch端口_dispatch_runloop_root_queue_perform_4CF
        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);
        if (!modeQueuePort) {
            CRASH("Unable to get port for run loop mode queue (%d)", -1);
        }
    }
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>__CFRunLoopRun</code>部分源码，接下来进入do-while循环，先初始化一个存放内核消息的缓冲池，获取所有需要监听的port，设置RunLoop为可以被唤醒状态，判断是否有timer、source0、source1回调。如果有timer则通知 Observers: RunLoop 即将触发 Timer 回调。如果有source0则通知 Observers: RunLoop 即将触发 Source0 (非port) 回调，执行被加入的block。RunLoop 触发 Source0 (非port) 回调，再执行被加入的block。如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。例如一个Timer 到时间了，触发这个Timer的回调。处理完后再次进入<code>__CFArmNextTimerInMode</code>查看是否有其他的timer。如果没有事务需要处理则通知 Observers: RunLoop 的线程即将进入休眠(sleep)，此时会进入一个内循环，线程进入休眠状态mach_msg_trap（比如我们在断点调试的时候），直到收到新消息才跳出该循环，继续执行run loop。比如监听到了事务基于 port 的Source 的事件、Timer 到时间了、RunLoop 自身的超时时间到了或者被其他什么调用者手动唤醒则唤醒。<br><pre class="line-numbers language-none"><code class="language-none">//标志位默认为true
    Boolean didDispatchPortLastTime = true;
    //记录最后runloop状态，用于return
    int32_t retVal = 0;
    do {
        //初始化一个存放内核消息的缓冲池
        uint8_t msg_buffer[3 * 1024];
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
        mach_msg_header_t *msg = NULL;
        mach_port_t livePort = MACH_PORT_NULL;
#elif DEPLOYMENT_TARGET_WINDOWS
        HANDLE livePort = NULL;
        Boolean windowsMessageReceived = false;
#endif
        //取所有需要监听的port
        __CFPortSet waitSet = rlm-&gt;_portSet;
        
        //设置RunLoop为可以被唤醒状态
        __CFRunLoopUnsetIgnoreWakeUps(rl);
        
        /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
        
        /// 执行被加入的block
        __CFRunLoopDoBlocks(rl, rlm);
        /// 4. RunLoop 触发 Source0 (非port) 回调。
        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        if (sourceHandledThisLoop) {
            /// 执行被加入的block
            __CFRunLoopDoBlocks(rl, rlm);
        }
        
        //如果没有Sources0事件处理 并且 没有超时，poll为false
        //如果有Sources0事件处理 或者 超时，poll都为true
        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);
        //第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true
        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
            //从缓冲区读取消息
            msg = (mach_msg_header_t *)msg_buffer;
            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) {
                //如果接收到了消息的话，前往第9步开始处理msg
                goto handle_msg;
            }
#elif DEPLOYMENT_TARGET_WINDOWS
            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {
                goto handle_msg;
            }
#endif
        }
// ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="RunLoop和Timer的关系"><a href="#RunLoop和Timer的关系" class="headerlink" title="RunLoop和Timer的关系"></a>RunLoop和Timer的关系</h4><p>首先timer要加入到runLoop的其中一个mode中，也就是加入到当前mode的items中；在runLoopRun的时候，执行doBlock，然后while循环items，block调用。<br>NSTimer：<br></p><pre class="line-numbers language-none"><code class="language-none">NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"hell timer -- %@",[[NSRunLoop currentRunLoop] currentMode]);
}];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>timer的底层CFRunLoopTimerRef：<br><pre class="line-numbers language-none"><code class="language-none">- (void)cfTimerDemo{
    CFRunLoopTimerContext context = {
        0,
        ((__bridge void *)self),
        NULL,
        NULL,
        NULL
    };
    CFRunLoopRef rlp = CFRunLoopGetCurrent();
    /**
     参数一:用于分配对象的内存
     参数二:在什么是触发 (距离现在)
     参数三:每隔多少时间触发一次
     参数四:未来参数
     参数五:CFRunLoopObserver的优先级 当在Runloop同一运行阶段中有多个CFRunLoopObserver 正常情况下使用0
     参数六:回调,比如触发事件,就会执行
     参数七:上下文记录信息
     */
    CFRunLoopTimerRef timerRef = CFRunLoopTimerCreate(kCFAllocatorDefault, 0, 1, 0, 0, runLoopTimerCallBack, &amp;context);
    CFRunLoopAddTimer(rlp, timerRef, kCFRunLoopDefaultMode);

}

void runLoopTimerCallBack(CFRunLoopTimerRef timer, void *info){
    NSLog(@"%@---%@",timer,info);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们再次查找RunLoop的addTimer方法<code>CFRunLoopAddTimer</code>（当然也有AddObserver、AddSource等），先判断kCFRunLoopCommonModes是否相同，如果不是则进行查找，其中<code>CFSetAddValue</code>把CFRunLoopTimerRef对象保存在items中，<code>CFSetApplyFunction</code>再把刚加进来的item储存到commonModes中。<br><pre class="line-numbers language-none"><code class="language-none">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return;
    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;
    __CFRunLoopLock(rl);
    if (modeName == kCFRunLoopCommonModes) {
        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
        if (NULL == rl-&gt;_commonModeItems) {
            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
        }
        CFSetAddValue(rl-&gt;_commonModeItems, rlt);
        if (NULL != set) {
            CFTypeRef context[2] = {rl, rlt};
            /* add new item to all common-modes */
            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);
            CFRelease(set);
        } else {
        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
    // ...省略N行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>把item添加到modes中后，<code>__CFRunLoopRun</code>方法有个重要的方法<code>CFRunLoopDoBlocks</code>，rl是runLoop，rlm是runLoopMode，把runLoopMode传给runLoop中，检查将执行哪个事务<br><pre class="line-numbers language-none"><code class="language-none">__CFRunLoopDoBlocks(rl, rlm);   

// -----------------------------------

static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) { // Call with rl and rlm locked
    if (!rl-&gt;_blocks_head) return false;
    if (!rlm || !rlm-&gt;_name) return false;
    Boolean did = false;
    struct _block_item *head = rl-&gt;_blocks_head;
    struct _block_item *tail = rl-&gt;_blocks_tail;
    rl-&gt;_blocks_head = NULL;
    rl-&gt;_blocks_tail = NULL;
    CFSetRef commonModes = rl-&gt;_commonModes;
    CFStringRef curMode = rlm-&gt;_name;
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    struct _block_item *prev = NULL;
    struct _block_item *item = head;
    while (item) {
        struct _block_item *curr = item;
        item = item-&gt;_next;
        Boolean doit = false;
        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) {
            doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));
        } else {
            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));
        }
        if (!doit) prev = curr;
        if (doit) {
            if (prev) prev-&gt;_next = item;
            if (curr == head) head = item;
            if (curr == tail) tail = prev;
            void (^block)(void) = curr-&gt;_block;
            CFRelease(curr-&gt;_mode);
            free(curr);
            if (doit) {
                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
                did = true;
            }
            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc
        }
    }
    __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);
    if (head) {
        tail-&gt;_next = rl-&gt;_blocks_head;
        rl-&gt;_blocks_head = head;
        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;
    }
    return did;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>CFRunLoopDoBlocks中通过链表遍历item， 判断当前的runLoopMode和加入的runLoopMode或者CFRunLoopCommonModes是否相同，执行<code>doit</code>，进入`</strong>CFRUNLOOP<em>IS<em>CALLING<em>OUT<em>TO<em>A<em>BLOCK</em></em> <code>,执行block
<pre class="line-numbers language-none"><code class="language-none">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__() __attribute__((noinline));
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(void (^block)(void)) {
    if (block) {
        block();
    }
    getpid(); // thwart tail-call optimization
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
举个例子，把定时器添加到RunLoop中，timer加入的runLoopMode类型</code>NSDefaultRunLoopMode<code>，和当前runLoopMode的类型(runLoopMode可以切换，比如默认kCFRunLoopDefaultMode类型，滑动的时候UITrackingRunLoopMode，启动时UIInitializationRunLoopMode)比较，默认情况下执行timer，当页面滑动的时候，当前runLoopMode的类型自动切换到</code>UITrackingRunLoopMode<code>，因此timer失效，停止滑动时，当前runLoopMode的类型切换到</code>NSDefaultRunLoopMode`，timer恢复。当然了，如果我们把timer加入到UITrackingRunLoopMode模式时，那么只有在滑动的时候才执行。如果想在默认情况下和滑动的时候都执行，就要把timer加入到占位模式NSRunLoopCommonModes中，NSRunLoopCommonModes相当于Mode集合，这样就可以在两个模式下都执行了，</em></em>这就是为什么定时器不准的原因与解决办法</em></em>。<p></p>
<h4 id="RunLoop和Source的关系"><a href="#RunLoop和Source的关系" class="headerlink" title="RunLoop和Source的关系"></a>RunLoop和Source的关系</h4><p>__CFRunLoopSource也是一个结构体，其中有一个union属性，它包含了version0和version1，也就是Source0（CFRunLoopSourceContext）和Source1（CFRunLoopSourceContext1）。进入源码<br></p><pre class="line-numbers language-none"><code class="language-none">struct __CFRunLoopSource {
    CFRuntimeBase _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    CFIndex _order;            /* immutable */
    CFMutableBagRef _runLoops;
    union {
        CFRunLoopSourceContext version0;    /* immutable, except invalidation */
        CFRunLoopSourceContext1 version1;    /* immutable, except invalidation */
    } _context;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="Source0分析"><a href="#Source0分析" class="headerlink" title="Source0分析"></a>Source0分析</h5><p>Source0是用来处理APP内部事件、APP自己负责管理，比如UIevent。<br><strong>调用底层：</strong>因为source0只包含一个回调（函数指针）它并不能主动触发事件；CFRunLoopSourceSignal（source）将这个事件标记为待处理；CFRunLoopWakeUp来唤醒runloop，让他处理事件。首先创建一个Source0并添加到当前的runLoop中，执行信号，标记待处理CFRunLoopSourceSignal，再唤醒runloop去处理CFRunLoopWakeUp，通过<code>CFRunLoopRemoveSource</code>来取消移除源，CFRelease(rlp)。打印结果会显示<code>准备执行</code>和<code>取消了,终止了!!!</code>，如果注释掉<code>CFRunLoopRemoveSource</code>，则会打印<code>准备执行</code>和<code>执行啦</code>。<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)source0Demo{
    
    CFRunLoopSourceContext context = {
        0,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        schedule,
        cancel,
        perform,
    };
    /**
     
     参数一:传递NULL或kCFAllocatorDefault以使用当前默认分配器。
     参数二:优先级索引，指示处理运行循环源的顺序。这里传0为了的就是自主回调
     参数三:为运行循环源保存上下文信息的结构
     */
    CFRunLoopSourceRef source0 = CFRunLoopSourceCreate(CFAllocatorGetDefault(), 0, &amp;context);
    CFRunLoopRef rlp = CFRunLoopGetCurrent();
    // source --&gt; runloop 指定了mode  那么此时我们source就进入待绪状态
    CFRunLoopAddSource(rlp, source0, kCFRunLoopDefaultMode);
    // 一个执行信号
    CFRunLoopSourceSignal(source0);
    // 唤醒 run loop 防止沉睡状态
    CFRunLoopWakeUp(rlp);
    // 取消 移除
    CFRunLoopRemoveSource(rlp, source0, kCFRunLoopDefaultMode);
    CFRelease(rlp);
}

void schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode){
    NSLog(@"准备执行");
}

void perform(void *info){
    NSLog(@"执行啦");
}

void cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode){
    NSLog(@"取消了,终止了!!!");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="Source1分析"><a href="#Source1分析" class="headerlink" title="Source1分析"></a>Source1分析</h5><p>Source1被用于通过内核和其他线程相互发送消息。<br><strong>调用底层：</strong>Source1包含一个 mach_port和一个回调（函数指针）<br>当然了，线程间的通讯除了可以通过以下方式：<br></p><pre class="line-numbers language-none"><code class="language-none">// 主线 -- 子线程
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"%@", [NSThread currentThread]); // 3

        NSString *str;
        dispatch_async(dispatch_get_main_queue(), ^{
            // 1
            NSLog(@"%@", [NSThread currentThread]);

        });
    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>还可以通过更加底层、更加接近内核的NSPort方式，NSPort是source1类型，通过addPort添加到runLoop中去。再添加子线程，子线程中再加入port。<br><pre class="line-numbers language-none"><code class="language-none">- (void)setupPort{
    
    self.mainThreadPort = [NSPort port];
    self.mainThreadPort.delegate = self;
    // port - source1 -- runloop
    [[NSRunLoop currentRunLoop] addPort:self.mainThreadPort forMode:NSDefaultRunLoopMode];

    [self task];
}

- (void) task {
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
        self.subThreadPort = [NSPort port];
        self.subThreadPort.delegate = self;
        
        [[NSRunLoop currentRunLoop] addPort:self.subThreadPort forMode:NSDefaultRunLoopMode];
        [[NSRunLoop currentRunLoop] run];
    }];
    
    [thread start];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<p>子线程给主线程发送消息响应。<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    
    NSMutableArray* components = [NSMutableArray array];
    NSData* data = [@"hello" dataUsingEncoding:NSUTF8StringEncoding];
    [components addObject:data];
    
    [self.subThreadPort sendBeforeDate:[NSDate date] components:components from:self.mainThreadPort reserved:0];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当NSPort对象接收到端口消息时，会调起<code>handlePortMessage</code>，<strong>官方文档如下解释：</strong><p></p>
<blockquote>
<p>When an <code>NSPort</code> object receives a port message, it forwards the message to its delegate in a <a href="apple-reference-documentation://hcZ8Ot65Ji"><code>handle&lt;wbr&gt;Mach&lt;wbr&gt;Message:</code></a> or <a href="apple-reference-documentation://hcoGVv2jBt"><code>handle&lt;wbr&gt;Port&lt;wbr&gt;Message:</code></a> message. The delegate should implement only one of these methods to process the incoming message in whatever form desired. <a href="apple-reference-documentation://hcZ8Ot65Ji"><code>handle&lt;wbr&gt;Mach&lt;wbr&gt;Message:</code></a> provides a message as a raw Mach message beginning with a <code>msg_header_t</code> structure. <a href="apple-reference-documentation://hcoGVv2jBt"><code>handle&lt;wbr&gt;Port&lt;wbr&gt;Message:</code></a> provides a message as an <a href="apple-reference-documentation://hcI7iWzk8C"><code>NSPort&lt;wbr&gt;Message</code></a> object, which is an object-oriented wrapper for a Mach message. If a delegate has not been set, the <code>NSPort</code> object handles the message itself.</p>
</blockquote>
<p>端口接收到消息后会打印message内部属性：<code>localPort</code>、<code>components</code>、<code>remotePort</code>等，睡眠一秒后，主线程再向子线程发送消息。<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)handlePortMessage:(id)message {
    NSLog(@"%@", [NSThread currentThread]); // 3 1

    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([message class], &amp;count);
    for (int i = 0; i&lt;count; i++) {
        
        NSString *name = [NSString stringWithUTF8String:ivar_getName(ivars[i])];
        NSLog(@"%@",name);
    }
    
    sleep(1);
    if (![[NSThread currentThread] isMainThread]) {

        NSMutableArray* components = [NSMutableArray array];
        NSData* data = [@"woard" dataUsingEncoding:NSUTF8StringEncoding];
        [components addObject:data];

        [self.mainThreadPort sendBeforeDate:[NSDate date] components:components from:self.subThreadPort reserved:0];
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该文章为记录本人的学习路程，希望能够帮助大家！！！<p></p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>底层原理</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
</search>
