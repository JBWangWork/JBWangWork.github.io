<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>了解Base64编码解码</title>
    <url>/2019/01/05/base64/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-161cc8afdcaec6f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="了解Base64编码解码"></p>
<blockquote>
<p>我们经常说Base64，那Base64到底是什么呢？<br><a href="https://zh.wikipedia.org/zh-hans/Base64"><strong>Base64</strong></a>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制数据</a>的表示方法，常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE" title="数据">数据</a>的场合，表示、传输、存储一些二进制数据，会将不便于查看的二进制数据用Base64进行表示。所以Bsea64经常用于密码学中，因为密码学通常用二进制进行加密，加密的结果用Base64编码来表示并传输。</p>
</blockquote>
<p>我们想了解Base64，其实看下面的Base64索引表就可以了。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-f9b1a93c393d27f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Base64索引表"></p>
<p>在Base64中的可打印字符包括<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D" title="拉丁字母">字母</a><code>A-Z</code>、<code>a-z</code>、<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97" title="数字">数字</a><code>0-9</code>共有62个字符，加上<code>+</code>、<code>/</code>共64个字符，实际上还有一个字符<code>=</code>来作为后缀。比如：编码Man<br><img src="https://upload-images.jianshu.io/upload_images/5741330-578423235d58ea16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编码Man"></p>
<p>当Base64对一个二进制数据进行编码时，每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>为一个单元，对应某个可打印字符。3个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82" title="字节">字节</a>有24个位元，对应于4个Base64单元，即3个字节可由4个可打印字符来表示，所以最少要24个比特位。如果不足24位，就在后面补0，后面补的0就会用<code>=</code>来表示，所以<code>=</code>也只会在最后面。</p>
<h4 id="终端演示Base64编码"><a href="#终端演示Base64编码" class="headerlink" title="终端演示Base64编码"></a>终端演示Base64编码</h4><pre class="line-numbers language-none"><code class="language-none">// 通过Base64将111图片进行编码，生成111.txt文件
$ base64 111.png -o 111.txt
// 对111.txt文件解码，生成222.png
$ base64 111.txt -o 222.png -D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-a811b9c976ba1fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Base64编码"></p>
<p>左侧的图片是原始文件，通过Base64编码后输出右侧111.txt文件，再对111.txt文件解码还原。</p>
<h4 id="代码演示Base64编码"><a href="#代码演示Base64编码" class="headerlink" title="代码演示Base64编码"></a>代码演示Base64编码</h4><p>Base64也是在iOS7以后出现的，接下来用代码简单操作一下<br></p><pre class="line-numbers language-none"><code class="language-none">//
//  ViewController.m
//  Base64
//
//  Created by Vincent on 2019/1/14.
//  Copyright © 2019 Vincent. All rights reserved.
//

#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

- (NSString *)getBase64Encode:(NSString *)encodeStr {
    // 将传进来的string转成NSData，再进行Base64编码
    NSData *data = [encodeStr dataUsingEncoding:NSUTF8StringEncoding];
    return [data base64EncodedStringWithOptions:0];
}

- (NSString *)getBase64Decode:(NSString *)decodeStr {
     // 由于传过来的是Base64编码字符串，则不需要先转二进制再解码，可以直接通过NSData初始化方法解码
    NSData *data = [[NSData alloc] initWithBase64EncodedString:decodeStr options:0];
    // 将data转成string
    return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    NSLog(@"----编码:%@", [self getBase64Encode:@"abc"]);
    NSLog(@"####解码:%@", [self getBase64Decode:[self getBase64Encode:@"abc"]]);
}

@end
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<ul>
<li>打印结果<pre class="line-numbers language-none"><code class="language-none">----编码:YWJj
####解码:abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>终端验证<pre class="line-numbers language-none"><code class="language-none">// 通过Base64将abc进行编码
$  echo -n abc | base64
YWJj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
验证通过！！！但是通过Base64编码，我们会发现编码结果会变大1/3。<br>该文章为记录本人的学习路程，希望能够帮助大家！！！</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密算法原理--OpenSSL演示、iOS代码运用及CCCrypt安全隐患</title>
    <url>/2019/01/13/cccrypt/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6fba0bae30b20faa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对称加密算法原理"></p>
<p>之前介绍了非对称加密算法，这篇文章介绍一下在非对称加密算法出现之前的对称加密算法，常见的对称加密算法、终端演示OpenSSL和iOS代码运用以及CCCrypt的安全隐患等。</p>
<blockquote>
<p>对称加密算法：明文通过密钥加密得到密文，密文再通过这个密钥解密得到明文。所以在业务逻辑上相对没有非对称加密RSA的安全性高。</p>
</blockquote>
<h4 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h4><ul>
<li>DES<br>数据加密标准，但由于强度不高，暴力破解难度不是很高，所以用的很少。</li>
<li>3DES<br>使用3个密钥，对数据进行三次加密，强度增强。虽然强度相对DES有所提高，但是对称加密算法密钥的保存就很难，3DES的3个密钥更麻烦，所以3DES也没有被广泛使用。</li>
<li>AES<br>高级密码标准，加密强度非常高，被广泛使用，美国安全局和苹果钥匙串访问都是用了AES加密算法。</li>
</ul>
<h4 id="常用的两种加密模式"><a href="#常用的两种加密模式" class="headerlink" title="常用的两种加密模式"></a>常用的两种加密模式</h4><ul>
<li>ECB（Electronic Code Book）：电子密码本模式（每一块数据独立加密）<br>最基本的加密模式，也就是通常理解的加密，相同的明文将永远加密成相同的密文，无初始向量，容易受到密码本重放攻击，一般情况下很少用。</li>
<li>CBC（Cipher Block Chaining）：密码分组链接模式（使用一个密钥和一个初始化向量[IV]对数据执行加密。每一块数据加密都依赖上一块数据，有效的保证数据的完整性）<br>明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。CBC可以有效的保证密文的完整性，如果一个数据块在传递时丢失或改变，后面的数据将无法正常解密。</li>
</ul>
<p>当然了，除了对称加密和非对称加密外，我们肯定还听说过Hash</p>
<h4 id="Hash概述"><a href="#Hash概述" class="headerlink" title="Hash概述"></a>Hash概述</h4><blockquote>
<p>Hash：一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</p>
</blockquote>
<p>之前介绍了RSA加密算法，在RSA算法之后也衍生出很多加密算法，典型的算法就有HASH函数（也称之为散列函数，严格意义上不算是加密算法，只不过是和加密一起用），还有在RSA出现之前的对称加密算法，这些算法都是公开的。</p>
<h4 id="Hash特点"><a href="#Hash特点" class="headerlink" title="Hash特点"></a>Hash特点</h4><p>算法是公开的<br>相同的数据加密结果不变<br>不同的数据加密结果定长（MD5得到的结果默认是128位二进制，一般用16进制的32个字符来标识）<br>不可逆<br>信息摘要，信息“指纹”，用来做数据识别的</p>
<h4 id="HASH用途"><a href="#HASH用途" class="headerlink" title="HASH用途"></a>HASH用途</h4><p>密码加密：服务器不需要知道用户真实密码，只需要匹配HASH值<br>搜索引擎<br>版权<br>数字签名</p>
<h4 id="OpenSSL演示ECB和CBC的区别"><a href="#OpenSSL演示ECB和CBC的区别" class="headerlink" title="OpenSSL演示ECB和CBC的区别"></a>OpenSSL演示ECB和CBC的区别</h4><ul>
<li><p>OpenSSL演示ECB模式加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先创建一个待加密的message.txt文件，编辑内容
$ vi message.txt
$ cat message.txt
  Hello vincent!!!
// enc -des-ecb是对称加密算法DES的ECB模式，-K是密钥，616263就是ASCII码“abc”，-nosalt不加盐（OpenSSL默认会加盐），输出msg.bin
$ openssl enc -des-ecb -K 616263 -nosalt -in message.txt -out msg.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这时在文件夹内会多出一个加密过后的二进制文件msg.bin，修改message.txt文件的内容，再次进行加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先修改message.txt的内容，vincent-&gt;Vincent
$ vi message.txt
$ cat message.txt
  Hello Vincent!!!
// 再次对message.txt进行同样的方式加密，输出msg1.bin
$ openssl enc -des-ecb -K 616263 -nosalt -in message.txt -out msg1.bin
// 查看下msg.bin和msg1.bin有什么不同
$ xxd msg.bin
00000000: 6d87 4097 d383 0bda a5bc d168 de16 688d  m.@........h..h.
00000010: b8db 0794 f9ed eca9
$ xxd msg1.bin
00000000: 20e2 8361 50a7 16a0 a5bc d168 de16 688d   ..aP......h..h.
00000010: b8db 0794 f9ed eca9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们会发现，修改message.txt内容后ECB模式加密的结果只是修改部分不同，前后加密结果不变</p>
</li>
<li><p>OpenSSL演示CBC模式加密</p>
<pre class="line-numbers language-none"><code class="language-none">// 先编辑message.txt的内容
$ vi message.txt
$ cat message.txt
  Hello vincent!!!
// 再次对message.txt进行CBC方式加密，相对ECB模式除了修改-des-cbc，还会多一个iv参数，iv是初始化向量，输出msg2.bin
$ openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -in message.txt -out msg2.bin
// 再次编辑message.txt的内容，vincent-&gt;Vincent
$ vi message.txt
$ cat message.txt
  Hello Vincent!!!
// 对修改后的文件加密，输出msg3.bin
$ openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -in message.txt -out msg3.bin
// 查看下msg2.bin和msg3.bin有什么不同
$ xxd msg2.bin
00000000: d647 a33b 0389 dea5 3c81 02c9 ec05 44dd  .G.;....&lt;.....D.
00000010: 467c a581 ab1a 415a
$ xxd msg3.bin
00000000: 9882 c1b6 3186 b465 b3be d08a 5ad5 2fd1  ....1..e....Z./.
00000010: 6032 add7 bdb2 07da                      `2......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经多次测试发现，修改message.txt内容后CBC模式加密的结果是修改部分不同以及后面的加密结果也会变化</p>
</li>
<li>终端测试指令<blockquote>
<p>  加密过程：先加密，再base64编码<br>   解密过程：先base64解码，再解密</p>
<pre class="line-numbers language-none"><code class="language-none">//  DES(ECB)加密
$ echo -n hello | openssl enc -des-ecb -K 616263 -nosalt | base64
 
// DES(CBC)加密
$ echo -n hello | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt | base64

//  AES(ECB)加密 128位
$ echo -n hello | openssl enc -aes-128-ecb -K 616263 -nosalt | base64
 
 //  AES(CBC)加密
$ echo -n hello | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 
//  DES(ECB)解密  base64 -D进行解码成二进制 -d解密
$ echo -n HQr0Oij2kbo= | base64 -D | openssl enc -des-ecb -K 616263 -nosalt -d

//  DES(CBC)解密
$ echo -n alvrvb3Gz88= | base64 -D | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -d

//  AES(ECB)解密
$ echo -n d1QG4T2tivoi0Kiu3NEmZQ== | base64 -D | openssl enc -aes-128-ecb -K 616263 -nosalt -d

//  AES(CBC)解密
$ echo -n u3W/N816uzFpcg6pZ+kbdg== | base64 -D | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="对称加密算法代码演示"><a href="#对称加密算法代码演示" class="headerlink" title="对称加密算法代码演示"></a>对称加密算法代码演示</h4><pre class="line-numbers language-none"><code class="language-none">// AES加密、ECB模式对“hello vincent!!!”进行加密
    NSString *ECBEncryptStr = [[EncryptionTools sharedEncryptionTools] encryptString:@"hello vincent!!!" keyString:@"abc" iv:nil];
    NSLog(@"%@", ECBEncryptStr);
    // 解密
    NSString *ECBDecrypt = [[EncryptionTools sharedEncryptionTools] decryptString:ECBEncryptStr keyString:@"abc" iv:nil];
    NSLog(@"%@", ECBDecrypt);
    
    // 一个数组，和前面一样有8个数据
    uint8_t iv[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    // 把数组包装才二进制NSdata 把数组的指针和长度传进去
    NSData *ivData = [NSData dataWithBytes:iv length:sizeof(iv)];
    // AES加密、CBC模式
    NSString *CBCEncryptStr = [[EncryptionTools sharedEncryptionTools] encryptString:@"hello vincent!!!" keyString:@"abc" iv:ivData];
    NSLog(@"%@", CBCEncryptStr);
    // 解密
    NSString *CBCDecrypt = [[EncryptionTools sharedEncryptionTools] decryptString:CBCEncryptStr keyString:@"abc" iv:ivData];
    NSLog(@"%@", CBCDecrypt);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>打印结果：</p>
<pre class="line-numbers language-none"><code class="language-none">LzWe4b6VMKHECZTg5GEoDvOJyUo3lvcCucS987KliFw=
hello vincent!!!
Vo04z90TAfQX07onyrvCie1SnRpsbHKMkYnaNhcEPP0=
hello vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然将加密和解密封装成了两个方法，但是苹果内部加密和解密都是用的一个函数。先看下其中封装的一个方法内部实现</p>
<pre class="line-numbers language-none"><code class="language-none">// 加密字符串并返回base64编码字符串
- (NSString *)encryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv {
    
    // 设置秘钥 将keyString转成二进制
    NSData *keyData = [keyString dataUsingEncoding:NSUTF8StringEncoding];
    uint8_t cKey[self.keySize];
    bzero(cKey, sizeof(cKey));
    [keyData getBytes:cKey length:self.keySize];
    
    // 设置iv
    uint8_t cIv[self.blockSize];
    bzero(cIv, self.blockSize);
    int option = 0;
    if (iv) {
        [iv getBytes:cIv length:self.blockSize];
        option = kCCOptionPKCS7Padding; // CBC加密
    } else {
        option = kCCOptionPKCS7Padding | kCCOptionECBMode;  // ECB加密
    }
    
    // 设置输出缓冲区 将原始数据转成二进制，并根据所使用的加密方式设置缓冲区
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    size_t bufferSize = [data length] + self.blockSize;
    void *buffer = malloc(bufferSize);
    
    // 开始加密
    size_t encryptedSize = 0;
    //加密解密都是它 -- CCCrypt
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                          self.algorithm,
                                          option,
                                          cKey,
                                          self.keySize,
                                          cIv,
                                          [data bytes],
                                          [data length],
                                          buffer,
                                          bufferSize,
                                          &amp;encryptedSize);
    
    NSData *result = nil;
    if (cryptStatus == kCCSuccess) {
        result = [NSData dataWithBytesNoCopy:buffer length:encryptedSize];
    } else {
        free(buffer);
        NSLog(@"[错误] 加密失败|状态编码: %d", cryptStatus);
    }
    
    return [result base64EncodedStringWithOptions:0];
}

// 解密字符串
- (NSString *)decryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv {
    
    // 设置秘钥
    NSData *keyData = [keyString dataUsingEncoding:NSUTF8StringEncoding];
    uint8_t cKey[self.keySize];
    bzero(cKey, sizeof(cKey));
    [keyData getBytes:cKey length:self.keySize];
    
    // 设置iv
    uint8_t cIv[self.blockSize];
    bzero(cIv, self.blockSize);
    int option = 0;
    if (iv) {
        [iv getBytes:cIv length:self.blockSize];
        option = kCCOptionPKCS7Padding;
    } else {
        option = kCCOptionPKCS7Padding | kCCOptionECBMode;
    }
    
    // 设置输出缓冲区
    NSData *data = [[NSData alloc] initWithBase64EncodedString:string options:0];
    size_t bufferSize = [data length] + self.blockSize;
    void *buffer = malloc(bufferSize);
    
    // 开始解密
    size_t decryptedSize = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,
                                          self.algorithm,
                                          option,
                                          cKey,
                                          self.keySize,
                                          cIv,
                                          [data bytes],
                                          [data length],
                                          buffer,
                                          bufferSize,
                                          &amp;decryptedSize);
    
    NSData *result = nil;
    if (cryptStatus == kCCSuccess) {
        result = [NSData dataWithBytesNoCopy:buffer length:decryptedSize];
    } else {
        free(buffer);
        NSLog(@"[错误] 解密失败|状态编码: %d", cryptStatus);
    }
    
    return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码已加入相应的注释，就不解释代码了。我们会发现苹果内部加密和解密都是用<code>CCCryptorStatus CCCrypt(
  CCOperation op, 
  CCAlgorithm alg, 
  CCOptions options, 
  const void *key,
  size_t keyLength,
  const void *iv, 
  const void *dataIn, 
  size_t dataInLength,
  void *dataOut, 
  size_t dataOutAvailable,
  size_t *dataOutMoved)</code>，这个函数是对称加密算法的核心函数。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-55512cbb2b8544e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CCCrypt函数"></p>
</blockquote>
</li>
</ul>
<p>WTF!!!11个参数，这么多，这都是干嘛的？</p>
<blockquote>
<p>参数意义<br>op：kCCEncrypt(加密)/ kCCDecrypt(解密)<br>alg：加密算法 kCCAlgorithmAES、kCCAlgorithmDES、kCCAlgorithmBlowfish等等<br>options：加密方式 kCCOptionPKCS7Padding（CBC方式）/kCCOptionECBMode（ECB方式）<br>key：加密密钥<br>keyLength：密钥长度<br>iv：初始化向量 ECB不需要指定（CBC多了这个参数就相当于加盐，加密强度更高了）<br>dataIn：加密的数据<br>dataInLength：加密数据的长度<br>dataOut：缓冲区（地址），存放密文<br>dataOutAvailable：缓冲区的大小<br>dataOutMoved：加密结果的大小</p>
</blockquote>
<p>搞清楚每个参数的意义也就明白了，苹果这样设计还是挺人性化的。对称加密和解密所用的参数密钥都是一样的，所以加密和解密都是用同一个函数。苹果的加密算法也都在CommonCrypto.h这个库里面，这个库并不在macho中，是在系统中，所以我们大多数会认为这个加密会很安全，但是事实上并不是这样。</p>
<h4 id="CCCrypt函数安全隐患"><a href="#CCCrypt函数安全隐患" class="headerlink" title="CCCrypt函数安全隐患"></a>CCCrypt函数安全隐患</h4><p>现在我们已经使用CCCrypt对数据进行加密和解密了，接下来看下我们用CCCrypt加密的数据是否真的安全。下面的内容涉及到逆向开发，可能有点跑偏，如果感兴趣的小伙伴也可以进一步研究一下。<br>我们加密数据就是为了防止中间人攻击，假设如果别人拿到我们的APP，别人肯定不会知道我们的源码，也不知道在数据核心加密的地方是不是用的CCCrypt，这时别人会进行符号断点，当然这个只要是没有去符号，或者系统的都是可以拦截到的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-b73c172a7ca12ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="符号断点"></p>
<h5 id="前方高能！！！"><a href="#前方高能！！！" class="headerlink" title="前方高能！！！"></a>前方高能！！！</h5><p>下了断点后，我们继续运行刚才的demo，程序果断进入断点，接下来要读寄存器了！！！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-76d1819cc5f6e894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WeChat112460611fd045da8d8d9a181882dc6d.png"></p>
<p>刚刚说过，CCCrypt第7个参数是我们加密的数据，所以在寄存器中X6（从X0开始）就是我们的加密数据，我们在lldb中读取X6的地址值，也就是指针，拿到X6的地址值是0x00000001c403ee00，再p (char *)0x00000001c403ee00查看X6的值，回车！！！我们刚刚加密的数据显示出来了，我们原以为很安全的手段就这样被别人拿到了！所以我们有很多核心的加密算法不能直接用。</p>
<p>那怎么防御呢？先想到去符号，前面也说了，这个库是系统的，所以没办法去符号，当然自己实现或者三方库，比如支付宝就是直接用的OpenSSL，可以去符号来避免被直接破解。最好的方式是加密之前不能直接使用关键数据，我们可以自己对关键数据处理一下比如异或，方法肯定不止一个，如果各位有什么好的解决办法欢迎交流。</p>
<p>后面可能会介绍下怎么隐藏函数调用，怎样保护核心数据，当然逆向大神还是很多的，这也仅仅是让逆向变的更难而已。该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>OpenSSL</tag>
        <tag>对称加密原理</tag>
        <tag>CCCrypt安全隐患</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac电脑配置福利Alfred、Go2shell、iTerm2+Oh My Zsh</title>
    <url>/2019/03/05/mac-pei-zhi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d655dfa497bbcfd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电脑配置"></p>
<p>哎，一年换了个21-inch iMac，两个27-inch iMac，加上重做系统就更不说了，每次都要下载各种软件，各种配置。。。故记录这篇文章以免自己以后老了记不住，希望可以帮到更多人吧！</p>
<h4 id="效率神器Alfred、Go2shell"><a href="#效率神器Alfred、Go2shell" class="headerlink" title="效率神器Alfred、Go2shell"></a>效率神器Alfred、Go2shell</h4><p>首先，拿到新电脑，需要下载很多软件，第一时间把<code>Alfred</code>和<code>Go2shell</code>安装好，这里有<a href="xclient.info">各种破解软件免费下载平台</a>，里面安装教程很详细，默认<code>alt + 空格</code>打开Alfred，Go2shell就是可以快速打开当前路径的终端，用起来还是很方便的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-8400d17b9f794546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Go2shell"></p>
<h4 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h4><p>接下来根据个人喜好配置终端，之前也一直在用苹果自带的终端，但是自从接触了iTerm2后就无法自拔了。</p>
<ul>
<li><p>安装iTerm2<br>先去官网下载iTerm2，<a href="http s://www.iterm2.com/downloads.html">iTerm2下载地址：</a><a href="https://www.iterm2.com/downloads.html">https://www.iterm2.com/downloads.html</a></p>
</li>
<li><p>配置iTerm2<br>目前iTerm2 最常用的主题是<code>Solarized Dark theme</code>，下载地址：<a href="http://ethanschoonover.com/solarized">http://ethanschoonover.com/solarized</a>，下载好的压缩文件解压后，打开 iTerm2的<code>Preferences</code>配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-889dc79aadf6e185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加主题文件"></p>
<p>选择刚才解压的solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors文件，导入成功，最后选择 Solarized Dark 主题。</p>
<h4 id="配置Oh-My-Zsh"><a href="#配置Oh-My-Zsh" class="headerlink" title="配置Oh My Zsh"></a>配置Oh My Zsh</h4><p>一款用于管理zsh配置，可以提供超级多而强大的插件和漂亮的主题。可以去GitHub下载<a href="https://github.com/robbyrussell/oh-my-zsh">Oh My Zsh</a></p>
<ul>
<li>安装Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 使用 crul 安装：
$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
或者<pre class="line-numbers language-none"><code class="language-none">// 使用wget：
$ sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
安装成功后</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3fe231151c615c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Oh My Zsh"></p>
<ul>
<li>卸载Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 卸载oh-my-zsh命令：
$ uninstall_oh_my_zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>设置当前用户的默认Shell为Zsh<pre class="line-numbers language-none"><code class="language-none">$ chsh -s /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
接下来，将主题配置修改为ZSH_THEME=”agnoster”<pre class="line-numbers language-none"><code class="language-none">$ vim ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
到目前为止，不出意外的话，iTerm2外观应该是这样的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92007dc6e28a9a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2外观"></p>
<p>界面显示乱码原因是没有安装<code>Meslo</code>字体，字体下载地址：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a>，下载后安装接下来还是打开 iTerm2的Preferences 配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-ffed44579f071798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Meslo字体"><br>成功后的截图<br><img src="https://upload-images.jianshu.io/upload_images/5741330-e95f6971f45f9469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2+Oh My Zsh"></p>
<p>也可以修改合适的字体大小。</p>
<h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>这个功能是非常实用的，可以方便我们快速的敲命令。</p>
<p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：<br></p><pre class="line-numbers language-none"><code class="language-none">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后编辑<code>vim ~/.zshrc</code>文件，找到<code>plugins</code>配置，增加<code>zsh-autosuggestions</code>插件。如果配置不生效增加zsh-syntax-highlighting插件试试。<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-275b4a55100f9dac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动填充"></p>
<h4 id="隐藏用户名和主机名"><a href="#隐藏用户名和主机名" class="headerlink" title="隐藏用户名和主机名"></a>隐藏用户名和主机名</h4><p>进入Oh My Zsh主题文件列表<br></p><pre class="line-numbers language-none"><code class="language-none">$ cd ~/.oh-my-zsh/themes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>进入已选的主题，并找到<code>prompt_context</code>，然后进行修改<br><pre class="line-numbers language-none"><code class="language-none">### Prompt components
# Each component will draw itself, and hide itself if no information needs to be shown

# Context: user@hostname (who am I and where am I)
prompt_context() {
  if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then
    # prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"
    prompt_segment black default "Vincent" // Vincent是写死的名字 可以根据个人爱好随意设置
  fi
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://upload-images.jianshu.io/upload_images/5741330-3c6300f5a99d9272.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隐藏用户名和主机名"><p></p>
<p>还有一些插件和功能网上很多，暂不做更多介绍。</p>
<p>该文章为记录本人的电脑配置，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Mac配置</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密算法--RSA加密原理及运用</title>
    <url>/2018/12/02/rsa-jia-mi-yuan-li-ji-yun-yong/</url>
    <content><![CDATA[<p><img src="https://s.im5i.com/2021/02/02/kIFKH.png" alt="RSA加密原理及运用"></p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81">密码</a>学是在编码与破译的斗争实践中逐步发展起来的,并随着先进科学技术的应用，已成为一门综合性的尖端技术科学。</p>
</blockquote>
<h4 id="密码学发展史"><a href="#密码学发展史" class="headerlink" title="密码学发展史"></a>密码学发展史</h4><p>在说RSA加密算法之前， 先说下密码学的发展史。其实密码学的诞生，就是为了运用在战场，在公元前，战争之中出现了秘密书信。在中国历史上最早的加密算法的记载出自于周朝兵书《六韬.龙韬》中的《阴符》和《阴书》。在遥远的西方，在希罗多德（Herodotus）的《历史》中记载了公元前五世纪，希腊城邦和波斯帝国的战争中，广泛使用了移位法进行加密处理战争通讯信息。</p>
<p>相传凯撒大帝为了防止敌人窃取信息，就使用加密的方式传递信息。那么当时的加密方式非常的简单，就是对二十几个罗马字母建立一张对照表，将明文对应成为密文。那么这种方式其实持续了很久。甚至在二战时期，日本的电报加密就是采用的这种原始加密方式。<br><img src="https://s.im5i.com/2021/02/02/kIVPa.webp" alt="凯撒密码对照表"></p>
<p>早期的密码学一直没有什么改进，几乎都是根据经验慢慢发展的。直到20世纪中叶，由香农发表的《秘密体制的通信理论》一文，标志着加密算法的重心转移往应用数学上的转移。于是，逐渐衍生出了当今重要的三类加密算法：非对称加密、对称加密以及哈希算法（HASH严格说不是加密算法，但由于其不可逆性，已成为加密算法中的一个重要构成部分）。</p>
<p>1976年以前，所有的加密方法都是同一种模式：加密和解密使用同样规则（简称”密钥”），这被称为<a href="http://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%AD%89%E5%8A%A0%E5%AF%86">“对称加密算法”</a>，使用相同的密钥，两次连续的对等加密运算后会恢复原始文字，也有很大的安全隐患。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">“Diffie-Hellman密钥交换算法”</a>。也正是因为这个算法的产生，人类终于可以实现非对称加密了：A给B发送信息</p>
<blockquote>
<ol>
<li>B要先生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</li>
<li>A获取B的公钥，然后用它对信息加密。</li>
<li>B得到加密后的信息，用私钥解密。<br>理论上如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</li>
</ol>
</blockquote>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">RSA算法</a>。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是232个十进制位，也就是768个二进制位，因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全，当然量子计算机除外。</p>
<h4 id="RSA算法的原理"><a href="#RSA算法的原理" class="headerlink" title="RSA算法的原理"></a>RSA算法的原理</h4><p>下面进入正题，解释RSA算法的原理，其实RSA算法并不难，只需要一点<a href="http://jeremykun.com/2011/07/30/number-theory-a-primer/">数论知识</a>就可以理解。</p>
<blockquote>
<ol>
<li><strong>素数</strong>：又称<strong>质数</strong>，指在一个大于1的<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F19911.htm">自然数</a>中，除了1和此<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F71484.htm">整数</a>自身外，不能被其他自然数<a href="https://link.jianshu.com/?t=http%3A%2F%2Fbaike.baidu.com%2Fview%2F135932.htm">整除</a>的数。</li>
<li><strong>互质</strong>，又称<strong>互素</strong>。若N个整数的<a href="https://link.jianshu.com/?t=http%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%259C%2580%25E5%25A4%25A7%25E5%2585%25AC%25E5%259B%25A0%25E6%2595%25B8">最大公因子</a>是1，则称这N个整数互质。</li>
<li><strong>模运算</strong>即<strong>求余运算</strong>。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个<strong>正</strong>整数，若得相同<a href="https://link.jianshu.com/?t=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25BD%2599%25E6%2595%25B0">余数</a>，则二整数<strong>同余</strong>。<h5 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h5>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）计算这个值的方法就叫做<a href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>，以φ(n)表示。</li>
</ol>
<ul>
<li>计算8的欧拉函数，和8互质的 <strong>1</strong>、2、<strong>3</strong>、4、<strong>5</strong>、6、<strong>7</strong>、8<br>φ(8) = 4<br>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则φ(n) = φ(p^k) = p^k - p^(k-1)。也就是φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4</li>
<li>计算7的欧拉函数，和7互质的 <strong>1</strong>、<strong>2</strong>、<strong>3</strong>、<strong>4</strong>、<strong>5</strong>、<strong>6</strong>、7<br>φ(7) = 6<br>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</li>
<li>计算56的欧拉函数<br>φ(56) = φ(8) <em> φ(7) = 4 </em> 6 = 24<br>如果n可以分解成两个互质的整数之积，即 n = p <em> k ，则φ(n) = φ(p </em> k) = φ(p1)*φ(p2)</li>
</ul>
<p><strong>欧拉定理</strong>：如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。<br><img src="https://s.im5i.com/2021/02/02/kIyhQ.webp" alt="欧拉定理"></p>
<p><strong>费马小定理</strong>：欧拉定理的特殊情况，如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。<br><img src="https://s.im5i.com/2021/02/02/kI6Jq.webp" alt="费马小定理"></p>
<h5 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h5><p>还剩下最后一个概念，<strong>模反元素</strong>：如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除，或者说ed被x除的余数是1。<br>那么d就是e相对于x的模反元素。<br><img src="https://s.im5i.com/2021/02/02/kIR2h.webp" alt="d是模反元素"></p>
</blockquote>
<h5 id="等式转换"><a href="#等式转换" class="headerlink" title="等式转换"></a>等式转换</h5><ol>
<li><p>根据欧拉定理<br><img src="https://s.im5i.com/2021/02/02/kIwtX.webp" alt="等式转换1"></p>
</li>
<li><p>由于1^k ≡ 1，等号左右两边都来个k次方<br><img src="https://s.im5i.com/2021/02/02/kIoYf.webp" alt="等式转换2"></p>
</li>
<li><p>由于1* m ≡ m，等号左右两边都乘上m<br><img src="https://s.im5i.com/2021/02/02/kItVM.webp" alt="等式转换3"></p>
</li>
</ol>
<p>根据模反元素，因为e*d 一定是x的倍数加1。所以如下：<br><img src="https://s.im5i.com/2021/02/02/kIvO3.webp" alt="等式转换"></p>
<p>通过多次的等式转换。终于可以将这两个等式进行合并了！如下：<br><img src="https://s.im5i.com/2021/02/02/kIBD7.webp" alt="最终等式转换"></p>
<p>这个等式成立有一个前提！就是关于模反元素的，就是当整数e和φ(n)互质！一定有一个整数d是e相对于φ(n)的模反元素。<br>我们可以测试一下。<br>m取值为4<br>n取值为15<br>φ(n)取值为8<br>e 如果取值为3<br>d 可以为 11、19…(模反元素很明显不止一个，其实就是解二元一次方程)<br>如果你测试了，那么你可以改变m的值试一下，其实这个等式不需要m和n 互质。只要m小于n 等式依然成立。<br>这里需要注意的是，我们可以看做 m 通过一系列运算得到结果仍然是 m。这一系列运算中，分别出现了多个参数n、φ(n)、e还有d。</p>
<p>m 的 e乘上d 次方为<strong>加密运算</strong>，得到结果 c<br>c 模以 n  为<strong>解密运算</strong>，得到结果 m<br>这似乎可以用于加密和解密。但这样，加密的结果会非常大。明文数据将非常小（虽然RSA用于加密的数据也很小，但是没这么大悬殊），真正的RSA要更加强大，那么RSA是怎么演变来的呢？？<br>早期很多数学家也停留在了这一步！直到1967年迪菲赫尔曼密钥交换打破了僵局！</p>
<h5 id="迪菲赫尔曼密钥交换"><a href="#迪菲赫尔曼密钥交换" class="headerlink" title="迪菲赫尔曼密钥交换"></a>迪菲赫尔曼密钥交换</h5><p>这个密钥交换当时轰动了整个数学界！而且对人类密码学的发展非常重要，因为这个伟大的算法能够拆分刚才的等式。当非对称加密算法没有出现以前，人类都是用的对称加密。所以密钥的传递，就必须要非常小心。<br>迪菲赫尔曼密钥交换 就是解决了密钥传递的保密性，我们来看一下<br><img src="https://s.im5i.com/2021/02/02/kIukp.webp" alt="迪菲赫尔曼密钥交换"><br>假设一个传递密钥的场景。算法就是用3 的次方去模以17。 三个角色</p>
<ul>
<li>服务器 随机数 15<br>这个15只有服务器才知道。通过算法得到结果 6 因为 3的15次方 mod 17 = 6 。然后将结果 6 公开发送出去，拿到客户端的 12 ，然后用12^15 mod 17 得到结果10(10就是交换得到的密钥)</li>
<li>客户端 随机数13<br>客户端用3 的 13次方 mod 17 = 12 然后将得到的结果12公布出去。<br>拿到服务器的 6 ，然后用6^13 mod 17 得到结果10(10就是交换得到的密钥)</li>
<li>第三者<br>第三者只能拿到6 和 12 ，因为没有私密数据13、15，所以它没法得到结果10。</li>
</ul>
<p>为什么 6的13次方会和12的15次方得到一样的结果呢?因为这就是规律，我们可以用小一点的数字测试一下3^3 mod 17 = 10和10 ^ 2 mod 17 ； 3 ^ 2 mod 17 = 9和9^3 mod 17结果都是15。迪菲赫尔曼密钥交换最核心的地方就在于这个规律<br><img src="https://s.im5i.com/2021/02/02/kI4AG.webp" alt="迪菲赫尔曼密钥交换转换"></p>
<h5 id="RSA的诞生"><a href="#RSA的诞生" class="headerlink" title="RSA的诞生"></a>RSA的诞生</h5><p><img src="https://s.im5i.com/2021/02/02/kIIEY.webp" alt="RSA原理"></p>
<blockquote>
<p>现在我们知道了m^e % n = c是加密，c^d % n = m是解密，m就是原始数据，c是密文，公钥是n和e，私钥是n和d，所以只有n和e是公开的。加密时我们也要知道φ(n)的值，最简单的方式是用两个质数之积得到，别人想破解RSA也要知道φ(n)的值，只能对n进行因数分解，那么我们不想m被破解，n的值就要非常大，就是我们之前说的，长度一般为1024个二进制位，这样就很安全了。但是据说量子计算机(用于科研，尚未普及)可以破解，理论上量子计算机的运行速度无穷快，大家可以了解一下。</p>
</blockquote>
<p>以上就是RSA的数学原理</p>
<h5 id="检验RSA加密算法"><a href="#检验RSA加密算法" class="headerlink" title="检验RSA加密算法"></a>检验RSA加密算法</h5><p>我们用终端命令演示下这个加密、解密过程。<br>假设m = 12(随便取值，只要比n小就OK)，n = 15(还是随机取一个值)，φ(n) = 8，e = 3(只要和φ(n)互质就可以)，d = 19（3d - 1 = 8，d也可以为3,11等等，也就是d = (8k + 1)/3 ）<br>终端分别以m=12，7输入结果<br><img src="https://s.im5i.com/2021/02/02/kIX2w.webp" alt="终端演示"></p>
<h5 id="OpenSSL进行RSA的命令运行"><a href="#OpenSSL进行RSA的命令运行" class="headerlink" title="OpenSSL进行RSA的命令运行"></a>OpenSSL进行RSA的命令运行</h5><p>Mac可以直接使用OpenSSL，首先进入相应文件夹</p>
<ul>
<li>生成公私钥<pre class="line-numbers language-none"><code class="language-none">// 生成RSA私钥，文件名为private.pem，长度为1024bit
openssl genrsa -out private.pem 1024<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 从私钥中提取公钥
openssl rsa -in private.pem -pubout -out publick.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<img src="https://s.im5i.com/2021/02/02/kImvF.webp" alt="生成私钥"></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// 查看刚刚生成好的私钥
cat private.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 查看刚刚生成好的公钥
cat publick.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://s.im5i.com/2021/02/02/kIPgd.webp" alt="查看公私钥"></p>
<p>我们可以看到base64编码，明显私钥二进制很大，公钥就小了很多。<br>这时候我们的文件夹内已经多了刚刚生成好的公私钥文件了</p>
<p><img src="https://s.im5i.com/2021/02/02/kXDVK.webp" alt="公私钥文件"></p>
<pre class="line-numbers language-none"><code class="language-none">// 将私钥转换为明文
openssl rsa -in private.pem -text -out private.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://s.im5i.com/2021/02/02/kXUQC.webp" alt="P1、P2信息"></p>
<p>里面就是P1、P2还有KEY等信息。</p>
<ul>
<li>对文件进行加密、解密<pre class="line-numbers language-none"><code class="language-none">// 编辑文件message内容为hello Vincent!!!
// 刚刚的public.pem写成了publick.pem(哎。。。)
 $ vi message.txt
 $ cat message.txt
 hello Vincent!!!
// 通过公钥加密数据时，使用encrypt对文件进行加密
 $ openssl rsautl -encrypt -in message.txt -inkey publick.pem -pubin -out enc.txt
// 此时查看该文件内容为乱码
 $ cat enc.txt
j��E]֌a��d�kUE�&amp;&lt;
                 ��I*��V/��pL[���ˋ�O�+�-�M��K�ܱ�&amp;⪅ծO��2���o34�:�$���6��C�L��,b�'M�S�k�0���A��3%�[I���1�����ps"%
// 通过私钥解密数据
 $ openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt
// 已成功解密，正确显示文件内容
 $ cat dec.txt
  hello Vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">// 通过私钥加密数据时，要使用sign对文件进行重签名
$ openssl rsautl -sign -in message.txt -inkey private.pem -out enc.bin
// 此时查看该文件内容同样为乱码
$ cat enc.bin
{���Ew�3�1E��,8-OA2�Is�:���:�ԅ@MU����؜
                                      �i1B���#��6���ׂm�D(�t#/���	�ہ�������ݬ&gt;(�&gt;�^@�C��3�ӸMQт�O%
// 通过公钥解密数据
$ openssl rsautl -verify -in enc.bin -inkey publick.pem -pubin -out dec.bin
// 已成功解密，正确显示文件内容
$ cat dec.bin
 hello Vincent!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="RSA用途及特点"><a href="#RSA用途及特点" class="headerlink" title="RSA用途及特点"></a>RSA用途及特点</h5>到这里，大家都知道RSA相对比较安全，但是通过数学算法来加密和解密，效率比较低，所以一般RSA的主战场是加密比较小的数据，比如对大数据进行对称加密，再用RSA给对称加密的KEY进行加密，或者加密Hash值，也就是数字签名。</li>
</ul>
<p>关于RSA数字签名后面再慢慢阐述。该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Runloop底层原理--源码分析</title>
    <url>/2021/02/02/runtime-fan-hui-bian/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0353c6ce7788cf39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反汇编分析消息转发"></p>
<blockquote>
<p>消息转发：发送一个消息，也就是sel查找imp，当没有找到imp，接下来进入动态方法解析，如果开发者并没有处理，会进入消息转发。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>前几篇文章介绍了<a href="https://www.jianshu.com/p/1ddd15e47343">Runtime底层原理</a>和<a href="https://www.jianshu.com/p/a7db9f0c82d6">动态方法解析总结</a></p>
</blockquote>
<p>，我们知道如果前面的动态方法解析也没有解决问题的话，那么就会进入消息转发<code>_objc_msgForward_impcache</code>方法，会有快速消息转发和慢速消息转发。<br><code>_objc_msgForward_impcache</code>方法会从C转换到汇编部分<code>__objc_msgForward_impcache</code>进行快速消息转发，执行闭源<code>__objc_msgForward</code>。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-3eb7d8eb18b221b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="汇编部分__objc_msgForward"></p>
<p>如果我们的方法没有查找到会报错<code>_forwarding_prep_0</code><br><img src="https://upload-images.jianshu.io/upload_images/5741330-9ef2ef6fcc43679a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃信息"></p>
<p>但是我们在源代码中找不到该方法，除了前面文章—<a href="https://www.jianshu.com/p/1ddd15e47343">Runtime底层原理—动态方法解析、消息转发源码分析</a>提到的方法外，我们可以用反汇编分析消息转发。</p>
<p>首先进入<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/CoreFoundation.framework</code>中，找到可执行文件<code>CoreFoundation</code>，将该文件拖入hopper中，找到<code>CFInitialze</code>可以看到了<code>___forwarding_prep_0___</code><br><img src="https://upload-images.jianshu.io/upload_images/5741330-0b90c8c5ea93efc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forwarding_prep_0"></p>
<p>进入<code>___forwarding_prep_0___</code>内部，<br><img src="https://upload-images.jianshu.io/upload_images/5741330-05fba25f458f9938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="____forwarding___"></p>
<p>从崩溃堆栈信息中看到有执行forwarding，进入forwarding内部，里面判断了_objc_msgSend_stret、_objc_msgSend、taggedpointer之后有个<code>forwardingTargetForSelector:</code>，判断<code>forwardingTargetForSelector:</code>没有实现，没有实现跳转到loc_126fc7，<br><img src="https://upload-images.jianshu.io/upload_images/5741330-0a615756710dd4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forwardingTargetForSelector"></p>
<p>进入loc_126fc7，判断僵尸对象之后执行方法签名<code>methodSignatureForSelector:</code>，如果有值，获取Name、是否有效的位移等，之后会响应<code>_forwardStackInvocation:</code>，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-828729004c8eb7f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_forwardStackInvocation"></p>
<p>如果没有响应<code>_forwardStackInvocation:</code>，则会响应<code>forwardInvocation:</code>，给rdi发送rax消息，rdi就是NSInvocation，rax就是sel<code>forwardInvocation:</code>，<strong>这就是消息转发的流程</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-025bfb972fbb00fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="selforwardInvocation"></p>
<p>对<code>_objc_msgForward</code>部分进行反汇编成OC代码：<br></p><pre class="line-numbers language-none"><code class="language-none">
int __forwarding__(void *frameStackPointer, int isStret) {
    id receiver = *(id *)frameStackPointer;
    SEL sel = *(SEL *)(frameStackPointer + 8);
    const char *selName = sel_getName(sel);
    Class receiverClass = object_getClass(receiver);
    
    // 调用 forwardingTargetForSelector:
    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {
        id forwardingTarget = [receiver forwardingTargetForSelector:sel];
        if (forwardingTarget &amp;&amp; forwarding != receiver) {
            if (isStret == 1) {
                int ret;
                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);
                return ret;
            }
            return objc_msgSend(forwardingTarget, sel, ...);
        }
    }
    
    // 僵尸对象
    const char *className = class_getName(receiverClass);
    const char *zombiePrefix = "_NSZombie_";
    size_t prefixLen = strlen(zombiePrefix); // 0xa
    if (strncmp(className, zombiePrefix, prefixLen) == 0) {
        CFLog(kCFLogLevelError,
              @"*** -[%s %s]: message sent to deallocated instance %p",
              className + prefixLen,
              selName,
              receiver);
        &lt;breakpoint-interrupt&gt;
    }
    
    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation
    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {
        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];
        if (methodSignature) {
            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;
            if (signatureIsStret != isStret) {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.",
                      selName,
                      signatureIsStret ? "" : not,
                      isStret ? "" : not);
            }
            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {
                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];
                
                [receiver forwardInvocation:invocation];
                
                void *returnValue = NULL;
                [invocation getReturnValue:&amp;value];
                return returnValue;
            } else {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message",
                      receiver,
                      className);
                return 0;
            }
        }
    }
    
    SEL *registeredSel = sel_getUid(selName);
    
    // selector 是否已经在 Runtime 注册过
    if (sel != registeredSel) {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort",
              sel,
              selName,
              registeredSel);
    } // doesNotRecognizeSelector
    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {
        [receiver doesNotRecognizeSelector:sel];
    }
    else {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort",
              receiver,
              className);
    }
    
    // The point of no return.
    kill(getpid(), 9);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该文章为记录本人的学习路程，希望能够帮助大家！！！<p></p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
        <tag>反汇编</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Runloop底层原理--源码分析</title>
    <url>/2019/04/05/runtime-jian-jie/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7f293e1c5c8cb366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runtime底层原理"></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106-SW2">Runtime官方文档介绍直通车</a></p>
<blockquote>
<p>扩展：编译时<br>看到运行时就会想到编译时，编译时主要是将源代码翻译成可识别的机器语言，如果编译时类型检查等翻译过程中发现语法分析之类有错误会给出相应的提示。比如OC，swift，Java等高级语言的可读性比较强，但是一般不会被机器直接识别，所以需要将他们编译成机器语言（汇编等），转为二进制</p>
</blockquote>
<h4 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h4><p>在 Objective-C 中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，<br></p><pre class="line-numbers language-none"><code class="language-none">[receiver message]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数:消息接收者和消息对应的方法——也就是方法编号（name），<strong>发送消息时候，通过sel找到函数实现的指针imp</strong><br><pre class="line-numbers language-none"><code class="language-none">objc_msgSend(receiver, selector)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>编译器将自动插入调用该消息函数的代码，同时接收消息中的任意数目的参数:<br><pre class="line-numbers language-none"><code class="language-none">objc_msgSend(receiver, selector, arg1, arg2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>该消息函数做了动态绑定所需要的一切:</strong><p></p>
<ul>
<li>它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。</li>
<li>然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传给找到的方法实现。</li>
<li>最后，将方法实现的返回值作为该函数的返回值返回。</li>
</ul>
<p><strong>消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素:</strong></p>
<ul>
<li>指向父类的指针。</li>
<li>类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。</li>
</ul>
<h4 id="和运行时系统的交互"><a href="#和运行时系统的交互" class="headerlink" title="和运行时系统的交互"></a>和运行时系统的交互</h4><p>Objective-C 程序有三种途径和运行时系统交互:</p>
<ul>
<li>通过Objective-C源代码<br>大部分情况下，运行时系统在后台自动运行，当编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。运行时系统的主要功能就是根据源代码中的表达式发送消息。</li>
<li>通过Foundation框架中 NSObject 的方法<br>Cocoa程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承 了NSObject的行为。然而，某些情况下， NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码（比如 description 方法）。某些 NSObject 的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查（比如methodForSelector方法返回指定方法实现的地址）。</li>
<li>通过调用运行时系统函数<br>直接调用运行时系统给我们提供的API接口</li>
</ul>
<h4 id="Runtime函数注释"><a href="#Runtime函数注释" class="headerlink" title="Runtime函数注释"></a>Runtime函数注释</h4><pre class="line-numbers language-none"><code class="language-none">
// 1.objc_xxx系列函数  宏观使用,如类与协议的空间分配,注册,注销等操作
// 函数名称     函数作用
objc_getClass     获取Class对象
objc_getMetaClass     获取MetaClass对象
objc_allocateClassPair     分配空间,创建类(仅在 创建之后,注册之前 能够添加成员变量)
objc_registerClassPair     注册一个类(注册后方可使用该类创建对象)
objc_disposeClassPair     注销某个类
objc_allocateProtocol     开辟空间创建协议
objc_registerProtocol     注册一个协议
objc_constructInstance     构造一个实例对象(ARC下无效)
objc_destructInstance     析构一个实例对象(ARC下无效)
objc_setAssociatedObject     为实例对象关联对象
objc_getAssociatedObje*ct     获取实例对象的关联对象
objc_removeAssociatedObjects     清空实例对象的所有关联对象

// 2.class_xxx系列函数   类的内部,如实例变量,属性,方法,协议等相关问题
函数名称     函数作用
class_addIvar     为类添加实例变量
class_addProperty     为类添加属性
class_addMethod     为类添加方法
class_addProtocol     为类遵循协议
class_replaceMethod     替换类某方法的实现
class_getName     获取类名
class_isMetaClass     判断是否为元类
objc_getProtocol     获取某个协议
objc_copyProtocolList     拷贝在运行时中注册过的协议列表
class_getSuperclass     获取某类的父类
class_setSuperclass     设置某类的父类
class_getProperty     获取某类的属性
class_getInstanceVariable     获取实例变量
class_getClassVariable     获取类变量
class_getInstanceMethod     获取实例方法
class_getClassMethod     获取类方法
class_getMethodImplementation     获取方法的实现
class_getInstanceSize     获取类的实例的大小
class_respondsToSelector     判断类是否实现某方法
class_conformsToProtocol     判断类是否遵循某协议
class_createInstance     创建类的实例
class_copyIvarList     拷贝类的实例变量列表
class_copyMethodList     拷贝类的方法列表
class_copyProtocolList     拷贝类遵循的协议列表
class_copyPropertyList     拷贝类的属性列表

// 3.object_xxx系列函数   对象的角度,如实例变量
函数名称     函数作用
object_copy     对象copy(ARC无效)
object_dispose     对象释放(ARC无效)
object_getClassName     获取对象的类名
object_getClass     获取对象的Class
object_setClass     设置对象的Class
object_getIvar     获取对象中实例变量的值
object_setIvar     设置对象中实例变量的值
object_getInstanceVariable     获取对象中实例变量的值 (ARC中无效,使用object_getIvar)
object_setInstanceVariable     设置对象中实例变量的值 (ARC中无效,使用object_setIvar)

// 4.method_xxx系列函数   方法内部,如方法的参数及返回值类型和方法的实现
函数名称     函数作用
method_getName     获取方法名
method_getImplementation     获取方法的实现
method_getTypeEncoding     获取方法的类型编码
method_getNumberOfArguments     获取方法的参数个数
method_copyReturnType     拷贝方法的返回类型
method_getReturnType     获取方法的返回类型
method_copyArgumentType     拷贝方法的参数类型
method_getArgumentType     获取方法的参数类型
method_getDescription     获取方法的描述
method_setImplementation     设置方法的实现
method_exchangeImplementations     替换方法的实现

// 5.property_xxx系列函数   属性*内部,如属性的特性等
函数名称     函数作用
property_getName     获取属性名
property_getAttributes     获取属性的特性列表
property_copyAttributeList     拷贝属性的特性列表
property_copyAttributeValue     拷贝属性中某特性的值

// 6.protocol_xxx系列函数 协议相关
函数名称     函数作用
protocol_conformsToProtocol     判断一个协议是否遵循另一个协议
protocol_isEqual     判断两个协议是否一致
protocol_getName     获取协议名称
protocol_copyPropertyList     拷贝协议的属性列表
protocol_copyProtocolList     拷贝某协议所遵循的协议列表
protocol_copyMethodDescriptionList     拷贝协议的方法列表
protocol_addProtocol     为一个协议遵循另一协议
protocol_addProperty     为协议添加属性
protocol_getProperty     获取协议中的某个属性
protocol_addMethodDescription     为协议添加方法描述
protocol_getMethodDescription     获取协议中某方法的描述

// 7.ivar_xxx 系列函数  实例变量相关
函数名称     函数作用
ivar_getName     获取Ivar名称
ivar_getTypeEncoding     获取类型编码
ivar_getOffset     获取偏移量

// 8.sel_xxx系列函数   方法编号相关
函数名称     函数作用
sel_getName     获取名称
sel_getUid     注册方法
sel_registerName     注册方法名
sel_isEqual     判断方法是否相等

// 9.imp_xxx系列函数   方法实现相关
函数名称     函数作用
imp_implementationWithBlock     通过代码块创建IMP
imp_getBlock     获取函数指针中的代码块
imp_removeBlock     移除IMP中的代码块
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想继续探究Runtime底层原理，下篇是<a href="[https://www.jianshu.com/p/1ddd15e47343](https://www.jianshu.com/p/1ddd15e47343">Runtime源码分析</a><br>)，包括动态方法解析和消息转发。<br>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac电脑配置福利Alfred、Go2shell、iTerm2+Oh My Zsh</title>
    <url>/2021/02/02/itunes/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-d655dfa497bbcfd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电脑配置"></p>
<p>哎，一年换了个21-inch iMac，两个27-inch iMac，加上重做系统就更不说了，每次都要下载各种软件，各种配置。。。故记录这篇文章以免自己以后老了记不住，希望可以帮到更多人吧！</p>
<h4 id="效率神器Alfred、Go2shell"><a href="#效率神器Alfred、Go2shell" class="headerlink" title="效率神器Alfred、Go2shell"></a>效率神器Alfred、Go2shell</h4><p>首先，拿到新电脑，需要下载很多软件，第一时间把<code>Alfred</code>和<code>Go2shell</code>安装好，这里有<a href="xclient.info">各种破解软件免费下载平台</a>，里面安装教程很详细，默认<code>alt + 空格</code>打开Alfred，Go2shell就是可以快速打开当前路径的终端，用起来还是很方便的。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-8400d17b9f794546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Go2shell"></p>
<h4 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h4><p>接下来根据个人喜好配置终端，之前也一直在用苹果自带的终端，但是自从接触了iTerm2后就无法自拔了。</p>
<ul>
<li><p>安装iTerm2<br>先去官网下载iTerm2，<a href="http s://www.iterm2.com/downloads.html">iTerm2下载地址：</a><a href="https://www.iterm2.com/downloads.html">https://www.iterm2.com/downloads.html</a></p>
</li>
<li><p>配置iTerm2<br>目前iTerm2 最常用的主题是<code>Solarized Dark theme</code>，下载地址：<a href="http://ethanschoonover.com/solarized">http://ethanschoonover.com/solarized</a>，下载好的压缩文件解压后，打开 iTerm2的<code>Preferences</code>配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-889dc79aadf6e185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加主题文件"></p>
<p>选择刚才解压的solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors文件，导入成功，最后选择 Solarized Dark 主题。</p>
<h4 id="配置Oh-My-Zsh"><a href="#配置Oh-My-Zsh" class="headerlink" title="配置Oh My Zsh"></a>配置Oh My Zsh</h4><p>一款用于管理zsh配置，可以提供超级多而强大的插件和漂亮的主题。可以去GitHub下载<a href="https://github.com/robbyrussell/oh-my-zsh">Oh My Zsh</a></p>
<ul>
<li>安装Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 使用 crul 安装：
$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
或者<pre class="line-numbers language-none"><code class="language-none">// 使用wget：
$ sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
安装成功后</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3fe231151c615c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Oh My Zsh"></p>
<ul>
<li>卸载Oh My Zsh<pre class="line-numbers language-none"><code class="language-none">// 卸载oh-my-zsh命令：
$ uninstall_oh_my_zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>设置当前用户的默认Shell为Zsh<pre class="line-numbers language-none"><code class="language-none">$ chsh -s /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
接下来，将主题配置修改为ZSH_THEME=”agnoster”<pre class="line-numbers language-none"><code class="language-none">$ vim ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
到目前为止，不出意外的话，iTerm2外观应该是这样的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92007dc6e28a9a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2外观"></p>
<p>界面显示乱码原因是没有安装<code>Meslo</code>字体，字体下载地址：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a>，下载后安装接下来还是打开 iTerm2的Preferences 配置界面，可以按<code>Command + ,</code>键打开 ，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-ffed44579f071798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Meslo字体"><br>成功后的截图<br><img src="https://upload-images.jianshu.io/upload_images/5741330-e95f6971f45f9469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm2+Oh My Zsh"></p>
<p>也可以修改合适的字体大小。</p>
<h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>这个功能是非常实用的，可以方便我们快速的敲命令。</p>
<p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：<br></p><pre class="line-numbers language-none"><code class="language-none">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后编辑<code>vim ~/.zshrc</code>文件，找到<code>plugins</code>配置，增加<code>zsh-autosuggestions</code>插件。如果配置不生效增加zsh-syntax-highlighting插件试试。<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-275b4a55100f9dac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动填充"></p>
<h4 id="隐藏用户名和主机名"><a href="#隐藏用户名和主机名" class="headerlink" title="隐藏用户名和主机名"></a>隐藏用户名和主机名</h4><p>进入Oh My Zsh主题文件列表<br></p><pre class="line-numbers language-none"><code class="language-none">$ cd ~/.oh-my-zsh/themes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>进入已选的主题，并找到<code>prompt_context</code>，然后进行修改<br><pre class="line-numbers language-none"><code class="language-none">### Prompt components
# Each component will draw itself, and hide itself if no information needs to be shown

# Context: user@hostname (who am I and where am I)
prompt_context() {
  if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then
    # prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"
    prompt_segment black default "Vincent" // Vincent是写死的名字 可以根据个人爱好随意设置
  fi
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://upload-images.jianshu.io/upload_images/5741330-3c6300f5a99d9272.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隐藏用户名和主机名"><p></p>
<p>还有一些插件和功能网上很多，暂不做更多介绍。</p>
<p>该文章为记录本人的电脑配置，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Mac配置</tag>
      </tags>
  </entry>
  <entry>
    <title>本地进行证书签名</title>
    <url>/2019/01/17/ben-di-qian-ming/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-fb33597ad95d93e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地进行证书签名"></p>
<blockquote>
<p>之前说过<a href="https://www.jianshu.com/p/ad3d1dea63af">生成公私钥.pem文件</a>，实际上，我们在工作中一般不会用到.pem文件，我们完全可以在钥匙串中证书助理直接从证书颁发机构中申请证书，当然本地也可以。</p>
</blockquote>
<ul>
<li>终端生成证书<br>首先生成.csr请求证书文件，之后用这个.csr文件去证书颁发机构请求证书。<pre class="line-numbers language-none"><code class="language-none">// 通过private.pem，new一个rsacert.csr文件
$ openssl req -new -key private.pem -out rsacert.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
// 输入一些信息，地址、公司和邮箱等
Country Name (2 letter code) []:cn
State or Province Name (full name) []:shanghai
Locality Name (eg, city) []:shanghai
Organization Name (eg, company) []:personal
Organizational Unit Name (eg, section) []:personal
Common Name (eg, fully qualified host name) []:personal.com
Email Address []:76521244@qq.com

Please enter the following 'extra' attributes
to be sent with your certificate request
// 可以直接回车，不设置密码
A challenge password []:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这样，终端就生成好了一个.csr文件了，接下来继续用终端申请证书</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">// x509标准格式，-req签名，-days 3650 时间，也就是10年，用刚刚生成的csr文件和private.pem私钥进行签名，输出rsacert.crt证书
$ openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt
Signature ok
subject=/C=cn/ST=shanghai/L=shanghai/O=personal/OU=personal/CN=personal.com/emailAddress=76521244@qq.com
Getting Private key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>证书生成好后，显示证书的信息，下面是生成好的两个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7da3590dde1c108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书文件"></p>
<p>这个证书大概一年5000大洋，刚刚的一个操作5W就出去了，哈哈哈。。。那这个证书可以用来干嘛呢</p>
<ul>
<li>用途<br>比如HTTPS协议，这个协议需要认证这个证书，我们把证书放在服务器，别人去接受。<br>当我们查看这个证书时，会发现这个证书还是Base64编码，所以开发的时候还是不能直接用，需要将其内容提取出来<pre class="line-numbers language-none"><code class="language-none">$ openssl x509 -outform der -in rsacert.crt -out rsacert.der<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
通过命令，生成一个rsacert.der文件，这个文件主要包含了公钥和一些信息，再通过这个.der文件生成可以直接用的P12文件，也就是对应这个公钥的私钥。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$ openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt
Enter Export Password:
Verifying - Enter Export Password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>用刚刚生成crt的private.pem和.crt文件提取出P12文件，提取过程中需要设置密码，输入两次相同的密码回车后，一个对应的P12文件已经生成了。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-a3c20781e11c6bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书文件"><br>有了它俩就可以进行加密和解密了，我们iOS开发就是用的这两个文件。当然这两个文件不需要都拿到，只用.der就OK，这里只是为了演示。</p>
]]></content>
      <categories>
        <category>签名</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>非对称加密原理</tag>
        <tag>OpenSSL</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime底层原理--IMP查找流程、动态方法解析、消息转发源码分析</title>
    <url>/2019/04/12/imp-yuan-ma-fen-xi/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3e21c38f5be9a8d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runtime底层原理"></p>
<p>了解了<a href="https://www.jianshu.com/p/eddc9bdb46ea">Runtime函数含义</a>，我们就可以直接使用Runtime的API了，那接下来继续探究Runtime的源码，经过源码分析来更加深刻的了解Runtime原理。</p>
<h4 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h4><blockquote>
<p>都知道Runtime很重要，但是有很多小伙伴根本不了解，或者只是知道可以替换方法啊、可以交换两个方法的调用，项目中也用不到，<br>从进入iOS开始，写了无数个<code>[[objc alloc] init]</code>，这个到底在干嘛？初始化和init？alloc和init到底做了什么？</p>
</blockquote>
<h5 id="通过汇编查看方法调用"><a href="#通过汇编查看方法调用" class="headerlink" title="通过汇编查看方法调用"></a>通过汇编查看方法调用</h5><pre class="line-numbers language-none"><code class="language-none">Person *person = [Person alloc];
Person *person1 = [person init];
Person *person2 = [person init];
NSLog(@"%p-----%p------%p", person, person1, person2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里会输出什么呢？</p>
<pre class="line-numbers language-none"><code class="language-none">0x10102e1a0-----0x10102e1a0------0x10102e1a0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>来，让我们断点看下，<code>alloc</code>和<code>init</code>是怎么调用的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-df50f7ae402013ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc_msgSend"></p>
<p>我们看到调用<code>alloc</code>和<code>init</code>都调起了<code>objc_msgSend</code>，接下来跟着符号断点走</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7706f8564d5b447d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="libobjc"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7f2f3a95f30891e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callAlloc"></p>
<p>进入<code>libobjc</code>库的dylib之后走<code>+[NSObject alloc]</code>方法，指针调起<code>_objc_rootAlloc</code>，进入<code>_objc_rootAlloc</code>方法，继续调起<code>callAlloc</code>，通过寄存器，可以看到alloc已经通过类创建实例对象</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6839fe399aa384bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象"></p>
<p><code>init</code>按照同样方法 依然可以通过汇编看出方法调用顺序，可以用真机进行测试并打印 </p>
<h5 id="通过编译C"><a href="#通过编译C" class="headerlink" title="通过编译C++"></a>通过编译C++</h5><p>当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做 isa。通过该指针，对象可以访问它对应的类以及相应的父类。在 Objective-C 运行时系统中对象需要有 isa 指针，我们一般创建的从 NSObject 或者 NSProxy 继承的对象都自动包括 isa 变量。接下来看下对象被创建的过程<br>首先，我们通过clang命令<br></p><pre class="line-numbers language-none"><code class="language-none">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o testMain.c++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>也可以用<code>clang -rewrite-objc main.m -o test.c++</code>命令，只不过会有很多警告、代码会更长（大概9万多行）。<br>编译main函数中的OC代码为C++代码<br><pre class="line-numbers language-none"><code class="language-none">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        Person *p = [[Person alloc] init];
        [p run];
  
    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>编译后多一个testMain.c++文件，打开后在代码最后面会发现我们的main函数<br><pre class="line-numbers language-none"><code class="language-none">int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        Person *p = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init"));
        ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName("run"));

    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看出，我们的方法调用会编译成objc_msgSend，<p></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6b959a3252ac08d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="person对象"></p>
<p>由此还会发现对象的本质其实就是一个结构体</p>
<h4 id="下层通讯-通过源码查看objc-msgSend内部实现"><a href="#下层通讯-通过源码查看objc-msgSend内部实现" class="headerlink" title="下层通讯(通过源码查看objc_msgSend内部实现)"></a>下层通讯(通过源码查看objc_msgSend内部实现)</h4><p>首先我们到<a href="https://upload-images.jianshu.io/upload_images/5741330-3acf8ade7f319c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">苹果open source</a>官网下载最新源码<br><img src="https://upload-images.jianshu.io/upload_images/5741330-3acf8ade7f319c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码"></p>
<p>在<strong>方法调用的时候，会发送<code>objc_msgSend</code>消息，<code>objc_msgSend</code>会根据sel找到函数实现的指针imp</strong>，进而执行函数，那sel是如何找到imp的呢？<br><code>objc_msgSend</code>在发送消息时候根据sel查找imp有两种方式</p>
<ul>
<li>快速（通过汇编的缓存快速查找）</li>
<li>慢速（C配合C++、汇编一起查找）<br>先看下objc_class</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-da01958ba32dd572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc_class"></p>
<p>bits中包含各种数据，cache（每个类都有一个）用来存储方法select和imp，select和imp会以哈希表形式存在<br><code>objc_msgSend</code>在快速查找的时候，就是通过汇编查找objc_class中的cache，如果找到则直接返回，否则通过C的lookup，找到后再存入cache</p>
<h5 id="汇编部分快速查找"><a href="#汇编部分快速查找" class="headerlink" title="汇编部分快速查找"></a>汇编部分快速查找</h5><p>首先调用<code>objc_msgSend</code>会走到ENTRY</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-4d838bce5a43c8e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ENTRY"></p>
<p>先判断p0检查是否为空和tagged pointer（特殊类型）判断，调用<code>LNilOrTagged</code>进行isa处理，通过isa找到相应类class，最后调用<code>LGetIsaDone</code>来执行<code>CacheLookup</code>在缓存中查找imp，如果查找到直接调起imp否则调起objc_msgSend_uncached，objc_msgSend_uncached有两种情况</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-41e6fb32bc6de43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CacheLookup"></p>
<p>首先，第一个是CacheHit，直接调起imp，第二个是CheckMiss，之后调用objc_msgSend_uncached，第三个就是add，下面是CacheHit和CheckMiss的宏</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-a88860fb2c1871b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CacheLookup macro"></p>
<p>那如果在缓存中没有查找到imp，调起<code>objc_msgSend_uncached</code>，在方法列表中找到imp之后再<code>TailCallFunctionPointer</code>调起imp<br></p><pre class="line-numbers language-none"><code class="language-none">   STATIC_ENTRY __objc_msgSend_uncached
UNWIND __objc_msgSend_uncached, FrameWithNoSaves

// THIS IS NOT A CALLABLE C FUNCTION
// Out-of-band p16 is the class to search

MethodTableLookup      // 方法列表中找到imp
TailCallFunctionPointer x17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>重点:MethodTableLookup是怎么操作的</strong><p></p>
<blockquote>
<p>小知识点：通过method list查找method，下面是method_t的结构，method其实是一个哈希表，sel和imp是键值对<br></p><pre class="line-numbers language-none"><code class="language-none">struct method_t {
    SEL name;
    const char *types;       // 参数类型
    MethodListIMP imp;
    struct SortBySELAddress :
        public std::binary_function&lt;const method_t&amp;,
                                    const method_t&amp;, bool&gt;
    {
        bool operator() (const method_t&amp; lhs,
                         const method_t&amp; rhs)
        { return lhs.name &lt; rhs.name; }
    };
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>进入<code>MethodTableLookup</code>之后，调起了<code>__class_lookupMethodAndLoadCache3</code>，如下图<p></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-e53cc3c30a78bbe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MethodTableLookup"></p>
<p><code>__class_lookupMethodAndLoadCache3</code>是C方法，再次进入<code>_class_lookupMethodAndLoadCache3</code>方法，<strong>注意，因为这里由汇编跳转到C，所以要全局搜索<code>_class_lookupMethodAndLoadCache3</code>，要删去一个<code>"_"</code></strong>,下面是<code>_class_lookupMethodAndLoadCache3</code>函数</p>
<pre class="line-numbers language-none"><code class="language-none">/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* This lookup avoids optimistic cache scan because the dispatcher 
* already tried that.
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="C-C-部分查找"><a href="#C-C-部分查找" class="headerlink" title="C/C++部分查找"></a>C/C++部分查找</h5><p>调起<code>lookUpImpOrForward</code>，因为当前cls对象已经经过汇编编译到结构，有了isa，并且在cache中没有找到，所以这里的initialize为YES，cache为NO，resolver为YES</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-71ad5c6ba37152f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>进入<code>lookUpImpOrForward</code>，这里再次判断是否存在cache，如果有则直接快速查找，但是这里是NO，所以不会走。接下来走<code>checkIsKnownClass</code>判断是否是已经声明的类，如果没有则报错”Attempt to use unknown class %p.”，之后走<code>realizeClass</code>判断是否已经实现，如果就相应赋值data。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-8916248bb091fe67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="realizeClass"></p>
<p>data赋值后走<code>_class_initialize</code>初始化cls，接下来开始<code>retry</code>操作。<br><strong>前方高能</strong><br>再次进行cache_getImp，why？并发啊，还有重映射（在初始化init的时候有个remap（class）第一次通过汇编找不到，但是在加载类的时候对当前类进行重映射）<br><img src="https://upload-images.jianshu.io/upload_images/5741330-cbe3379e8e73bf14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cache_getImp"></p>
<p>接下来开始先在自己的class_rw_t的methods中根据sel查找方法返回method_t</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-22158fedc376e3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="method_t"></p>
<p>如果拿到Method后保存到缓存中，保证以后调用可以直接走汇编的CacheHit快速查找，如果拿不到则继续从父类开始查找，直到找到NSObject(因为NSObject的父类为nil)，如果找到imp则一样保存在缓存中，如果到最后还是没有查找到，则进入动态方法解析。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-348eeda298ad6d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父类查找方法"></p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>如果前面一系列操作还是没有找到方法，那么就会进行动态方法解析，动态方法解析只执行一次</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-9cbb884006c3e59c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态方法解析"></p>
<p>首先执行<code>_class_resolveMethod</code>，这里会执行<code>+resolveClassMethod</code> 或者 <code>+resolveInstanceMethod</code>。<br><img src="https://upload-images.jianshu.io/upload_images/5741330-c5cda417fae04acb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class resolveMethod"></p>
<p>先判断当前cls是否为元类，如果是元类则执行<code>_class_resolveClassMethod</code>，再执行<code>_class_resolveInstanceMethod</code>，如果不是元类则直接执行<code>_class_resolveInstanceMethod</code>，<code>_class_resolveInstanceMethod</code>内部调用objc_msgSend实现消息发送，对cls发送了<code>SEL_resolveInstanceMethod</code>类型的消息，所以在方法中会走到<code>resolveInstanceMethod</code>方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0ed2701ca3678b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class resolveInstanceMethod"></p>
<p>为什么元类最后也执行了<code>_class_resolveInstanceMethod</code>方法呢？因为类方法以实例对象的形态存在元类里面，比如类方法中没有找到方法，会去元类中查找，元类中没有再继续去根元类中查找，最后会查到NSObject。</p>
<h6 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h6><p>.h实现<br></p><pre class="line-numbers language-none"><code class="language-none">- (void)run;
+ (void)eat;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>.m实现(没有实现-run方法和+eat方法)<br><pre class="line-numbers language-none"><code class="language-none">- (void)walk {
    NSLog(@"%s",__func__);
}
+ (void)drink {
    NSLog(@"%s",__func__);
}

// .m没有实现,并且父类也没有,那么我们就开启动态方法解析
//- (void)walk{
//    NSLog(@"%s",__func__);
//}
//+ (void)drink{
//    NSLog(@"%s",__func__);
//}


#pragma mark - 动态方法解析

+ (BOOL)resolveInstanceMethod:(SEL)sel{
    if (sel == @selector(run)) {
        // 我们动态解析我们的 对象方法
        NSLog(@"对象方法解析走这里");
        SEL walkSEL = @selector(walk);
        Method readM= class_getInstanceMethod(self, walkSEL);
        IMP readImp = method_getImplementation(readM);
        const char *type = method_getTypeEncoding(readM);
        return class_addMethod(self, sel, readImp, type);
    }
    return [super resolveInstanceMethod:sel];
}


+ (BOOL)resolveClassMethod:(SEL)sel{
    if (sel == @selector(eat)) {
        // 我们动态解析我们的 对象方法
        NSLog(@"类方法解析走这里");
        SEL drinkSEL = @selector(drink);
        // 类方法就存在我们的元类的方法列表
        // 类 类犯法
        // 元类 对象实例方法
        //        Method hellowordM1= class_getClassMethod(self, hellowordSEL);
        Method drinkM= class_getInstanceMethod(object_getClass(self), drinkSEL);
        IMP drinkImp = method_getImplementation(drinkM);
        const char *type = method_getTypeEncoding(drinkM);
        NSLog(@"%s",type);
        return class_addMethod(object_getClass(self), sel, drinkImp, type);
    }
    return [super resolveClassMethod:sel];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h5 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h5><p>经历了动态方法决议还没有找到，会进入苹果尚未开源的消息转发，继续查找方法，<code>_objc_msgForward_impcache</code>再次跨域到汇编。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-c9fa6f055cdbc9d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<p>走到<code>__objc_msgForward_impcache</code>后执行<code>__objc_msgForward</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-bb97c18875125e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__objc_msgForward_impcache"></p>
<p>没有了源码实现，但是我们可以通过<code>instrumentObjcMessageSends</code>函数来打印调用堆栈信息。可以进入<code>instrumentObjcMessageSends</code>内部看下具体实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-f7a9ba5a7514aff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instrumentObjcMessageSends"></p>
<p>先判断了是否可以写入日志信息等，接下来同步日志文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-e67afa0438c44bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logMessageSend"></p>
<p>所以我们每次运行会在<code>/private/tmp</code>文件下多一个<code>msgSends-xxx</code>文件，里面是所有调用过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-7879482357d545ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆栈调用信息"></p>
<p>如果还没有找到的话最后会报错调用<code>__objc_forward_handler</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0c3110e83a8752ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__objc_forward_handler"></p>
<p>这也是我们在方法报错的时候会报<code>unrecognized selector sent to instance %p " "(no message forward handler is installed)"</code>错误的原因，会提示出元类信息，<code>+</code>或者<code>-</code>方法，方法的名字还有SEL方法编号</p>
<h6 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h6><pre class="line-numbers language-none"><code class="language-none">#pragma mark - 实例对象消息转发

- (id)forwardingTargetForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    //    if (aSelector == @selector(run)) {
    //        // 转发给Student对象
    //        return [Student new];
    //    }
    return [super forwardingTargetForSelector:aSelector];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    if (aSelector == @selector(run)) {
        // forwardingTargetForSelector 没有实现，就只能方法签名了
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation{
    NSLog(@"%s",__func__);
    NSLog(@"------%@-----",anInvocation);
    anInvocation.selector = @selector(walk);
    [anInvocation invoke];
}

#pragma mark - 类消息转发

+ (id)forwardingTargetForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    return [super forwardingTargetForSelector:aSelector];
}
//

+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSLog(@"%s",__func__);
    if (aSelector == @selector(walk)) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:@"];
    }
    return [super methodSignatureForSelector:aSelector];
}

+ (void)forwardInvocation:(NSInvocation *)anInvocation{
    NSLog(@"%s",__func__);
    
    NSString *sto = @"奔跑吧";
    anInvocation.target = [Student class];
    [anInvocation setArgument:&amp;sto atIndex:2];
    NSLog(@"%@",anInvocation.methodSignature);
    anInvocation.selector = @selector(run:);
    [anInvocation invoke];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们应该也知道了为什么<code>objc_msgSend</code>的源码用的汇编，因为汇编可以通过寄存器x0-x31来保留未知参数来跳转到任意的指针，还有汇编更高效一点，而C满足不了。</p>
<h4 id="言而总之，总而言之"><a href="#言而总之，总而言之" class="headerlink" title="言而总之，总而言之"></a>言而总之，总而言之</h4><blockquote>
<p>Runtime就是C、C++、汇编实现的一套API，给OC增加的一个运行时功能，也就是我们平时所说的运行时。<br>在运行工程时工程会被装载到内存，来提供运行时功能。</p>
</blockquote>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用签名原理--数字签名？代码签名？双层代码签名？</title>
    <url>/2019/03/02/ying-yong-qian-ming/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3d5330cfad68a1dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用签名"></p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><blockquote>
<p>数字签名（又称<a href="https://baike.baidu.com/item/%E5%85%AC%E9%92%A5">公钥</a>数字签名、<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E7%AD%BE%E7%AB%A0/4076522">电子签章</a>等）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。<br>数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>
</blockquote>
<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF">数字签名技术</a>是将摘要信息用发送者的私钥加密，与<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%96%87">原文</a>一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用<a href="https://baike.baidu.com/item/HASH%E5%87%BD%E6%95%B0">Hash函数</a>对收到的<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%96%87">原文</a>产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<p>举个例子：移动客户端向服务器发送数据</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-643b048c3213f611.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端发送数据"></p>
<p>如果不做任何处理，可能会遭到中间人的窃取攻击，后果如何严重就不说了。那么我们如何防止中间人拦截，或者检查数据是否被篡改呢？<br>直接用RSA（<a href="www.jianshu.com/p/ad3d1dea63af">RSA加密原理</a>）进行加密应该是不满足我们的需求，RSA只适合对小数据进行加密，我们知道验证数据的完整性可以用Hash（<a href="www.jianshu.com/p/a6fca79eb89c">Hash概述</a>）来验证，可以对数据进行Hash，把Hash值和原始数据一起打包发送给服务器，服务器将原始数据进行Hash，得到的hash值和客户端发送的Hash值做对比，如果一致则保证数据有效性。但是这样会有安全隐患，如果中间人篡改了客户端发送的数据，当然也可以修改客户端发送的Hash值，所以这样操作不可行。</p>
<p>这时我们可以用RSA来对hash值进行保护，此时客户端发送原始数据，和经RSA加密后的该数据的hash值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-2570cf7be94ba279.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数字签名"></p>
<p>服务器对RSA加密的数据进行解密，得到原始数据的hash值，接下来对原始数据进行通过同样的Hash算法，将得到的Hash值和解密后的Hash值做对比，如果一致则保证数据有效性，整个过程中，如果解密的Hash值和原始的Hash值不一致，或者无法解密RSA的数据，说明数据被篡改了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-091add7525e628eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg"></p>
<p>现在我们解决了服务端收到客户端发送数据的有效性，此时我们称，对原始数据Hash值进行RSA加密后的数据，是原始数据的数字签名。简单解释数字签名也就是对原始数据的Hash值进行非对称加密。</p>
<h4 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h4><blockquote>
<p>代码签名是对可执行文件或脚本进行数字签名，用来标识软件来源以及软件开发者的真实身份，确认软件在签名后未被修改或损坏的措施。和数字签名原来一样，只不过签名的数据是代码而已。</p>
</blockquote>
<p>苹果也是通过代码签名来保证每一个安装到iOS上的APP都是经过苹果官方允许的，防止盗版软件、病毒入侵、静默安装等。如果想要实现验证，最简单的方式就是通过苹果官方生成非对称加密的一对公私钥，在iOS系统中内置一个与服务器对应的公钥，私钥由苹果后台来保存，我们传APP到App Store时，苹果后来用私钥对APP数据进行签名，iOS系统下载这个APP后，用公钥验证这个签名，如果签名正确则这个APP肯定是由苹果后台认证的，并且没有被修改或损坏。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-3f81b4ef5db3f1b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码签名"></p>
<p>整个过程很简单，这样就保证了苹果安装的每一个APP都是经过苹果官方允许的。对于大部分普通用户而言，这样一个数字签名就解决了安全隐患问题，但是实际上iOS设备安装APP并不是只有App Store这一个渠道，比如对于我们iOSer来说，我们在开发APP时还在真机调试，当然苹果还开放了企业内部分发的渠道，这时就无法通过简单的代码签名来满足这些需求了。</p>
<p>苹果为了实现这些需求，iOS签名的复杂度也就开始增加了，这样双层代码签名就出现了。前提，我们都知道描述文件，但是描述文件具体是干嘛的呢</p>
<h4 id="描述文件"><a href="#描述文件" class="headerlink" title="描述文件"></a>描述文件</h4><blockquote>
<p>在真机调试时候，都会有一个描述文件，描述文件就是在developer.apple.com创建的，在Xcode中填入AppID后会代办创建，Xcode运行时会打包进APP中。为了系统安全，苹果除了控制APP滥用问题还控制了推送、iCloud、调试器等附加这些权限，苹果把这些权限开关统一称为Entitlements（授权文件）。并将这个文件放在了一个叫做Provisioning Profile（描述文件）文件中，描述文件里面就包括权限、证书等配置相关文件。</p>
</blockquote>
<p>通常，描述文件会保存在~/Library/MobileDevice/Provisioning Profiles/这个文件中，可以在终端用 security cms -D -i  + [名称]命令查看描述文件里面的信息，我们会发现，描述文件是一个plist文件，下面是个人描述文件信息演示，并对一些信息做出了注释，部分关键内容被隐藏，Base64（<a href="www.jianshu.com/p/26f2ed1ed1f6">了解Base64编码解码</a>）内容被删减<br></p><pre class="line-numbers language-none"><code class="language-none">$ security cms -D -i 294b2de0-a877-4f33-9825-9a8***.mobileprovision 
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
	&lt;key&gt;AppIDName&lt;/key&gt;
	&lt;string&gt;com *** &lt;/string&gt;
	&lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt;
	&lt;array&gt;
	&lt;string&gt;***GCDB&lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;CreationDate&lt;/key&gt;
	&lt;date&gt;2019-03-06T08:54:06Z&lt;/date&gt;
	&lt;key&gt;Platform&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt;iOS&lt;/string&gt;
	&lt;/array&gt;
    &lt;key&gt;IsXcodeManaged&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;DeveloperCertificates&lt;/key&gt;
	&lt;array&gt;
		&lt;data&gt;***vcNAQELBQAwgZYxCzAJBgNVBAYTAlVTMRMwEQYDVQQKDApBcHBsZSBJbmMuMSwwKgYDVQQLDCNBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNzEwMDIzNsb3BtZW50IENvLixMdGQuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAO4xNm+/SXHwULul2Am4b+2/a919AfaDSy6Jw+nC3599RNhUlY+/PNTudcsBUsSw53+flAh6dVVGO77lebM1GaveXMLr65l9aZe2a6ewR0QOpSkvoBZBXlRA14WpyfdMbU7VlWutKiFHsuxA4KSQyoagY8GJ3tB5vSlxRtfix0TKtOCMx9v1iYdCztmhmtt5J6GZn8jKszkPgKxMNvm4MD9N/pr7/Z0gX06oywYb3DpS7uQKdffsLZyj05H0HvSg6V4nHZw5HNIf8qd1VjOiI7NGcvsOwltfGmiOhmxQjaESwalgX7vWg7ij8fh9ke1on8veQgptIxutKjLWG9JnJ2LPOeP7w3PJC03Yl89qJ6F0VAyA1+ck1ieimrG0yXkd9z/YWMd/puDoW7SmEQ/WdKyQkyld0iSnkQ90511uOAp0/yDgaaouyUDZlcIjL2/4JzdEJEiRkZEdmw63uYe4dwXSyTyLlA+ntka2QlKEiJmy8oyPTqjEuqcWWQmnFYWiEBqPaeEXlXT9uuGjqn9aN3MaTgD8QFIyOhonc6ReQHtx8apXGEzhVNAQXCLuKSB04JiCbL3YE2XT42QlygBL+7ROxC00pAIltrPkFfuoyBbpnj9pWQ==&lt;/data&gt;
		&lt;data&gt;***GVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNTI1MTMxMjA4WhcNMTkwNTI1MTMxMjA4WjCBrjEaMBgGCgmSJomT8ixkAQEMCjVFVE45NEpBNlUxMTAvBgNVBAMMKGlQaG9uZSBEZXZlbG9wZXI6IFhpbiBDaGVuZyAoNEU4Mk5RVzZDMikxEzARBgNVBAsMClpFV0pNSEdDREIxOzA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBvd2VyIERldmVsb3BtZW50IENvMDYGCCsGAQUFBwIBFipodHRwOi8dEU39NyqZsQBCA/P1txkkx9sI7JsMcMnjwa/N5QCg+gJLvMEh1ZvQ/rroTtyvDxFuuMrQkiZeeBGs8qBO2Jre6ma32mMo5kSjc9w9AtnFwlQHrW3+HPwwqlThRrMeNvbLZAvZhoENb04HE26sH4k1tk8CrNvutsjl+K3GGnuvWCnZy/dT57wrGAMrlkQZRWXomSxr9y+F4ArsMj+4UsA==&lt;/data&gt;
		&lt;data&gt;***sZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwNTEzMDQ1OTQ0WhcNMTkwNTEzMDQ1OTQ0WjCBrjEaMBgGCgmSJomT8ixkAQEMCjVFVE45NEpBNlUxMTAvBgNVBAMMKGlQaG9uZSBEZXZlbG9wZXI6IFhpbiBDaGVuZyAoNEU4Mk5RVzZDMikxEzARBgNVBAsMClpFV0pNSEdDREIxOzA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBByYWN0aWNlIHN0YXRlbWVudHMuMDYGCCsGAQUFBwIBFipodHRwOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwMwHQYzizUHwwrgDSFxwfGfc71fr4hz3PmN6o7XqtGcNO4Af49JdDMZv6VQ5mr/plPBSDdun0D5ZfNDr9cXopDCzy+XPZB/H1ARmy1MT4vuKvdsGuUKBvJX/HinDi38G6AuwZ0alfPY9xqJ7WB7K14kaVdaaqOHMThOA7b7b1Stu+MjAKYJ6aUkrf9vvDbDAkQFi8lfh4L3Vya9MoXEpDpCNxQrUJhc6sy2eMf1NT5Q==&lt;/data&gt;
		&lt;data&gt;***zA5BgNVBAoMMlNoYW5naGFpIFJpc2VuIEVsZWN0cmljIFBvd2VyIERldmVsb3BtZW50IENvLixMdGQuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKIWs9nQdTq3yqKLYVmjrGrgh6MhaWlkZb5MeHWKwGfky3/n/FaXmrLNxFFFWeFihdg4zmFjSjRl8ccvPF3afdZU2qW4Co1aKu459CnPhknFNbFtcrs0V1T6u6p3RJn6togsWn1z33IakruJPYtwY7k4S5jb20vb2NzcDAzLXd3ZHIwMTCCAR0GA1UdIASCARQwggEQMIIBDAYJKoZIhvdjZAUBMIH+MIHDBggrBgEFBQcCAjCBtgyBs1JlbGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMgYWNjZXB0YW5jZSBvZiB0aGUgdGVAFqGwKrYTc+8/GyszOm3u4/mn5s5b58ORnITE+A9bNtDGv6Qz46ev3ZMCrQZFwye//Tk+BI7ms4++jkj/pcmUCULtZw178cTRBpMT4P7tzgH5mRP/BpcSd/rv8994UXYPYdpXa4epFhchlCvu8dT8sQ38fFeahyd85nS30c4RxyW32bzKnzzRSedr/j4Y1qIIvzKdWPcnwkA5RYH8naxYfzEXL2321tdwfR5skvApeP/S2oX9WC+18XBk8Yy693rJoqrKdwkOzQSVGcA==&lt;/data&gt;
		&lt;data&gt;***3NjZOMlBGS00xMzAxBgNVBAMMKmlQaG9uZSBEZXZlbG9wZXI6IEhhb3lhbmcgWmh1IChLTU5VVTI4QlBaKTETMBEGA1UECwwKWkVXSk1IR0NEQjE7MDkGA1UECgwyU2hhbmdoYWkgUmlzZW4gRWxlY3RyaWMgUG93ZXIgRGV2ZWxvcG1lbnQgQ28uLEx0ZC4xCzAJBgNVBAYTAlVTMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA19bNzMNJ0uSYvwNygYH8b4GQY11UmNvbS9vY3NwMDMtd3dkcjAxMIIBHQYDVR0gBIIBFDCCARAwggEMBgkqhkiG92NkBQEwgf4wgcMGCY2QGAQIBAf8EAgUAMA0GCSqGSIb3DQEBCwUAA4IBAQCJw3MoEbhJNVyc1PFG6FtY7QZAy+gmqRz9YiwnFh3y5Qj5lnC2n0WdG8SrlZA+TKQgfwRZNEB6ZIfDZOJAFsqpBMAauC1V0CDzP8UWBDfluoVCU89Ns5juag8ffk/ulEQfEN1NakgiSwihy+QEmd2PWBTn4dfGVSV9mYRjPppFdM6kik1WLgMDZfLRmNzZ0MzMZMAPy8gdMmQiM7uBY1v+EnUXfyjKnK7Y28AB9c6oQHPoTGmVQxZjJgkejyOlBPWwVPbNvvzNRPuBaHI8muX2HzjsA9SJowEBXKICinqLSFZ8NDQVBrw2fgDs5MD5vaDHXtrz9t6Ahw6/7nUB240U&lt;/data&gt;
		&lt;data&gt;***LDCNBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFEMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwOTI1MDIxMzA4WhcNMTkwOTI1MDIxMzA4WjCBrzEaMBgGCgmSJomT8ixkAQEMCjIzVDNTWlo0WjQxMjAwBgNVBAMMKWlQaG9uZSBEZXZlbG9wZXI6IOS9s+a7qCDnjosgKDN1UdDgQWBBT7im/bw3RlTv0soM/RVB2mmh9e4zAOBgNVHQ8BAf8EBAMCB4AwEwYKKoZIhvdjZAYBAgEB/wQCBQAwDQYJKoZIhvcNAQELBQADggEBACErmsYfmt/qn5yj86poEkDsDWhznabHVn1CJprtzyHbXNcbKJE1pY99ACzSUVW9iGaxXJ9m5dWmZsd+2gxOBthFDq4mSpU50OHQgg9AjjugvsQ+OH1r1qgqcJMPdLN4stJtkAC9Mb/rt3AYA5eEdHOXbhrsE3TXWmWfJzYS9PFyarGcJ9xFAWg76jTtFA6nlzYtl/YyMDS6Z075oMzKG/pRfCI13P4AqRKdx/DBtz4x0Wv59LVMVrXa4bfePLKMBJrBFdiiyCy4k4BIx4weG/Y/8OsEkmWkN0fDWmi4MZjy3I+FCNkv9tUzI/vRvDEiNR7qo5rGRKnAi+X1QbdLYcU=&lt;/data&gt;
		&lt;data&gt;***o0WjQxMjAwBgNVBAMMKWlQaG9uZSBEZXZlbG9wZXI6IOS9s+a7qCDnjosgKDNYTDJNRFdWOUcpMRMwEQYDVQQLDApaRVdKTUhHQ0RCMTswOQYDVQQKDDJTaGFuZ2hhaSBSaXNlbiBFbGVjdHJpYyBQb3dlciBEZXZlbG9wbWVudCBDby4sTHRkLjELMAkGA1UEBhMCVVMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC35nKt/AoSiANJn9e9H96rol/85zSEAjAAMB8GA1UdIwQYMBaAFIgnFwmpthhgi+zruvZHWcVSVKO3MD8GCCsGAQUFBwEBBDMwMTAvBggr1UdJQEB/wQMMAoGCCsGAQUFBwMDMB0GA1UdDgQWBBSIeBiIaX4EyW39H2laObRLnSyWVjAOBgNVHQ8BAf8EBAMCB4AwEwYKKoZIhvdjZAYBAgEB/wQCyETSZ/FOr8EBZBVLmMGXz03x6f2Hpd7QsmoJJM5+6hHu4qgstgXNg0RRsa0B4jScKTMlRxmdZuLjm3plaX+P+yo0ylAnvGWm1sx9mxPTgrDbUg7Rg0n1bhrBtkX47+r8SUz4+E6dHnqZ7x48hZlhv6SFkj4PQ/apeAvITvnLeq7bj586gkpwS30bjmrsqSO8aEnysvyxq6Xx3+seH9Uihmjb7XdnV25mKfbf5ms6sm+HrN6ifrDb0LePX8YAsSH4=&lt;/data&gt;
	&lt;/array&gt;


	&lt;key&gt;Entitlements&lt;/key&gt;      // 权限
	&lt;dict&gt;
		&lt;key&gt;keychain-access-groups&lt;/key&gt;
		&lt;array&gt;
			&lt;string&gt; *** .*&lt;/string&gt;		
		&lt;/array&gt;
		&lt;key&gt;get-task-allow&lt;/key&gt;    // APP是否允许调试
		&lt;true/&gt;
		&lt;key&gt;application-identifier&lt;/key&gt;    // appID
		&lt;string&gt; *** &lt;/string&gt;
		&lt;key&gt;com.apple.developer.associated-domains&lt;/key&gt;
		&lt;string&gt;*&lt;/string&gt;
		&lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
		&lt;string&gt; *** &lt;/string&gt;
		&lt;key&gt;aps-environment&lt;/key&gt;
		&lt;string&gt;development&lt;/string&gt;

	&lt;/dict&gt;
	&lt;key&gt;ExpirationDate&lt;/key&gt;    // 过期时间
	&lt;date&gt;2020-03-05T08:54:06Z&lt;/date&gt;
	&lt;key&gt;Name&lt;/key&gt;
	&lt;string&gt;iOS Team Provisioning Profile: *** &lt;/string&gt;
	&lt;key&gt;ProvisionedDevices&lt;/key&gt;    // 设备列表
	&lt;array&gt;
		&lt;string&gt;476c21e91700a0605a11a***3de7705a&lt;/string&gt;
		&lt;string&gt;98a1263783fb5538ec292f0***9d05690ffb&lt;/string&gt;
		&lt;string&gt;bc9144d7496e5337e1f***cb653dc42e&lt;/string&gt;
		&lt;string&gt;254fbcad0126f989b8980***d1dd8169b6ca&lt;/string&gt;
		&lt;string&gt;349f7aeb300473cc30c28***025d&lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;TeamIdentifier&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt; *** &lt;/string&gt;
	&lt;/array&gt;
	&lt;key&gt;TeamName&lt;/key&gt;
	&lt;string&gt; *** Co.,Ltd.&lt;/string&gt;
	&lt;key&gt;TimeToLive&lt;/key&gt;
	&lt;integer&gt;365&lt;/integer&gt;
	&lt;key&gt;UUID&lt;/key&gt;    // 描述文件的UUID
	&lt;string&gt; *** &lt;/string&gt;
	&lt;key&gt;Version&lt;/key&gt;
	&lt;integer&gt;1&lt;/integer&gt;
&lt;/dict&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h4 id="双层代码签名"><a href="#双层代码签名" class="headerlink" title="双层代码签名"></a>双层代码签名</h4><ul>
<li>请求证书<br>开发过程中，首先Mac电脑（比如Xcode）会自动生成一对公私钥</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-6ec3926ede28d14e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公私钥"></p>
<p>图中的证书就是公钥M，专用密钥就是私钥M（也就是我们导出的P12文件）</p>
<p>用一个CSR文件（就是在钥匙串访问中，证书助理，从证书颁发机构中获取的）向苹果申请一个证书，这个CSR文件主要包含了一个公钥文件，还有一些信息，比如邮箱、名字、签名信息、Hash值等等，苹果收到请求后，会用私钥A将公钥M进行签名，以供苹果设备进行验证（用公钥A进行验证）。苹果服务器将公钥M和签名信息打包成证书，并把appID、证书、设备IDs、权限文件等放入描述文件一并返回给Mac电脑，以备Mac电脑用这个描述文件中的证书到iOS设备去验证。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-0df7c92d9f6b22ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求证书"></p>
<ul>
<li>生成IPA文件，发送到iOS设备上<br>iOS设备上的APP其实都是文件夹，最重要的是可执行文件MachO和framework，APP签名也就是对它俩进行签名，通过Mac电脑的私钥M对文件进行签名，把这个签名和从苹果申请的描述文件一并放入到APP中。当安装APP时，iOS设备用公钥A来解析描述文件中的证书进行验证证书的有效性，通过之后将证书中的公钥M拿出来，再去验证APP签名的有效性，这样就可以验证当前APP是否是苹果官方允许的。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-92f2a337c5fac6e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双层代码签名"></p>
<p>在开发阶段，我们需要频繁的改动程序跑真机，苹果不需要关心这些，所以iOS设备没有对APP的更改进行验证，只是验证证书（公钥M是不是合法的，APP签名的有效性）。这样解决了安装问题，但是如果这样的话，可以在任何一部iOS设备上安装APP，苹果防止开发者滥用，又加了两个限制：</p>
<ol>
<li>要在苹果后台注册过的设备才可以安装</li>
<li>签名只能针对具体的某一个APP进行签名</li>
</ol>
<h4 id="关于APP签名"><a href="#关于APP签名" class="headerlink" title="关于APP签名"></a>关于APP签名</h4><blockquote>
<p>在开发中，编译一个APP后，用本地的私钥M对APP进行签名，同时把从苹果服务器得到的Provisioning Profile文件打包进APP中，文件名为embedded.mobileprovision，把APP安装到iOS设备后，系统进行验证。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/5741330-212efe0fca5a83df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看资源文件签名"></p>
<p>查看APP的包内容，里面会有_CodeSignature文件夹（里面的就是资源文件的签名），还有个可执行文件，可以用MachO查看，里面的Code signature就是应用签名。</p>
<p>该文章为记录本人的学习路程，希望能够帮助大家！！！</p>
]]></content>
      <categories>
        <category>签名</category>
        <category>加密原理</category>
      </categories>
      <tags>
        <tag>非对称加密原理</tag>
        <tag>数字签名</tag>
        <tag>代码签名</tag>
        <tag>双层代码签名</tag>
      </tags>
  </entry>
</search>
